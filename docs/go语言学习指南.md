---
title: go语言学习指南
tags:
  - golang
  - go
  - 开发
  - 编程语言
author: kubei
created: 2024-04-17
---
## 一、Go语言的概述

## 1. go语言的起源

- Go语言起源于2007年，并于2009年正式对外发布。它从2009年9月21日开始作为谷歌公司20%的兼职项目，即相关员工利用20%的空余时间来参与Go语言的研发工作。
  - 这三位领导者均是著名的 IT 工程师：
    - Robert Griesemer，参与开发 Java HotSpot 虚拟机；
    - Rob Pike，Go 语言项目负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和Limbo 编程语言；
    - Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以C语言为目标结果的编译器来拓展Go语言的设计思想。

- **创造go语言的原因：**
  - 计算机硬件技术更新频繁，性能提高很快。日前主流的编程语言发展明显落后于硬件，不能合理利用多核多CPU的优势提升软件系统性能。
  - 软件系统复杂度越来越高，维护成本越来越高，目前缺乏一个足够简洁高效的编程语言。现有的编程语言：1.风格不统一2.计算能力不够3.处理大并发不够好）
  - 企业运行维护很多c/c++的项目，c/c++程序运行速度虽然很快，但是编译速度确很慢，同时还存在内存泄漏的一系列的困扰需要解决
- 时间轴：
  - 2007年9月21日：雏形设计
  - 2009年11月10日：首次公开发布
  - 2010年1月8日：当选2009年年度语言
  - 2010年5月：谷歌投入使用
  - 2011年5月5日：Google App Engine支持Go语言
  - 2015年8月19日： Go1.5版本发布，移除了最后残遗的C代码
  - 2017年2月17日：Go1.8版本发布
  - 2017年8月24日： Go1.9版本发布
  - 2018年2月16日：Go1.10版本发布

## 2. go语言的特点

- Go语言保证了既能到达静态编译语言的安全和性能，又达到了动态语言开发维护的高效率，使用一个表达式来形容Go语言：Go=C+Python，说明Go语言既有C静态语言程序的运行速度，又能达到Python动态语言的快速开发
  - 从C语言中继承了很多理念，包括表达式语法，控制结构，基础数据类型，调用参数传值，指针等等，也保留了和C语言一样的编译执行方式及弱化的指针
  - 引入了包的概念，用于组织程序结构，Go语言的一个文件都要属于一个包，不能单独存在
  - 垃圾回收机制，内存自动回收
  - 天然支持高并发，用户代码运行于轻量级goroutine内，可实现高并发处理，高效利用多核
  - 完整工具链和丰富标准库
  - 支持多平台和主流架构
  - 吸收了管道通信机制，形成Go语言特有的管道channel通过管道channel，可以实现不同的goroute之间的相互通信

## 3. go语言概述小结

- 简化问题，易学习，易部署
- 静态类型，编译速度快
- 高效开发，高效执行
- 标准类库，规范统一
- 天然并发，内存回收

# 二、go语言安装

## 1. 下载sdk

- [下载地址](https://go.dev/dl/)

![image-20230813230317369](https://cloud.006288.xyz/PicGo/image-20230813230317369.png)

## 2. 安装go

- windows端：
  - 点击下载的sdk运行安装
  - 安装目录不要有中文和特殊符号

- linux端：

  - 将sdk安装包上传到linux上某个目录上（例如/opt目录）
  - 解压安装包，将安装包解压到指定目录（看个人习惯，/usr/local)

  ``` 
  tar -xzvf "go安装包" -C /usr/local
  ```

## 3. 配置环境变量

- 目前我们先采用GOPATH方式来进行包管理,后面我们将采用go mod方式,如果想直接采用go mod可以提前使用[[#13.2.2 Go Modules 模式]]

- windows:

| 环境变量 |              说明              |
| :------: | :----------------------------: |
|  GOROOT  |       指定SDK的安装路径        |
|   Path   |       添加sdk的/bin目录        |
|  GOPATH  | 工作目录，将来go项目的工作路径 |

- linxu：

```bash
vim /etc/profile

export GOROOT=/usr/local/go
export GOPATH=/code/go
export PATH=$PATH:$GOPATH/bin
```

- 验证是否安装成功

```bash
go version
```

## 4. go常用命令

```go
go env用于打印Go语言的环境信息。
go run命令可以编译并运行命令源码文件。
go get可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，并对它们进行编译和安装。
go build命令用于编译我们指定的源码文件或代码包以及它们的依赖包。
go install用于编译并安装指定的代码包及它们的依赖包。
go clean命令会删除掉执行其它命令时产生的一些文件和目录。
go doc命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。
go test命令用于对Go语言编写的程序进行测试。
go list命令的作用是列出指定的代码包的信息。
go fix会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码
go vet是一个用于检查Go语言源码中静态错误的简单工具。
go tool pprof命令来交互式的访问概要文件的内容
```

## 5.go语言开发注意事项

- go的源文件以.go结尾
- go语言程序执行的入口函数是main()函数
- go语言定义的变量和导入的包如果没使用到会报错
- go语言严格区分大小写，每行语句后不需要分号

- 标识符命名时需要注意：
  - 只能由非空字母(Unicode)、数字、下划线(_)组成 
  - 只能以字母或下划线开头 
  - 不能 Go 语言关键字 
  - 避免使用 Go 语言预定义标识符 
  -  建议使用驼峰式
  - 标识符区分大小写
- Go 语言提供一些预先定义的标识符用来表示内置的常量、类型、函数，在自定义标识符时 应避免使用： 
  -  内置常量：true、false、nil、iota 
  - 内置类型：bool、byte、rune、int、int8、int16、int32、int64、uint、uint8、unit16、 unit32、unit64、uintptr、float32、float64、complex64、complex128、string、error 
  -  内置函数：make、len、cap、new、append、copy、close、delete、complex、real、 imag、panic、recover 
  -  空白标识符:_
- 关键字用于特定的语法结构，Go 语言定义 25 关键字： 
  - 声明：import、package 
  - 实体声明和定义：chan、const、func、interface、map、struct、type、var 
  - 流程控制：break、case、continue、default、defer、else、fallthrough、for、go、goto、 if、range、return、select、switch



- go语言项目结构

![image-20230814000210532](https://cloud.006288.xyz/PicGo/image-20230814000210532.png)

# 三、go语言的基本语法

## 1. 注释

### 1.1 注释概述

- 对代码进行解释说明，在程序执行时不会执行的语句
- 注释可以提高代码的阅读性，降低维护成本

### 1.2 go语言注释

- go语言注释分为：行注释和块注释
- 基本语法：

```go
// 行注释

/*
...
块注释
*/
```

## 2. 常量

### 2.1 常量概述

- 常量用于定义不可被修改的的值，需要在编译过程中进行计算，只能为基础的数据类型布尔、 数值、字符串，使用 const 进行常量声明，常用语法：

```go
const 常量名 类型 = 值
定义常量并进行初始化，例如：const pi float64 = 3.1415926


const 常量名 = 值
定义常量，类型通过值类型进行推导，例如：const e = 2.7182818

// 批量定义
const (
    常量名 1 类型 1 = 值 1
    常量名 2 类型 2 = 值 2
)
定义多个变量并进行初始化，批量复制中变量类型可省略，并且除了第一个常量值外其他常量可同时省略类型和值，表示使用前一个常量的初始化表达式
```

### 2.2 枚举

- Go 语言并没有像其他编程语言（如 C++ 和 Java）中那样的传统枚举类型。然而，Go 中有一种常见的模拟枚举的方式，使用 `const` 定义一组具有相同类型的常量来表示枚举值。这种方式虽然不同于传统的枚举，但也能够满足类似的需求

- 使用 iota 生成器用于初始化一系列相同规则的常量，批量声明常量的第一个常量使用 iota 进行赋值，此时 iota 被重置为 0，其他常量省略类型和赋值，在每初始化一个常量则 加 1

```go
package main

import "fmt"

func main() {
	const (
		a2 = iota
		a3
		a4
		a5 int = 10
	)
	fmt.Printf("a2: %d \na3: %d \na4: %d \na5: %d \n", a2, a3, a4, a5)
}
```



## 3. 变量

### 3.1 变量概述

- 变量是指对一块存储空间定义名称，通过名称对存储空间的内容进行访问或修改，使用 var 进行变量声明，常用的语法为:

```go
var 变量名 变量类型 = 值
定义变量并进行初始化，例如：var name string = "silence"

var 变量名 变量类型
定义变量使用默认值进行初始化，例如：var age int

var 变量名 = 值
定义变量，变量类型通过值类型进行推导
例如： var isBoy = true

var 变量名 1, 变量名 2 , …, 变量名 n 变量类型
定义多个相同类型的变量并使用零值进行初始化
例如：var prefix, suffix string

var 变量名 1, 变量名 2 , …, 变量名 n 变量类型 = 值 1, 值 2, …, 值 n
定义多个相同类型的变量并使用对应的值进行初始化，例如：var prev, next int = 3,4

var 变量名 1, 变量名 2 , …, 变量名 n = 值 1, 值 2, …, 值 n
定义多个变量并使用对应的值进行初始化，变量的类型使用值类型进行推导，类型可不
相同，例如：var name, age = "silence", 30

//批量定义
var (
变量名 1 变量类型 1 = 值 1
变量名 2 变量类型 2 = 值 2
)
定义多个变量并进行初始化，批量复制中变量类型可省略

// 简短写法
变量名 := 值
省略关键字和变量类型，但是需要确保该变量没有被定义g
```

### 3.2 变量的使用步骤

- 声明变量
- 给变量赋值
- 使用变量

``` go
// 变量使用示例

package main

import "fmt"

func main() {
	// 声明变量
	var name string

	// 给变量赋值
	name = "Tom"

	// 使用变量
	fmt.Printf("my name is %s\t", name)
}
```

## 4. 输入与输出

### 4.1 格式化动作

- [官方文档](https://studygolang.com/static/pkgdoc/pkg/fmt.htm#pkg-index)

```go
// 占位符：
%v：默认格式，可以用于任何数据类型。
%d：十进制整数。
%f：浮点数。
%s：字符串。
%t：布尔值。
%c：字符（Unicode 代码点）。
%q：带有引号的字符串。

// 宽度和精度控制：

%5d：输出最少宽度为 5 的整数，不足补空格。
%.2f：保留两位小数的浮点数。
%10s：输出最少宽度为 10 的字符串，不足补空格。

// 对齐和填充：
%10s：右对齐字符串，总宽度为 10。
%-10s：左对齐字符串，总宽度为 10。
%05d：在数字前填充 0，总宽度为 5

//类型相关格式化：
%T：打印变量的类型

// 格式化组合：
%d-%d-%d：多个占位符的组合，可以用于日期等。

//打印特殊字符：
%%：输出百分号。
\n：换行。
\t：制表符
```

![img](https://cloud.006288.xyz/PicGo/1199d7de63d94475b162a24ff306ba07.png)

![img](https://cloud.006288.xyz/PicGo/c69313e48d244e028df59e63c2c96049.png)

### 4.2 输入

- 数据输入(DataInput)是当程序在运行过程中,将系统外部原始数据通过标准输入设备传输给系统内部,并将这些数据以外部格式转换为系统便于处理的内部格式的过程,其方式与使用的输人设备密切相关(比如键盘)。在Go标准库fmt包中,有三种标准输入函数Scan()、Scanf()和Scanln()

#### 4.2.1 Scan()函数

- [Scan()函](https://github.com/golang/go/blob/master/src/fmt/scan.go?name=release#71)数的功能是从标准输入设备读取数据，并将使用空格分割的连续数据顺序存入到参数里,换行也将被视为空格。Scan()函数调用成功，返回正确读取的参数的数量n; 如果少于要求提供的参数数量,函数返回err并报告错误原因

- Scan注意事项：
  - 在使用Scan()时，用户输入完成后会返回两个值
    - count: 记录输入正确的个数
    - err：用户输入错误，提示错误信息
  - 当输入多个值的时候，要用空格分开输入
  - 若不想使用某一个返回值可以用_来接收，若两个返回值都不想要只是单纯的输入，那就直接写等号后面的即可
  - `Scan()`要求，若要输入两个值，那就必须输入两个，若要输入三个值，那就必须是三个。否则程序会一直等待，不会执行下面的程序 



- Scan()使用示例：

```go
package main

import "fmt"

func main() {
	var (
		name string
		age  int
	)
	fmt.Print("请输入你的姓名和年龄:")
    // 如果不需要Scan返回值，可以使用_屏蔽返回值
	count, err := fmt.Scan(&name, &age)  
	if err == nil {
		fmt.Printf("你的姓名: %v, 你的年龄: %d, 你一共输入: %d 个有效值", name, age, count)
	} else {
		fmt.Println("你的输入有误,请重新输入")
	}

}

---> 输出：
请输入你的姓名和年龄:Tom 23    
你的姓名: Tom, 你的年龄: 23, 你一共输入: 2 个有效值

请输入你的姓名和年龄:23 Tom
你的输入有误,请重新输入
```

#### 4.2.2 Scanln()函数

- `Scan()`与[Scanln()](https://studygolang.com/static/pkgdoc/pkg/fmt.htm#pkg-index)用法与功能效果完全一样，但有一个不同点：
  - `Scan()`要求，若要输入两个值，那就必须输入两个，若要输入三个值，那就必须是三个。否则程序会一直等待，不会执行下面的程序, `Scan()`必须等待所要求的值输入完成才能执行程序
  - `Scanln()`没有这个强制的要求，如果要求我们输入两个值，但只输入一个值，那么回车后程序依然会执行,`Scanln()`不管输入的数据是否完成，只要回车就直接执行

```go
package main

import "fmt"

func main() {
	var (
		name string
		age  int
	)
	fmt.Print("请输入你的姓名和年龄:")
	count, err := fmt.Scanln(&name, &age)
	if err == nil {
		fmt.Printf("你的姓名: %v, 你的年龄: %d, 你一共输入: %d 个有效值", name, age, count)
		//fmt.Printf("你的姓名: %v, 你的年龄: %d", name, age)
	} else {
		fmt.Println("你的输入有误,请重新输入")
	}

}

---> 输出
请输入你的姓名和年龄:Tom
你的输入有误,请重新输入
```

#### 4.2.3 Scanf()函数

- [Scanf()](https://studygolang.com/static/pkgdoc/pkg/fmt.htm#pkg-index)也有两个返回值count和err；
- 如果在`Scanf()`中写了两个输入值但是只输入一个，那样未输入的值就是该值类型的默认值；
- 支持用户格式化输入

```go
package main

import "fmt"

func main() {
	var (
		name string
		age  int
	)
	fmt.Print("请输入你的姓名和年龄:")
	count, err := fmt.Scanf("%v %d", &name, &age)
	if err == nil {
		fmt.Printf("你的姓名: %v, 你的年龄: %d, 你一共输入: %d 个有效值", name, age, count)
	} else {
		fmt.Println("你的输入有误,请重新输入")
	}

}
```

### 4.3 输出

- 数据输出(Data Output),是计算机对各类输入数据进行加工处理后,将结果以用户所要求的形式输出到标准输出设备上(比如显示器)。在Go标准库的fmt包中,有三种标准输出函数: Print()、Printf()和Println()

#### 4.3.1 Print()函数

- [Print()](https://studygolang.com/static/pkgdoc/pkg/fmt.htm#pkg-index)函数的功能是按照系统默认格式字符串和参数表,生成一个打印字符串，然后再将其输出到标准输出设备上，输出时会在操作数之间自动加上空格。Print()函数执行后会返回输出的字节数或错误类型， Print()函数不支持格式化输出，所以像回车、换行这些操作要用户自己来控制

```go
package main

import "fmt"

func main() {
	var (
		name string
		age  int
	)
	name = "Tom"
	age = 23

	fmt.Print(name, age)

}
```

#### 4.3.2 Println()函数

- [Println()](https://studygolang.com/static/pkgdoc/pkg/fmt.htm#pkg-index)函数和Print()函数的功能基本一致,不同的是Println()函数会在输出结束后再自动输出一个换行

```go
package main

import "fmt"

func main() {
	var (
		name string
		age  int
	)
	name = "Tom"
	age = 23

	fmt.Println(name, age)

}
```

#### 4.3.3 Printf()函数

- Print()和Println()函数都是采用默认格式输出数据，如果要按照更灵活的格式输出数据就要使用Printf()函数， [Printf()](https://studygolang.com/static/pkgdoc/pkg/fmt.htm#pkg-index)会按照格式化(format)字符串将操作数格式化输出到标准输出设备上,Printf()函数也会返回输出的字节数和错误类型  

```go
package main

import "fmt"

func main() {
	var (
		name string
		age  int
	)
	fmt.Print("请输入你的姓名和年龄:")
	count, err := fmt.Scanf("%v %d", &name, &age)
	if err == nil {
		fmt.Printf("你的姓名: %v, 你的年龄: %d, 你一共输入: %d 个有效值", name, age, count)
	} else {
		fmt.Println("你的输入有误,请重新输入")
	}

}
```

### 4.4 获取命令行参数

- 使用 `os` 包提供的 `Args` 变量来获取命令行参数。`Args` 是一个字符串切片，其中包括了程序名称和在命令行上指定的参数, 其中第一个元素是程序的名称，其余的元素是传递给程序的参数

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// os.Args 切片包含了所有的命令行参数
	args := os.Args

	// 第一个元素是程序的名称
	programName := args[0]
	fmt.Println("程序名称:", programName)

	// 其余的元素是传递给程序的参数
	// 注意：os.Args 切片的第一个元素是程序的名称，而不是实际的参数
	if len(args) > 1 {
		fmt.Println("传递给程序的参数:")
		for _, arg := range args[1:] {
			fmt.Println(arg)
		}
	} else {
		fmt.Println("没有传递参数给程序.")
	}
}

// 命令行参数
go run .\demo.go name age add
程序名称: demo.exe
传递给程序的参数:
name
age
add
```

- 解析命令行参数

  - 在Go语言中，有几个常用的库用于解析命令行参数，其中最常见的是标准库中的 `flag` 包。除了 `flag` 包外，还有一些第三方库，例如 `cobra`、`kingpin`、`pflag` 等，它们提供了更丰富的功能和更高级的用

  

- 使用`flag` 包解析命令行参数

  - 前面的方式是比较原生的方式, 解析参数不是特别的方便，特别是带有指定参数形式的命令行
  - `flag` 包提供了一种简单而灵活的方式来定义和解析命令行选项。你可以使用 `flag` 包的函数，如 `flag.String`、`flag.Int`、`flag.Bool` 等，轻松地定义不同类型的命令行选项。
  - 通过使用 `flag` 包，你可以很容易地生成帮助信息。`flag` 包可以识别 `-h`、`--help` 等参数，并自动生成帮助信息，显示所有定义的命令行选项及其说明。
  - `flag` 包提供了对不同数据类型的支持，包括字符串、整数、布尔值等。当你定义一个命令行选项时，你可以指定它的类型，从而确保在解析时得到正确类型的值。
  - 可以为命令行选项指定默认值，这在处理未提供特定参数时很有用。
  - `flag` 包允许定义短选项（如 `-f`）和长选项（如 `--file`）。这提供了更灵活的命令行接口，让用户可以根据自己的偏好选择使用哪种形式。
  - 可以将多个选项组合在一起，形成一个命令行接口，而不需要手动解析和处理参数

```go
package main

import (
	"flag"
	"fmt"
)

func main() {
	var (
		username string
		password string
		host     string
		port     int
	)

	flag.StringVar(&username, "u", "root", "用户名: ")
	flag.StringVar(&password, "p", "", "密码: ")
	flag.StringVar(&host, "h", "", "ip地址: ")
	flag.IntVar(&port, "P", 22, "端口号: ")

	flag.Parse()

	fmt.Printf("%v@%v:%v %v\n", username, host, port, password)
}
```



## 5. go语言基本数据类型

![mark](https://cloud.006288.xyz/PicGo/t1jRSgll4p1M.png)

### 5.1 整数型

- 用于存放整数数值的数据类型，包括正整数和负整数

#### 5.1.1 有符号类型

| 类型  | 占用空间 | 表示范围      |
| ----- | -------- | ------------- |
| int8  | 1字节    | -128~127      |
| int16 | 2字节    | -2^15 ~2^15-1 |
| int32 | 4字节    | -2^31~2^31    |
| int64 | 8字节    | -2^63~2^63-1  |

#### 5.1.2 无符号类型

| 类型    | 占用存储空间 | 表示范围 |
| ------- | ------------ | -------- |
| unint8  | 1字节        | 0~255    |
| unint16 | 2字节        | 0~2^16-1 |
| unint32 | 4字节        | 0~2^32-1 |
| unint64 | 8字节        | 0~2^64-1 |

#### 5.1.3 特殊类型

| 类型    | 占用空间                                         | 表示范围                        |
| ------- | ------------------------------------------------ | ------------------------------- |
| int     | 与平台有关，32 位 系统 4 字节，64 位 系统 8 字节 | 有符号整型                      |
| uint    | 与平台有关，32 位 系统 4 字节，64 位 系统 8 字节 | 无符号整形                      |
| byte    | 1 字节                                           | 字节类型，取值范围同 uint8      |
| rune    | 4 字节                                           | Unicode 码点，取值范围同 uint32 |
| uintptr | 与平台有关，32 位 系统 4 字节，64 位 系统 8 字节 | 指针值的无符号整型              |

#### 5.1.4 整型数据类型注意事项

- 整型默认数据声明时int型
- 查看变量数据类型使用%T,查看字节大小使用unsafe.Sizeof("变量")
- go程序在使用变量时遵循保小不保大的原则: 在保证程序正常运行下,尽量使用占用空间较小的数据类型
- bit是计算机中最小的存储单位,byte是计算中基本存储单位

### 5.2 浮点型

- 用于存放小数的数据类型

- Go 提供 float32 和 float64 两种浮点类型

| 类型          | 占用空间 | 表示范围               |
| ------------- | -------- | ---------------------- |
| 单精度float32 | 4字节    | -3.403E38 ~ 3.403E38   |
| 双精度float64 | 8字节    | -1.798E308 ~ 1.798E308 |

- 浮点数注意事项:
  - 浮点数都是有符号的,0表示正数,1表示负数
  - 浮点数在计算中的存放形式: 浮点数= 符号位+指数位+尾数位,在存储过程中尾数可能会丢失
  - float64要比floa32更准确
  - 浮点数默认声明是floa64
  - 浮点数有两种表示方法:
    - 十进制:  5.12
    - 科学计数法: 5.12e2 = 5.12*10^2  ;   5.12e-2 = 0.0512 * 10 ^2 

### 5.3 布尔类型

- 布尔类型用于表示真假，类型名为 bool，只有两个值 true 和 false，占用1个字节宽度， 0值为 false

### 5.4 字符串类型

- 字符串就是一串固定长度的字符连接起来的字符序列, 使用 string 表示。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本
- 字符串有两种表现形式:
  - 字符串通过双引号"来创建，不能包含多行，支持特殊字符转义序列 

- 原生字符串：通过反引号`来创建，可包含多行，不支持特殊字符转义序列
- 字符串是不可变数据类型,一旦赋值就不能修改了
- 字符串拼接使用加号+处理

### 5.5 基本数据类型的默认值

- 在go中，数据类型都有一个默认值，当程序员没有赋值时，就会保留默认值，在go中，默认值又叫零值

| 数据类型 | 默认值 |
| -------- | ------ |
| 整型     | 0      |
| 浮点型   | 0      |
| 字符串   | ""     |
| bool类型 | false  |

### 5.6 基本数据类型转换

- Go 不会对自动对数据类型转换，因此左、右操作数类型必须一致或某个字面量，可通过 类型名(数据)的语法将数据转换为对应类型。需要注意值截断和值溢出问题

#### 5.6.1 基本语法

```go
// 基本语法
表达式T(v) // 将值v 转化成类型T
T: 就是数据类型
v: 就是需要转换的值
```

- 案例演示

```go
package main

import "fmt"

func main() {
	var (
		i int64 = 100
		j float64
		q string
	)

	// 将i 转化成浮点型
	j = float64(i)
	// 将i 转化成字符串
	q = string(i)

	fmt.Printf("i的数据类型是: %T, 值是: %d \n", i, i)
	fmt.Printf("j的数据类型是: %T, 值是: %f \n", j, j)
	fmt.Printf("q的数据类型是: %T, 值是: %v \n", q, q)

}
```

#### 5.6.2 将其他基本数据类型转化成字符串

- **使用 `fmt.Sprintf`("%参数", 表达式)：** 这是一种格式化字符串的方式，可以将不同类型的数据格式化为字符串并返回。这个方法非常灵活，适用于多种数据类型

```go
numInt := 42
strFromInt := fmt.Sprintf("%d", numInt)    // 参数需要和表达式数据类型相匹配
```

- **使用[strconv](https://studygolang.com/static/pkgdoc/pkg/strconv.htm#pkg-index)包函数 **
  - strconv.FormatInt:  将整数转换为字符串，可以指定格式和精度
  - strconv.FormatFloat 将浮点数数转换为字符串，可以指定格式和精度
  - strconv.FormatBool： 将布尔值转换为字符串

```go
numFloat := 3.14159
strFromFloat := strconv.FormatFloat(numFloat, 'f', 2, 64) // f:格式化  2: 保留2位小数, 64: 表示使用float64


boolVal := true
strFromBool := strconv.FormatBool(boolVal)
```

#### 5.6.3 基本数据类型转化注意事项

- 数据类型可以从小范围转换到大范围,也可以从大范围转化到小范围, 但会有数据丢失(溢出),因此数据转换是需要考虑范围
- 被转化的是变量存储的值,变量本身的数据类型没有变化

### 5.7 指针

- 每个变量在内存中都有对应存储位置（内存地址），可以通过&运算符获取。
- 指针也是一个变量，但它是一种特殊的变量, 指针是用来存储 变量地址的变量, 获取变量的的地址使用&变量
- 指针声明需要指定存储地址中对应数据的类型，并使用*作为类型前缀(使用`*数据类型`声明一个指针)。指针变量声明 后会被初始化为 nil，表示空指针
- 指针本身也会有一个地址

```go
package main

import "fmt"

func main() {
	var num1 int = 100
	fmt.Printf("num1的值为: %v, num1的类型: %T, num1的内存地址为： %p\n", num1, num1, &num1)
	var num2 *int = &num1 // *
	fmt.Printf("num2的值为: %v, num2的类型为: %T, num2的内存地址为：%p\n", num2, num2, &num2)
}


---->输出
num1的值为: 100, num1的类型: int, num1的内存地址为： 0xc0000180a8
num2的值为: 0xc0000180a8, num2的类型为: *int, num2的内存地址为：0xc00000a030
```

![image-20230624003135435](https://cloud.006288.xyz/PicGo/image-20230624003135435.png)

- 指针示例

```go
// 指针练习题
/* 题目：
写一个程序，获取一个int变量的内存地址
将变量的内存地址赋值给指针，并通过指针区修改变量的值
*/

package main

import (
	"fmt"
)

func main() {
	// 定义一个变量
	var num int = 100

	// 获取变量的值和内存地址
	fmt.Printf("num的值为：%v, num的内存地址为： %p\n", num, &num)

	// 将num的内存地址赋值给指针
	var ptr *int = &num
	// 修改变量值
	*ptr = 200 // 此时 ptr等于num的内存地址，*ptr就等于num，此时修改*ptr的值，就等修改num的值
	fmt.Printf("num是否等于*ptr：%t,  ptr是否等于num的内存地址： %t\n", num == *ptr, ptr == &num)
	fmt.Printf("ptr的值为：%v, ptr的内存地址为：%p, num的值为：%v, num的内存地址为：%p\n", ptr, &ptr, num, &num)
}

--->输出
num的值为：100, num的内存地址为： 0xc0000180a8
num是否等于*ptr：true,  ptr是否等于num的内存地址： true
ptr的值为：0xc0000180a8, ptr的内存地址为：0xc00000a030, num的值为：200, num的内存地址为：0xc0000180a8 
```

- 指针注意事项

  - 空指针

  ```go
  var ptr *int
  fmt.Println(ptr)
  ```

  - 不要操作没有合法指向的内存

  ```go
  // 错误示例
  var ptr *int
  *ptr = 100
  fmt.Println(ptr)
  ```

- new函数的使用
  - 开辟数据类型对应的内存空间 返回值为数据类型指针

```go
package main

import "fmt"

func main() {
	var ptr1 *int
	ptr1 = new(int)
	fmt.Println(*ptr1)
	fmt.Println(ptr1)
}
```

- 多级指针
  - 多级指针是指指针指向指针的指针，以此类推。这在某些情况下可以用于传递或修改指针所指向的值，特别是在需要动态分配内存或修改函数参数的指针时
  - 多级指针在某些情况下用于动态分配内存，例如在函数内部分配新的结构体并返回指针，或者在处理复杂的数据结构时进行遍历和修改。在Go中，多级指针的使用通常相对较少，因为Go的垃圾回收器处理内存管理，而不需要手动释放内存

```go
package main

import "fmt"

func main() {
    // 声明一个整数和指向整数的指针
    var x int = 42
    var p *int = &x

    // 声明一个指向指针的指针
    var q **int = &p

    // 打印各级指针的值
    fmt.Printf("x = %d\n", x)      // 输出 x = 42
    fmt.Printf("p = %p\n", p)      // 输出 p = 0xc000018098 (指向 x 的地址)
    fmt.Printf("q = %p\n", q)      // 输出 q = 0xc0000180a0 (指向 p 的地址)
    fmt.Printf("*p = %d\n", *p)    // 输出 *p = 42 (p 指向 x)
    fmt.Printf("**q = %d\n", **q)  // 输出 **q = 42 (q 指向 p，p 指向 x)
}

```



### 5.8 值类型和引用类型

- 在编程中，值类型（Value Types）和引用类型（Reference Types）是两种不同的数据类型分类，它们决定了数据在内存中的存储方式、复制方式以及在赋值和传递过程中的行为

#### 5.8.1 值类型（Value Types)

- **数据存储方式**：值类型的数据在内存中存储它们的实际值，而不是引用或指针，数据存储在栈（Stack）上。每个值类型变量都包含其自己的数据副本
- **复制行为**：当值类型的变量被赋值给另一个变量或作为参数传递给函数时，会发生值的复制。这意味着新变量或函数参数会拥有原始值的独立副本，修改一个变量不会影响另一个。
- **基本数据类型**：整数、浮点数、布尔值、字符、数组、枚举等用户自定义的结构体（structs）都是值类型的例子。
- **传递方式**：值类型的赋值和传递通常比较高效，因为数据直接存储在变量中，不需要额外的引用和内存管理, 在函数之间传递值类型的数据时，通常会创建副本，因此修改副本不会影响原始数据
- 值类型可以借助指针修改原值

```go
// 值类型示例
a := 5
b := a // a 的值被复制给 b
b = 10
fmt.Println(a) // 输出 5，a 不受 b 的修改影响
```

#### 5.8.2 引用类型（Reference Types）

1. **数据存储方式**：引用类型的数据在内存中存储的是指向实际数据的引用或地址，而不是实际数据本身。多个引用类型变量可以引用同一个数据对象。数据存储在堆（Heap）上, 当没有任何变量引用这个地址是，该地址对应的数据空间就成为了一个垃圾，由GC回收
2. **复制行为**：当引用类型的变量被赋值给另一个变量或作为参数传递给函数时，仅复制了引用，而不是实际数据。这意味着新变量和原始变量都指向相同的数据，修改一个变量或参数可能会影响其他引用该数据对象的变量或参数
3. **复合数据类型**：切片（slices）、映射（maps）、通道（channels）、函数、接口和指针等都是引用类型的例子。
4. **传递方式**：引用类型的赋值和传递通常需要考虑引用的复制和内存管理开销，因为数据对象可能由多个引用共享,

```go
// 引用类型示例
slice1 := []int{1, 2, 3}
slice2 := slice1 // slice2 引用了 slice1 的底层数组
slice2[0] = 99
fmt.Println(slice1) // 输出 [99 2 3]，slice1 和 slice2 共享底层数组，修改 slice2 影响 slice1
```

### 5.9 深拷贝和浅拷贝

- 深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在编程中用于复制数据的两种不同方式，它们在复制数据时的行为和结果不同
- 浅拷贝（Shallow Copy）：
  - 浅拷贝是一种复制操作，它创建一个新的对象或数据结构，并将原始对象中的元素的引用复制到新对象中。这意味着新对象和原始对象中的某些部分共享相同的数据。
  - 当进行浅拷贝时，只有对象的引用被复制，而不是对象本身的内容。因此，如果修改了新对象中的某个元素，原始对象中的相应元素也会受到影响，因为它们引用同一数据。
  - 浅拷贝通常更快，因为它不需要复制大量的数据。但在某些情况下，它可能导致意外的副作用

```go
originalSlice := []int{1, 2, 3}
copiedSlice := originalSlice // 浅拷贝

// 修改拷贝后的切片会影响原始切片
copiedSlice[0] = 100
fmt.Println(originalSlice) // 输出 [100 2 3]
```

- 深拷贝（Deep Copy）：
  - 深拷贝是一种复制操作，它创建一个全新的对象或数据结构，并递归地复制原始对象中的所有元素及其内容，而不仅仅是引用。这确保了新对象是完全独立于原始对象的。
  - 深拷贝会复制原始对象的所有内容，包括对象的内部对象。因此，即使修改新对象中的元素，原始对象也不会受到任何影响。
  - 深拷贝通常更安全，因为它创建了一个独立的副本，不会引发意外的副作用

```go
import "github.com/mohae/deepcopy"

originalSlice := []int{1, 2, 3}
copiedSlice := deepcopy.Copy(originalSlice) // 深拷贝

// 修改拷贝后的切片不会影响原始切片
copiedSlice.([]int)[0] = 100
fmt.Println(originalSlice) // 输出 [1 2 3]

```

- 深拷贝可能会涉及到递归复制内部对象，因此可能会占用更多的内存和时间。
- 浅拷贝通常更快，但要小心因共享内部对象而引起的意外行为。
- 在实际编程中，需要根据需求选择浅拷贝或深拷贝。有些编程语言和库提供了内置的深拷贝功能，Go标准库不提供内置的深拷贝功能，因为深拷贝通常依赖于特定数据类型的结构和语义。通常需要手动编写深拷贝函数或使用第三方库，如 `github.com/mohae/deepcopy`。
- 深拷贝通常在需要完全独立的数据副本时使用，而浅拷贝可以在某些情况下提供更高的性能和内存效率

## 6. 基本运算符

- 运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等
- 运算符分类:
  - 算术运算符
  - 赋值运算符
  - 比较运算符\关系运算符
  - 逻辑运算符
  - 位运算符
  - 其它运算符

- 运算符优先级

![image-20230820222111586](E:/obsidian-data/images/image-20230820222111586.png)



### 6.1 算术运算符

- 算术运算符是对数值类型的变量进行运算的

#### 6.1.1 常见的算术运算符

| 运算符 |           示例            |
| :----: | :-----------------------: |
|   +    |        5 + 5 = 10         |
|   -    |         5 - 5 = 0         |
|   *    |         5 * 5 =25         |
|   /    |         5 * 5 = 1         |
|   %    |         5 % 5 = 0         |
|   ++   | a = 5, a++ = 6(先用在加1) |
|   --   | a = 5, a++ = 4(先用在加1) |

```go
package main

import "fmt"

func main() {
	var (
		a int = 5
		b int = 5
		c int
	)
	// 加法
	c = a + b
	fmt.Printf("a + b: %d\n", c)

	// 减法
	c = a - b
	fmt.Printf("a - b: %d\n", c)

	// 乘法
	c = a * b
	fmt.Printf("a * b: %d\n", c)

	// 除法
	c = a / b
	fmt.Printf("a / b: %d\n", c)

	// 取模
	c = a % b
	fmt.Printf("a %% b: %d\n", c)

	// 自增
	a++
	c = a + b
	fmt.Printf("a++ + b: %d\n", c)

	// 自减
	a = 5
	a--
	c = a + b
	fmt.Printf("a-- + b: %d\n", c)
}
```

#### 6.1.2 算术运算符注意事项

- 除法的整数之间做除法是: 只保留整数部分,舍弃小数部分, 除数或者被除数为负,结果就为负
- 取模运算计算公式:  a % b = a - a/b*b
- go的自增自减只能独立使用,不能进行赋值操作

```go
a := 5
a++
a--

// 错误写法 
a = a++
a = a--
```

- go语言是有a++和a--,没有++a和--a

### 6.2 关系运算符

- 关系运算符用于比较两个值之间的关系，并返回一个布尔值（true或false）
- 关系运算符常用于if结构和循环结构语句中

#### 6.2.1 常见的关系运算符

`==`：等于，用于比较两个值是否相等。

`!=`：不等于，用于比较两个值是否不相等。

`<`：小于，用于检查左边的值是否小于右边的值。

`>`：大于，用于检查左边的值是否大于右边的值。

`<=`：小于等于，用于检查左边的值是否小于等于右边的值。

`>=`：大于等于，用于检查左边的值是否大于等于右边的



- 示例

```go
package main

import "fmt"

func main() {
    var a, b int
    a = 5
    b = 10
    
    fmt.Println(a == b) // false
    fmt.Println(a != b) // true
    fmt.Println(a < b)  // true
    fmt.Println(a > b)  // false
    fmt.Println(a <= b) // true
    fmt.Println(a >= b) // false
}
```

#### 6.2.2 关系运算符注意事项

- 关系运算符的结果都是bool类型的,要么是true,要么是false
- 编写条件语句时，要确保使用`==`进行比较，而不是`=`赋值运算符。混淆这两者可能会导致逻辑错误
- 关系运算符要求进行比较的两个操作数具有相同的类型，或者它们的类型可以进行隐式类型转换。如果操作数类型不一致，编译器可能会报错
- Go语言中，使用关系运算符比较字符串时，实际上是比较字符串的字典序（按照Unicode码点排序），而不是字符串的内容
- 对于复合类型（如数组、切片、映射等），不能直接使用关系运算符进行比较，因为Go语言中的关系运算符并不支持复合类型的直接比较。需要编写自定义的比较函数来处理这些情况
- 浮点数的比较涉及到浮点数的精度问题，因此直接使用关系运算符比较浮点数可能会产生意想不到的结果。通常建议使用一个很小的误差范围来比较浮点数，而不是直接使用`==`或其他关系运算符
- 可以使用关系运算符比较指针的值，但要注意它比较的是指针的内存地址而不是指向的值

### 6.3 逻辑运算符

- 用于连接多个条件(一般来说就是关系表达式),最终回返回一个bool值

#### 6.3.1 常见的逻辑运算符

`&&`（逻辑与）：如果两个操作数都为`true`，则结果为`true`，否则为`false`。

`||`（逻辑或）：如果至少有一个操作数为`true`，则结果为`true`，否则为`false`。

`!`（逻辑非）：用于取反操作数的布尔值，如果操作数为`true`，则结果为`false`，如果操作数为`false`，则结果为`true`。

```go
package main

import "fmt"

func main() {
    a := true
    b := false
    
    resultAnd := a && b // false
    resultOr := a || b  // true
    resultNotA := !a    // false
    resultNotB := !b    // true
    
    fmt.Println(resultAnd)
    fmt.Println(resultOr)
    fmt.Println(resultNotA)
    fmt.Println(resultNotB)
}
```

#### 6.3.2 逻辑运算符注意事项

- **短路特性：** 逻辑运算符具有短路特性，即在某些情况下，只会计算第一个操作数就能确定整个表达式的结果。例如，逻辑与(`&&`)中，如果第一个操作数为`false`，那么整个表达式的结果就一定是`false`，因此不会计算第二个操作数。在逻辑或(`||`)中，如果第一个操作数为`true`，那么整个表达式的结果就一定是`true`，也不会计算第二个操作数。这个特性可以用来提高性能或避免不必要的计算
- **操作数类型：** 逻辑运算符只能用于布尔类型的操作数。不能直接用于其他类型的操作数，如果需要，你可能需要使用比较运算符或其他操作来将其他类型转换为布尔值
- **逻辑运算符的优先级：** 逻辑非(`!`)的优先级最高，其次是逻辑与(`&&`)，最后是逻辑或(`||`)。如果有多个逻辑运算符在一个表达式中，建议使用括号明确指定运算顺序，以免造成歧义
- 逻辑运算符通常用于条件判断、循环控制、错误处理等场景。在构建复杂逻辑条件时，要特别注意逻辑运算符的使用，确保逻辑关系清晰
- 在逻辑表达式中使用多重否定可能会使代码难以理解。尽量避免使用过多的逻辑非(`!`)运算符，以免降低代码的可读性

### 6.4 赋值运算符

- 赋值运算符就是将运算后的值赋值给指定变量

#### 6.4.1 常见的赋值运算符

`=`：基本的赋值运算符，用于将右侧表达式的值赋给左侧的变量。

`+=`：加赋值运算符，将右侧表达式的值加到左侧变量上，并将结果赋给左侧变量。

`-=`：减赋值运算符，将右侧表达式的值从左侧变量中减去，并将结果赋给左侧变量。

`*=`：乘赋值运算符，将左侧变量与右侧表达式的值相乘，并将结果赋给左侧变量。

`/=`：除赋值运算符，将左侧变量除以右侧表达式的值，并将结果赋给左侧变量。

`%=`：取模赋值运算符，将左侧变量除以右侧表达式的值的余数，并将结果赋给左侧变量。

`<<=`：左移赋值运算符，将左侧变量的位向左移动右侧表达式的位数，并将结果赋给左侧变量。

`>>=`：右移赋值运算符，将左侧变量的位向右移动右侧表达式的位数，并将结果赋给左侧变量。

`&=`：按位与赋值运算符，将左侧变量与右侧表达式的按位与结果赋给左侧变量。

`|=`：按位或赋值运算符，将左侧变量与右侧表达式的按位或结果赋给左侧变量。

`^=`：按位异或赋值运算符，将左侧变量与右侧表达式的按位异或结果赋给左侧变量



- 赋值运算符示例

```go
package main

import "fmt"

func main() {
    // 基本的赋值运算符
    a := 5
    b := a
    fmt.Println(b) // 输出 5
    
    // 加赋值运算符 +=
    x := 10
    x += 5 // 相当于 x = x + 5
    fmt.Println(x) // 输出 15
    
    // 减赋值运算符 -=
    y := 20
    y -= 7 // 相当于 y = y - 7
    fmt.Println(y) // 输出 13
    
    // 乘赋值运算符 *=
    width := 4
    height := 6
    area := 0
    area += width * height // 相当于 area = area + (width * height)
    fmt.Println(area) // 输出 24
    
    // 除赋值运算符 /=
    total := 100
    portion := 5
    remaining := 0
    remaining = total % portion // 相当于 remaining = total % portion
    fmt.Println(remaining) // 输出 0
    
// 下面运算符涉及到二进制和原码,补码等知识
    // 左移赋值运算符 <<=
    num := 1
    num <<= 3 // 相当于 num = num << 3
    fmt.Println(num) // 输出 8
    
    // 右移赋值运算符 >>=
    value := 16
    value >>= 2 // 相当于 value = value >> 2
    fmt.Println(value) // 输出 4
    
    // 按位与赋值运算符 &=
    flags := 0b101010
    mask := 0b110011
    flags &= mask // 相当于 flags = flags & mask
    fmt.Printf("%b\n", flags) // 输出 100010
    
    // 按位或赋值运算符 |=
    permissions := 0b001100
    grant := 0b010001
    permissions |= grant // 相当于 permissions = permissions | grant
    fmt.Printf("%b\n", permissions) // 输出 111101
    
    // 按位异或赋值运算符 ^=
    data := 0b1100
    flip := 0b1010
    data ^= flip // 相当于 data = data ^ flip
    fmt.Printf("%b\n", data) // 输出 0110
}
```

#### 6.4.2 赋值运算符注意事项

- 赋值运算顺序是从右往左

- 赋值运算符的左操作数必须是一个可寻址的变量。不能将赋值运算符用于常量、表达式的结果或不可寻址的值
- 值运算符要求左右操作数的数据类型兼容或可以隐式转换。如果左右操作数的类型不匹配，并且没有合适的类型转换，编译器会报错
- Go语言支持多重赋值，即可以同时为多个变量赋值。赋值运算符左侧的变量数量和类型必须与右侧的表达式返回值的数量和类型相匹配
- 尽管Go语言支持连续的赋值（例如：`a = b = 5`），但这在实际中并不常见，因为这可能会降低代码的可读性。最好分开写明赋值操作，以提高代码的清晰度
- 赋值运算符的优先级相对较低，因此在复杂表达式中可能需要使用括号来明确运算顺序
- 赋值运算符对指针进行赋值时，会复制指针的值，而不是指向的数据。这可能会导致多个指针引用相同的数据

### 6.5 位运算符

- Go语言也支持位运算符，这些运算符用于对整数的各个位进行操作

#### 6.5.1 常见的位运算符

- **按位与（&）**：对两个操作数的每个对应位执行AND操作，只有在两个位都是1时结果才是1，否则为0
- **按位或（|）**：对两个操作数的每个对应位执行OR操作，只有在两个位都是0时结果才是0，否则为1
- **按位异或（^）**：对两个操作数的每个对应位执行XOR操作，相同位的结果为0，不同位的结果为1
- **按位取反（^）**：对操作数的每个位执行NOT操作，将0变为1，1变为0
- **左移（<<）**：将操作数的二进制表示向左移动指定的位数，右侧空出的位用0填充
- **右移（>>）**：将操作数的二进制表示向右移动指定的位数，左侧空出的位根据情况用0或1填充

> 注意: 位运算使用的补码进行计算的

- 位运算符使用示例

```go
package main

import "fmt"

func main() {
    a := 5      // 二进制 101
    b := 3      // 二进制 011

    fmt.Printf("a & b = %d\n", a & b)   // 按位与
    fmt.Printf("a | b = %d\n", a | b)   // 按位或
    fmt.Printf("a ^ b = %d\n", a ^ b)   // 按位异或
    fmt.Printf("^a = %d\n", ^a)         // 按位补足
    fmt.Printf("a << 1 = %d\n", a << 1) // 左移一位
    fmt.Printf("a >> 1 = %d\n", a >> 1) // 右移一位
}
```

#### 6.5.2 位运算符注意事项

- 位运算符的行为取决于操作数的有符号还是无符号类型。对于有符号整数，右移运算符（`>>`）会保留符号位，而左移运算符（`<<`）不会影响符号位。对于无符号整数，位运算会在整数的所有位上进行操作
- 位运算可能导致溢出，特别是在执行左移操作时。溢出可能会导致意外的结果，因此在使用位运算符时应该小心
- 在右移运算（`>>`）和左移运算（`<<`）中，移位的数量应该在0到位数减一的范围内，否则行为是未定义的

### 6.6 补充知识

#### 6.6.1 进制

- 进制表示了数字在不同权重位置上的值,在计算机科学和数学中，常见的数字进制有四种：二进制、八进制、十进制和十六进制
- 在计算机内部各种运算都是通过二进制的方式来完成的
- 进制分类:
  - **二进制（Binary）：** 由0和1组成的基数系统。在计算机中，所有数据都是以二进制形式存储和处理的。
    - 示例：1010（二进制）表示十进制的10。
  - **八进制（Octal）：** 由0-7组成的基数系统。在计算机编程中，较少使用。
    - 示例：12（八进制）表示十进制的10。
  - **十进制（Decimal）：** 我们平常使用的十个数字组成的基数系统。
    - 示例：10（十进制）就是我们平常所说的10。
  - **十六进制（Hexadecimal）：** 由0-9和A-F（或a-f）组成的基数系统, 开头都是以0x开始。在计算机领域常用于表示字节序列
    - 示例：1A（十六进制）表示十进制的26

- 进制转换

![image-20230720230208897.png](https://cloud.006288.xyz/PicGo//image-20230720230208897.png)

#### 6.6.2 原码,反码,补码

- 原码、反码和补码是在计算机中表示有符号整数的三种不同方式。它们在处理负数时有不同的优势和应用
- **原码（Sign-Magnitude）：** 最简单的表示方法，直接使用二进制表示整数的绝对值，然后使用一个符号位来表示正负。即最高位为符号位，0 表示正数，1 表示负数, 原码的问题在于它不适合进行数学运算，尤其是加法和减法，因为对应的位级操作不直观

  - 正数的原码：如 +5 的原码为 `00000101`
  - 负数的原码：如 -5 的原码为 `10000101`
- **反码（Ones' Complement）：** 反码是通过将原码中的正数保持不变，负数的每一位取反（0 变为 1，1 变为 0）得到的。然后，通过对应的运算规则，可以进行加法和减法。但反码表示方式存在一个问题，就是存在“零”的两个表示：0000 和 1111。这会导致数学运算的混乱

  - 正数的反码：与原码相同，如 +5 的反码为 `00000101`
  - 负数的反码：将原码的符号位保持不变，其他位按位取反，如 -5 的反码为 `11111010`
- **补码（Two's Complement）：** 补码是解决了原码和反码的问题，广泛用于计算机内部表示有符号整数。对于正数，补码和原码一样；对于负数，补码是将反码加1得到的。补码的最大优势在于加法和减法在位级操作中是一样的，这使得计算机中的算术运算更为方便
  - 正数的补码：与原码相同，如 +5 的补码为 `00000101`
  - 负数的补码：将反码的最低位加1，如 -5 的补码为 `11111011`




- 示例

```go
// go语言中有三个位运算
按位与&：  11为1，10和00为0
按位或|：  11和10为1，00为0
按位异或^:  10为1，11和00为0


// 2&3（正数补码等于原码）
0000 0010 & 0000 0011 = 0000 0010

// -2 & 3（负数补码等于反码加1）
-2: 原码: 1000 0010  反码：1111 1101  补码： 1111 1110 
3：0000 0011
-2 & 3 = 0000 0010

// -2 | 3
-2: 原码: 1000 0010  反码：1111 1101  补码： 1111 1110 
3：0000 0011
-2 | 3 = 1111 1111

// -2 ^ 2
-2: 原码: 1000 0010  反码：1111 1101  补码： 1111 1110 
2:  原码：0000 0010

-2 ^ 2 = 1111 1100
补码：1111 1100  --> 反码：1111 1011  ---> 原码：1000 0100 = -4


// >>右移和
// <<左移运算

>>: 低位溢出，符号位不变，并用符号位补溢出的高位
<<: 符号位不变，低位补0

a: = 1>>2 = 0000 0001--> 0000 0000 = 0
b: = 1<<2 = 0000 0001 --> 0000 0100 = 4

// 位清空 &^

200 &^ 100 :

200的二进制数为： 0000 1100 1000 

100的二进制数为： 0000 0110 0100

对比两个二进制数，相同位一致当前位取 0，相同位不一致取 左边变量二进制数的当前位值

得到： 0000 1000 1000；转化为十进制为：136；
```



- 总结:
  - 原码简单，但不适合计算。
  - 反码适合加法和减法，但存在“零”的两种表示。
  - 补码适合计算，加法和减法可以在位级操作中统一处理

​	

- 补码的使用使得计算机在执行加法和减法运算时，可以将减法问题转化为加法问题，简化了运算电路的设计。而且补码的唯一性保证了零的表示是唯一的
- 补码的使用在计算机中更为普遍，因为它解决了负数的加法和减法问题，并且可以避免出现额外的数值范围，因此在计算机内部通常使用补码来表示有符号整数

## 7. 流程控制

- 在程序执行过程中主要有三大流程控制语句
  - **顺序结构：** 顺序结构是最简单的流程控制，代码会按照从上到下的顺序依次执行
  - **条件结构（分支结构）：** 使用 `if` 和 `switch` 语句来实现条件结构，根据条件的真假来决定不同的执行路径
  - **循环结构：** 使用 `for` 语句来实现循环结构，可以通过条件判断或者无限循环的方式来重复执行代码块

### 7.1 顺序控制语句

- 顺序控制语句是程序按照从上到下的顺序执行的基本结构，也是最简单的控制结构之一。顺序控制语句不需要特定的关键字，代码会按照书写顺序依次执行,中间没有任何判断和跳转

- 顺序控制语句是程序的基础，每行代码都会被依次执行，不需要特殊的语法来实现顺序执行

- 示例

```go
package main

import "fmt"

func main() {
    // 顺序执行语句
    fmt.Println("Step 1")
    fmt.Println("Step 2")
    fmt.Println("Step 3")
}

//在上述示例中，fmt.Println 函数调用被按照顺序执行，输出结果会依次是：
Step 1
Step 2
Step 3
```

### 7.2 分支控制语句

- 分支语句用于根据不同的条件执行不同的代码块

#### 7.2.1 if条件判断语句

- `if` 语句用于基于条件执行代码块

##### 7.2.1.1 if条件表达式基本语法

```go
// 单分支
if 条件表达式 {
    执行代码块
}


// 双分支
if 条件表达式 {
    执行代码块1
} else {
    执行代码块2
}

// 多分支
if 条件表达式1 {
    执行代码块1
} else if 条件表达式2 {
    执行代码块2
} else if 条件表达式3 {
    执行代码块3
    
 ....
}  else {
    执行代码块
}

// 嵌套分支 (在一个分支中又完整嵌套了一个分支)
if 条件表达式 {
    if 条件表达式 {
        执行代码块
    }
}
```

- 示例

```go
package main

import "fmt"

func main() {
	var (
		name   string
		result float64
	)
	fmt.Println("请输入你的姓名")
	fmt.Scanln(&name)
	fmt.Println("请输入你的成绩")
	fmt.Scanln(&result)

	if name == "" {
		fmt.Println("请你输出一个姓名!")
	} else {
		if result >= 90 {
			fmt.Println("优秀")
		} else if result >= 80 {
			fmt.Println("良好")
		} else if result >= 70 {
			fmt.Println("一般")
		} else if result < 70 {
			fmt.Println("不及格")
		} else {
			fmt.Println("输入有误!")
		}
	}

}
```

##### 7.2.1.2 if条件表达式注意事项

- **花括号 `{}`：** 尽量在 `if` 和 `else` 后使用花括号 `{}` 来明确代码块的范围，以避免出现歧义。即使在只有一行代码的情况下，使用花括号也可以提高代码的可读性和维护性
- **布尔表达式：** 在 `if` 语句中，条件表达式的结果应该是布尔值（`true` 或 `false`）。不要将整数、浮点数等其他类型的值直接用作条件表达式，这可能会导致不确定的行为
- **初始化变量：** 在 `if` 语句中可以初始化一个局部变量，但注意该变量的作用域仅限于 `if` 块内部
- **顺序判断：** 在使用多个 `if` 或 `else if` 条件时，注意条件的顺序，以确保条件被正确判断。因为只有第一个满足条件的分支会被执行
- **复杂条件：** 如果条件较为复杂，建议将逻辑分解成小的、可理解的部分，使用括号来明确优先级，以确保条件的正确性
- 嵌套分支层数应该尽量控制在三层以内

#### 7.2.2 switch分支控制语句

- `switch` 语句用于根据一个表达式的值在不同的条件中选择一个分支来执行,每一个case分支都是唯一的,从上到下逐一判断,知道匹配到为止, 匹配项后不需要再加break
- [type switch: switch语句还可以用type-switch来判断某个interface变量中实际指向的变量类型](https://www.yiibai.com/go/go_switch_statement.html),这里暂时不做细化,后面涉及到在展开

##### 7.2.2.1 switch分支控制语句基本语法

```go
// 基本语法
switch 表达式 {
    case 表达式1:
    	执行代码块
	case 表达式2,表达式3 :
    	执行代码块
    .....
    default:
    	执行代码块
}

// switch穿透 (switch-case 默认执行 case 语句后退出，若需要继续执行下一个 case 语句块，可以在 case语句块中使用 fullthrough 进行声明, 只能穿透一层)
switch 表达式 {
    case 表达式1:
    	执行代码块
    	fullthrough
	case 表达式2,表达式3 :
    	执行代码块
    	fullthrough
    .....
    default:
    	执行代码块
}

```

- 示例

```go
package main

import (
	"fmt"
)

func main() {
	var month int
	fmt.Print("Enter a month (1-12): ")
	fmt.Scanln(&month)

	switch month {
	case 1, 2, 12:
		fmt.Println("Winter")
	case 3, 4, 5:
		fmt.Println("Spring")
	case 6, 7, 8:
		fmt.Println("Summer")
	case 9, 10, 11:
		fmt.Println("Autumn")
	default:
		fmt.Println("Invalid month")
	}
}
```

##### 7.2.2.2 switch分支控制语句注意事项

- case/switch后是一个表达式（即：常量值、变量、一个有返回值的函数等都可以）

- case后的表达式的数据类型必须和switch的表达式数据类型一致

- fallthrough默认只能穿透一层

- case后面的表达式如果是常量不能重复

- **不需要 break：** Go 语言的 `switch` 语句默认不会穿透到下一个分支，所以不需要使用 `break` 来阻止穿透。每个 `case` 分支只会执行一次，然后程序会跳出 `switch` 语句

- **唯一匹配：** 在 `switch` 语句中，只有一个分支会被执行。如果多个分支匹配了相同的值，只会执行第一个匹配的分支

- **默认分支：** 可以使用 `default` 分支来处理没有匹配到的情况。`default` 分支是可选的，如果没有匹配的分支且没有 `default` 分支，`switch` 语句将不执行任何代码

- **多值匹配：** 可以在一个 `case` 分支中同时匹配多个值，使用逗号分隔。这在需要多个值都触发同一操作时很有用

- **复杂条件：** 如果分支的条件较为复杂，可以使用逻辑运算符组合多个条件表达式，或者使用变量来进行判断

- **表达式匹配：** switch后面也可以不带表达式，只提供 `case` 分支，可以实现基于条件的匹配，类似于 `if-else if-else` 结构

#### 7.2.3 if语句和switch比较

-  **if 语句：**
  - `if` 语句用于基于条件来执行代码块。可以处理更为复杂的条件逻辑，包括逻辑运算、比较等。
  - 可以使用 `if`、`else if` 和 `else` 来构建多个条件分支，适用于处理多个不同的条件情况。
  - 适用于需要进行复杂条件判断或者处理多个条件分支的情况。
  - 不同条件分支可以使用不同的条件表达式
-  **switch 语句：**
  - `switch` 语句用于基于一个表达式的值来选择一个分支进行执行。
  - 适用于处理有限的、特定值的匹配情况，使代码更加紧凑和可读。
  - 一个 `case` 分支匹配一个值，而不需要使用 `break` 来阻止穿透。
  - 可以使用 `switch` 表达式为空，类似于 `if-else if-else` 结构。
  - 可以在分支中使用类型断言，匹配不同的类型情况



- **选择使用场景：**

  - 如果需要根据复杂的条件逻辑进行判断，`if` 语句更加灵活，适用于处理多条件分支和较为复杂的条件判断。
  - 如果只需要根据一个表达式的值进行选择，并且需要将多个特定值与不同代码分支关联，`switch` 语句更适合，可以使代码更加简洁和易读。

  总之，根据不同的情况选择使用 `if` 语句或 `switch` 语句，可以使代码更加清晰、高效和易于维护

### 7.3 循环控制语句

- 让一段代码循环执行的过程

#### 7.3.1 for循环控制语句

##### 7.3.1.1 for循环基本语法

```go
// 传统for循环
for 循环变量初始化;循环条件;循环迭代变量 {
    循环代码块
}

// 类while循环
循环变量初始化
for 循环条件 {
    循环代码块
    循环迭代变量
}

// 死循环
// :写法一
for {
    循环代码块
}

// 写法二:
for ;; {
    循环代码块
}

// for-range循环,用于遍历可迭代对象中的每个元素，例如字符串，数组，切片，映射，通道等
collection
for index, value := range collection {
    // 使用索引和值
}

// 针对包含 Unicode 字符的字符串遍历是需要使用 for-range，range 返回两个元素分别为字节索引和 rune 字符，可通过空白标识符忽略需要接收的变量
```

- 示例

```go
package main

import "fmt"

func main() {
	// 传统for循环示例
	for i := 1; i <= 10; i++ {
		fmt.Println(i)
	}

	// 类while循环
	i := 1
	for i <= 10 {
		fmt.Println(i)
		i++
	}

	// 死循环
	for {
		fmt.Println("hello")
	}
    
	// for-range循环
	test_string := "hello"
	for index, value := range test_string {
		fmt.Printf("第 %d 个字符是: %c \n", index, value)
	}

}
```

##### 7.3.1.2 for循环控制条件注意事项

- 循环条件的返回值必须是一个bool类型
- 在传统的`for`循环中，循环变量的作用域仅限于循环体内。如果在循环体外部尝试访问循环变量，将会导致编译错误
- 使用无限循环时，确保在适当的地方使用`break`来跳出循环，避免无法终止的情况
- 在`range`循环中，当遍历字符串时，`vaule` 的类型应为 `rune`（Unicode 字符），而不是字符串。这是因为字符串在 Go 中是由 `byte` 组成的切片，而不是单个字符

#### 7.3.2 类while和类do...while循环

- Go语言没有专门的"while"循环和"do-while"循环语法，但通过`for`循环的不同形式，您可以实现类似的行为

```go
// While循环
循环变量初始化
for  {
    if 循环条件 {
        break 
    }
    循环代码块
    循环迭代变量
}

// Do-While循环：
for {
    循环代码块
    循环迭代变量
    if 循环条件 {
        break
    }
}

```

- 示例

```go
package main

import "fmt"

func main() {
    // while
    i := 1
    for i <= 5 {
        fmt.Println(i)
        i++
    }
   // do-while  
    i := 1
    for {
        fmt.Println(i)
        i++
        if i > 5 {
            break
        }
    }
}
```

#### 7.3.3 嵌套循环

- 将一个循环放在另一个循环体内，就形成了嵌套循环。在外边的for称为外层循环在里面的for循环称为内层循环。【建议一般使用两层，最多不要超过3层】
- 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为false时，才会完全跳出内层循环，才可结束外层的当次循环，开始下一次的循环
- 外层循环次数为m次，内层为n次，则内层循环体实际上需要执行m*m次



- 示例

```go
// 打印一个4*4的正方形
package main

import "fmt"

func main() {
	i := 1
	for i <= 4 {
		j := 1
		for j <= 4 {
			fmt.Print("*")
			j++
		}
		i++
		fmt.Println()
	}
}

// 打印一个等边直角三角形
package main

import "fmt"

func main() {
	i := 0
	for i <= 4 {
		j := 0
		for j < i+1 {
			fmt.Print("*")
			j++
		}
		i++
		fmt.Println()
	}
}

// 打印九九乘法表
package main

import "fmt"

func main() {
	for i := 1; i <= 9; i++ {
		for j := 1; j <= i; j++ {
			fmt.Printf("%d * %d = %d \t", j, i, i*j)
		}
		fmt.Println()
	}
}
```

#### 7.3.4 break和continue

- `break` 和 `continue` 是在循环中控制流程的关键字，它们在编程中用于更精细地控制循环的执行
  - `break` 关键字用于立即终止循环的执行，并跳出循环。通常用于在满足某个条件时提前终止循环，或者在无限循环中创建跳出条件
  - `continue` 关键字用于跳过当前迭代，直接进入下一次迭代的执行。它通常用于在循环中跳过某些特定情况，然后继续执行后续迭代
- `break` 和 `continue` 的使用有助于在循环中进行更精细的控制，从而实现更复杂的逻辑。但需要注意，过度使用它们可能会导致代码难以理解和维护，因此应该谨慎使用



- 示例

```go
// break示例
package main

import "fmt"

func main() {
	for i := 1; i <= 10; i++ {
		if i > 5 {
			break // 当 i 大于 5 时终止循环
		}
		fmt.Println(i)
	}

}

// continue  
// 打印偶数
package main

import "fmt"

func main() {
	for i := 1; i <= 100; i++ {
		if i%2 == 0 {
			fmt.Println(i)
		}
	}

}

```

#### 7.3.5 label 与 goto 

- 在Go语言中，`label` 和 `goto` 是两个关键字，用于实现在程序中跳转到指定标签位置的控制流

##### 7.3.5.1 Label（标签)

- `label` 是一个标识符，用于标记代码中的一个位置。标签通常用于与 `goto` 语句结合使用，以便在代码中指定跳转的目标位置

```go
package main

import "fmt"

func main() {
outerLoop:
	for i := 1; i <= 3; i++ {
		for j := 1; j <= 3; j++ {
			fmt.Printf("i: %d, j: %d\n", i, j)
			if i == 2 && j == 2 {
				break outerLoop // 跳出外层循环
			}
		}
	}
}

// outerLoop 是一个标签，它标记了外层的 for 循环。当 i 和 j 都为 2 时，使用 break outerLoop 语句跳出了外层循环
```

##### 7.3.5.2 Goto(跳转)

- `goto` 语句允许在代码中跳转到指定的标签位置。尽管它在某些情况下可能是有用的，但使用 `goto` 往往会使代码难以理解和维护，因此应该谨慎使用。大多数情况下，通过更结构化的控制流程，如循环和条件语句，可以更好地组织代码逻辑
- goto语句通常与条件语句配合使用。可用来实现条件转移，跳出循环体等功能

```go
package main

import "fmt"

func main() {
	for i := 1; i <= 10; i++ {
		fmt.Println("hello")
		if i == 8 {
			goto END
		}
	}
END:
	fmt.Println("see you")
}

```

## 8. 复合数据类型

### 8.1 数组(array)

- 数组（Array）是一种数据结构, 是具有相同数据类型的数据项组成的一组长度固定的序列，数据项叫做数组的元素，数组的长度必须是非负整数的常量，长度也是类型的一部分
- 数组是固定大小的，一旦定义，其大小不能更改
- 数组是值类型。

#### 8.1.1 数组基本语法

- 数组声明
  - 数组声明需要指定组成元素的类型以及存储元素的数量（长度）。在数组声明后，其长度不 可修改，数组的每个元素会根据对应类型的零值对进行初始化

```go
var arrayName [size]dataType

// arrayName 是数组的名称。
// size 是数组的大小，即它可以容纳的元素数量。
// dataType 是数组中元素的数据类型
```

- 数组初始化

```go
// 指定数组长度: [length]type{v1, v2, …, vlength}  (使用字面值初始化数组)
var username [3] string = [3]string {"Tom","Bob","Kevin"}

或者
var username = [3]string {"Tom","Bob","Kevin"}

// 使用初始化元素数量推到数组长度: […]type{v1, v2, …, vlength}
var username = [...]int{1, 2, 3, 4, 5}

// 使用索引对指定位置元素进行初始化: [length]type{im:vm, …, sin:in}
var arr [5]int
arr[0] = 1
arr[1] = 2
```

- 数组使用

```go
package main

import "fmt"

func main() {
	var result = [3]float64{88.5, 90.5, 75.6}

	// 使用数组
	fmt.Println(result)

	// 访问数组指定元素
	fmt.Printf("数组下标为2的元素值为: %.2f ", result[2])
}


// 可以通过索引访问数组中的元素。数组的索引从 0 开始，最后一个元素的索引是 size-1
```

#### 8.1.2 数组在内存中的布局

-  在 Go 中，数组是值类型，传递给函数时会复制整个数组。
- 数组在内存中是一段连续的存储空间

```go
package main

import "fmt"

func main() {
	var result [3]float64

	fmt.Printf("该数组的地址为: %p \n该数组下标0的值为: %.2f, 地址为: %p \n 该数组下标1的值为: %.2f, 地址为: %p \n 该数组下标2的值为: %.2f, 地址为: %p ",
		&result, result[0], &result[0], result[1], &result[1], result[2], &result[2])
	
	// 小结:
	// 如果没有初始化数组时,系统会使用0来默认储实化数组
	// 数组的首个元素地址就是数组的地址
	// 各个数组元素之间的地址时在首个元素地址的基础上,按照数组定义的类型占用的内存字符数进行逐个相加
	
}
```

![image-20230907002804554](E:/obsidian-data/images/image-20230907002804554.png)

- 小结:

  - 数组的地址可以通过数组名来获取   比如: &result

  - 数组的第一个元素的地址，就是数组的首地址

  - 数组的各个元素的地址间隔是依据数组的类型决定，比如 int64 -> 8 int32->4...

#### 8.1.3 数组的基本操作

##### 8.1.3.1 获取数组长度

- 使用 `len()` 函数可以获取数组的长度

```go
package main

import "fmt"

func main() {
	var result = [3]float64{88.5, 90.5, 75.6}

	result_size := len(result)

	fmt.Printf("数组长度为: %v", result_size)
}


// 自动推到数据长度
package main

import "fmt"

func main() {
	array := [...]int{1, 2, 3, 4, 5, 6}
	fmt.Println(len(array))
}
```

##### 8.1.3.2 修改数组元素

```go
package main

import "fmt"

func main() {
	var result = [3]float64{88.5, 90.5, 75.6}

	result[1] = 88.8

	fmt.Printf("数组下标为1的元素值为: %.2f ", result[1])
}
```

##### 8.1.3.3 数组遍历

- 可以通过 for+len+访问方式或 for-range 方式对数组中元素进行遍历

- 使用for + len方法遍历

```go
package main

import "fmt"

func main() {
	var result = [3]float64{88.5, 90.5, 75.6}

	for i := 0; i < len(result); i++ {
		fmt.Printf("数组下标为 %v 的元素值为: %.2f \n", i, result[i])
	}

}
```

- 使用for-range方式遍历

```go
// for-rangge基本语法
for index, value := range name {
    ...
}


// 示例
package main

import "fmt"

func main() {
	var result = [3]float64{88.5, 90.5, 75.6}

	for index, value := range result {
		fmt.Printf("数组下标为 %v 的元素值为: %.2f \n", index, value)
	}

	// 如果不需要访问某个值可以使用_来屏蔽
	for _, value := range result {
		fmt.Printf("数组元素值为: %.2f \n", value)
	}
}
```

#### 8.1.4 多维数组

- Go 支持多维数组，例如二维数组、三维数组等
- 多维数组是一种表格或矩阵的数据结构，可以用于表示二维或更高维度的数据

##### 8.1.4.1 多维数组基本语法

- 声明多维数组

```go
var 数组名 [大小][大小]类型 = [大小][大小]类型{{初值..},{初值..}}
var 数组名 [大小][大小]类型 = [...][大小]类型{{初值..},{初值..}}
var 数组名 = [大小][大小]类型{{初值..},{初值..}}
var 数组名 = [...][大小]类型{{初值..},{初值..}}
// 多维数组只有第一维度的长度可以使用推导长度



// 二维数组
// 二维数组是最常见的多维数组形式
var matrix [3][3]int // 一个3x3的整数二维数组

matrix = [3][3]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},
}


// 三维数组
// 三维数组是更高维度的扩展
var cube [2][2][2]int // 一个2x2x2的整数三维数组

cube = [2][2][2]int{
    {
        {1, 2},
        {3, 4},
    },
    {
        {5, 6},
        {7, 8},
    },
}

```

- 访问多维数组

```go
package main

import "fmt"

func main() {
	// 声明一个二维数组
	var numbers = [3][3]int{{1, 2, 3}, {4, 5, 6}, {7, 8}}

	// 使用二维数组
	fmt.Println(numbers)

	// 打印如下图形
	//0 0 0 0 0
	//0 1 0 0 0
	//2 0 3 0 0
	//5 2 4 0 6

	var tables [4][5]int

	tables[1][1] = 1
	tables[2][0] = 2
	tables[2][2] = 3
	tables[3][0] = 5
	tables[3][1] = 2
	tables[3][2] = 4
	tables[3][4] = 6

	for i := 0; i < 4; i++ {
		for j := 0; j < 5; j++ {
			fmt.Print(tables[i][j])
		}
		fmt.Println()
	}

}
```

##### 8.1.4.2 多维数组的遍历

- 遍历多维数组可以使用嵌套循环和for-range完成

```go
// 使用嵌套循环遍历多维数组

package main

import "fmt"

func main() {
	matrix := [3][3]int{
		{1, 2, 3},
		{4, 5, 6},
		{7, 8, 9},
	}

	for i := 0; i < len(matrix); i++ {
		for j := 0; j < len(matrix[j]); j++ {
			fmt.Printf("下标为:(%v,%v)的值为: %d \n", i, j, matrix[i][j])
		}
	}
}


// 使用for-range遍历多维数组

package main

import "fmt"

func main() {
	matrix := [3][3]int{
		{1, 2, 3},
		{4, 5, 6},
		{7, 8, 9},
	}

	for index1, value1 := range matrix {                      // 循环遍历二维数组的每一行
		for index2, value2 := range value1 {                 // 循环遍历每一行中的元素
			fmt.Printf("下标为:(%v,%v)的值为: %d \n", index1, index2, value2)
		}
	}
}
```

### 8.2 切片(slice)

- 切片（Slice）是一种灵活的动态数组，它比传统的数组更强大和便捷。切片允许你动态增加或减少元素数量，而不需要事先声明数组的大小
- 切片是长度可变的数组（具有相同数据类型的数据项组成的一组长度可变的序列）
- 切片是数组的一个引用，底层实现是一个指向数组的指针, 因此切片是引用类型，在进行传递时，遵守引用传递的机制
- 切片的使用和数组类似，遍历切片、访问切片的元素和求切片长度len(slice)都一样

#### 8.2.1 切片的基本语法

- 切片由 三部分组成： 
  - 指针：指向切片第一个元素指向的数组元素的地址 
  - 长度：切片元素的数量 
  - 容量：切片开始到结束位置元素的数量



- 切片声明
  - 切片声明需要指定组成元素的类型，但不需要指定存储元素的数量（长度）。在切片声明后， 会被初始化为 nil，表示暂不存在的切片

```go
// 声明一个切片
// 方法1
var sliceName []elementType

// 方法2
sliceName := []elementType{}

// 方法3
make([]type, len)
make([]type, len, cap)

// len 已经初始化的空间
// cap 已经初始化和空闲的空间
// len不能大于cap
 

// 切片使用数组初始化
var slice = arr[0:end] 可以简写 var slice = arr[:end]
var slice = arr[start:len(arr)] 可以简写： var slice = arr[start:]
var slice = arr[0:len(arr)] 可以简写: var 


//其中，sliceName 是切片的名称，elementType 是切片中元素的数据类型。
```

- 初始化切片
  - 使用字面量初始化:[]type{v1, v2, …, vn}使用字面
  - 量初始化空切片: []type{}
  - 指定长度和容量字面量初始化:[]type{im:vm, in:vn, ilength:vlength}
  - 使用 make 函数初始化, make([]type, len)/make([]type, len, cap)，通过 make 函数创建长度为 len，容量为 cap 的切片，len 必须小于等于 cap使用数组
  - 使用数组切片操作初始化：`array[start:end]/array[start:end:cap] (end<=cap<=len)`

```go
package main

import "fmt"

func main() {
	// 使用字面量初始化:[]type{v1, v2, …, vn}使用字面
	var sliceName1 []int = []int{1, 2, 3, 4, 5}
	fmt.Println(sliceName1)

	// 使用apped函数对切片进行初始化
	var sliceName1_1 []int
	sliceName1_1 = append(sliceName1_1, 6, 7, 8, 9, 10)
	fmt.Println(sliceName1_1)

	//量初始化空切片: []type{}指定长度
	// 可以在{}直接添加值
	// 可以使用append函数追加值
	sliceName2 := []int{}
	fmt.Println(sliceName2)

	// 直接在{}中添加值
	sliceName2_1 := []int{1, 2, 3, 4, 5}
	fmt.Println(sliceName2_1)

	// 使用appen函数追加值
	sliceName2_2 := append(sliceName2, 6, 7, 8, 9)
	fmt.Println(sliceName2_2)

	//指定长度和容量字面量初始化:[]type{im:vm, in:vn, ilength:vlength}
	// 0: 5 表示在切片的索引 0 处设置元素值为 5。这意味着切片的第一个元素是 5。
	//8: 12 表示在切片的索引 8 处设置元素值为 12。这意味着切片的第九个元素是 12
	sliceName3 := []int{0: 5, 8: 12}
	fmt.Println(sliceName3)

	//使用 make 函数初始化, make([]type, len)  /   make([]type, len, cap)
	//通过 make 函数创建长度为 len，容量为 cap 的切片，len 必须小于等于 cap使用数组
	sliceName4 := make([]int, 3, 5)
	sliceName5 := make([]int, 5)

	// 初始化
	sliceName4[0] = 1
	sliceName4[1] = 2
	sliceName4[2] = 3

	for i := 0; i < len(sliceName5); i++ {
		sliceName5[i] = i + 1
	}

	fmt.Println(sliceName4)
	fmt.Println(sliceName5)

	//使用数组切片操作初始化：`array[start:end] /  array[start:end:cap] (end<=cap<=len)`
	arrayName := [8]int{1, 2, 3, 4, 5, 6, 7, 8}

	sliceName6 := arrayName[2:6]
	sliceName7 := arrayName[0:5:6]

	fmt.Println(sliceName6)
	fmt.Println(sliceName7)
	fmt.Println(len(sliceName7))
	fmt.Println(cap(sliceName7))

}

```

#### 8.2.2 切片在内存中的布局

- 切片在内存中是引用类型的
- 切片从底层来说，其实就是一个数据结构(struct 结构体)

```go

type slice struct {
    ptr *[2]int
	len int
	cap int
}
```



- 示例

```go
package main

import (
	"fmt"
)

func main() {
	arrayName1 := [5]int{1, 2, 3, 4}

	sliceNmae1 := arrayName1[1:3]

	fmt.Printf("arrayName的数据类型是 %T, 它的值是: %v, 它的长度是: %d ,它的地址是: %p ,它的首元素地址是: %p , 它的下标为1的元素地址是: %p\nn",
		arrayName1, arrayName1, len(arrayName1), &arrayName1, &arrayName1[0], &arrayName1[1])
	fmt.Printf("sliceNmae1的数据类型是 %T, 它的值是: %v, 它的长度是: %d ,它的地址是: %p ,它的首元素地址是: %p , 它的cap是: %v, \n",
		sliceNmae1, sliceNmae1, len(sliceNmae1), &sliceNmae1, &sliceNmae1[0], cap(sliceNmae1))

    // 切片在内存中是引用类型的,修改切片的数据也会影响原数组的数据
	sliceNmae1[1] = 8

	fmt.Println(arrayName1)
	fmt.Println(sliceNmae1)

}
```

#### 8.2.3 切片的基本操作

##### 8.2.3.1 获取切片长度

- 使用 len 函数可获取切片的长度，使用 cap 函数可获取切片容量

```go
package main

import "fmt"

func main() {
	sliceName1 := make([]int, 3, 10)

	fmt.Printf("切片长度为: %d, 切片容量为: %d \n", len(sliceName1), cap(sliceName1))
}
```

##### 8.2.3.2 访问和修改切片

```go
package main

import "fmt"

func main() {
	sliceName1 := make([]int, 3, 10)
	// 初始化切片
	for i := 0; i < len(sliceName1); i++ {
		sliceName1[i] = i + 2
	}

	sliceName1[2] = 88

	fmt.Printf("切片数据为: %v", sliceName1)
}
```

##### 8.2.3.3 遍历切片

- 可以通过 for+len+访问方式或 for-range 方式对切片中元素进行遍历

```go
package main

import "fmt"

func main() {
	sliceName1 := []int{1, 2, 3, 4, 5, 6}

	// 使用for循环遍历
	for i := 0; i < len(sliceName1); i++ {
		fmt.Println(sliceName1[i])
	}

	// 使用for-range遍历数组
	for _, value := range sliceName1 {
		fmt.Println(value)
	}
}
```

##### 8.2.3.4 切片动态追加

- 使用 append 对切片增加一个或多个元素并返回修改后切片，当长度在容量范围内时只 增加长度，容量和底层数组不变。当长度超过容量范围则会创建一个新的底层数组并对 容量进行智能运算(元素数量<1024 时，约按原容量 1 倍增加，>1024 时约按原容量 0.25 倍增加)

```go
package main

import "fmt"

func main() {
   sliceName1 := make([]int, 3, 10)
   // 初始化切片
   for i := 0; i < len(sliceName1); i++ {
      sliceName1[i] = i + 2
   }

   sliceName1 = append(sliceName1, 7, 8, 9)

   fmt.Printf("切片数据为: %v", sliceName1)
}
```

##### 8.2.3.5 切片的截取

![image-20230909174452358](E:/obsidian-data/images/image-20230909174452358.png)

```go
package main

import "fmt"

func main() {
	sliceName1 := []int{1, 2, 3, 4, 5}

	sliceName2 := sliceName1[2]
	fmt.Println(sliceName2)

	sliceName3 := sliceName1[:]
	fmt.Println(sliceName3)

	sliceName4 := sliceName1[1:3]
	fmt.Println(sliceName4)

	//截取后的切片len等于: end - start
	//截取后的cap等于: max - start
	sliceName5 := sliceName1[0:4:5]
	// len: 4-0 = 4
	// cap: 5-0 : 5
	fmt.Println(sliceName5)
	fmt.Printf("sliceName5len等于 %v, cap等于: %v \n ", len(sliceName5), cap(sliceName5))

}
```

##### 8.2.3.6 拷贝切片中的元素

- 切片使用 copy 内置函数完成拷贝,copy(para1, para2) 参数的数据类型是切片

```go
// copy(目标切片,源切片)


package main

import "fmt"

func main() {
	sliceName1 := []int{1, 2, 3, 4, 5}
	var sliceName2 = make([]int, 6)

	copy(sliceName2, sliceName1)
	fmt.Println(sliceName2)
}
```

##### 8.2.3.7 删除切片中的元素

- Go 语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素

```go
package main

import "fmt"

func main() {
	// 删除切片中的元素
	sliceName1 := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}
	// 删除第一个元素
	sliceName1 = sliceName1[1:]
	fmt.Println(sliceName1)

	// 删除最后一个元素
	sliceName1 = sliceName1[:len(sliceName1)-1]
	fmt.Println(sliceName1)

	// 删除指定位置的元素
	index := 3
	sliceName1 = append(sliceName1[:index], sliceName1[index+1:]...)
	fmt.Println(sliceName1)

	// 删除指定元素块
	startindex := 2
	endindex := 5
	sliceName1 = append(sliceName1[:startindex], sliceName1[endindex+1:]...)
	fmt.Println(sliceName1)

	// 清空切片
	sliceName1 = nil
	fmt.Println(sliceName1)

}
```

> 为什么切片后面有三个点，因为我们要将切片打散，什么意思呢？我们直接在一个切片后面增加另一个切片是不行的，我们需要把切片进行打散成一个一个的元素，然后传递到前一个切片中，为什么不能直接将2个切片合并？我的猜想是append考虑了切片底层数组的大小，如果我们往切片后面加上一个参数此时正好切片的大小大于底层数组的大小，那么底层数组将会被换一个原来容量2倍的数组，注意这个将底层数组换成2倍的操作是一个固定操作，不是换成3倍，4倍，如果我们往后直接累加一个切片，加入后加入的切片大小是底层数组的3倍，岂不是我们将原先的底层数组更换成原先的2倍还是装不下吗，所以我们需要一个一个的append

#### 8.2.4切片综合案例

- 计算一组整数的和

```go
package main

import (
	"fmt"
)

func main() {
	// 创建一个整数切片来存储用户输入的整数
	var numbers []int

	fmt.Print("请输入你要求和的整数: ")

	for {
		var num int
		_, err := fmt.Scanf("%d", &num)

		if err != nil {
			break
		}

		numbers = append(numbers, num)

	}

	sum := 0
	for i := 0; i < len(numbers); i++ {
		sum += numbers[i]
	}
	fmt.Printf("切片%v的和是: %d\n", numbers, sum)
}

```

- 输出一组整型数据中最大的值

```go
package main

import (
	"fmt"
)

func get_maxvalue(name []int) int {
	maxvalue := name[0]

	for _, value := range name {
		if value > maxvalue {
			maxvalue = value
		}
	}

	return maxvalue

}

func main() {
	// 创建一个整数切片来存储用户输入的整数
	var (
		numbers []int
		num     int
	)

	fmt.Print("请输入你要处理的数据: ")

	for {
		_, err := fmt.Scanf("%d", &num)
		if err != nil {
			break
		}

		numbers = append(numbers, num)
	}

	max_value := get_maxvalue(numbers)

	fmt.Printf("你输入的切片%v,它的最大值是: %d \n", numbers, max_value)
}

```

### 8.3 映射(map)

- 映射map是存储一系列无序的key-value 数据结构，又称为字段或者关联数组, 通过 key 来对 value 进行操作（增、删、改、查）。 映射的 key 只能为可使用==运算符的值类型（字符串、数字、布尔、数组），value 可以为 任意类型



- key 可以是什么类型
  -  golang 中的 map，的 key 可以是很多种类型，比如 bool, 数字，string, 指针, channel , 还可以是只包含前面几个类型的 接口, 结构体, 数组, 通常 key 为 int 、string, 注意: slice， map 还有 function 不可以，因为这几个没法用 == 来判断
- valuetype 可以是什么类型 
  - valuetype 的类型和 key 基本一样, 通常为: 数字(整数,浮点数),string,map,struct



- map注意事项:
  - map 是引用类型，遵守引用类型传递的机制，在一个函数接收 map，修改后，会直接修改原来的 map
  - map 的容量达到后，再想 map 增加元素，会自动扩容，并不会发生panic，也就是说map能动态的增长 键值对(key-value)
  - map 的 value 也经常使用 struct 类型，更适合管理复杂的数据(比前面value 是一个map更好)，



#### 8.3.1 映射基本语法

- 声明map
  - map 在使用前一定要 make 
  - map 的 key 是不能重复，如果重复了，则以最后这个 key-value 为准
  - map 的 value 是可以相同的
  - map 的 key-value 是无序 
  - make 内置函数数目


```go
// 三种声明形式
var mapName map[键的类型]值的类型
mapName := map[键的类型]值的类型{}
make(map[键的类型]值的类型)

// 示例
package main

func main() {
	// 声明map
	var mapName1 map[string]int

	mapName2 := map[int]int{}

	mapName3 := make(map[string]string)
	
}
```

> 注意：声明是不会分配内存的，初始化需要 make ，分配内存后才能赋值和使用

- 初始化map
  - 使用字面量初始化:map[ktype]vtype{k1:v1, k2:v2, …, kn:vn}
  - 使用字面量初始化空映射:map[ktype]vtype{ }
  - 使用 make 函数初始化 make(map[ktype]vtype)，通过 make 函数创建映射


```go
package main

import "fmt"

func main() {
	// 声明map
	var mapName1 map[string]int
	// 初始化
	mapName1 = make(map[string]int, 10)
	mapName1["Tom"] = 23
	mapName1["Kevin"] = 20
	mapName1["Bob"] = 18

	fmt.Println(mapName1)

	//mapName2 := map[string]float64{}
	mapName2 := map[string]float64{
		"Tom":   99.9,
		"Bob":   88.8,
		"Kevin": 66.6,
	}

	fmt.Println(mapName2)

	mapName3 := make(map[string]string)
	mapName3["Tom"] = "sahnghai"
	mapName3["Kevin"] = "shenzhen"
	mapName3["Bob"] = "yunnan"

	fmt.Println(mapName3)

}

```

#### 8.3.2 映射基本操作

##### 8.3.2.1 获取map长度

- 使用 len 函数获取映射元素的数量

```go
package main

import "fmt"

func main() {
	// 声明map
	var mapName1 map[string]int
	// 初始化
	mapName1 = make(map[string]int, 10)
	mapName1["Tom"] = 23
	mapName1["Kevin"] = 20
	mapName1["Bob"] = 18

	fmt.Println(mapName1)

	//mapName2 := map[string]float64{}
	mapName2 := map[string]float64{
		"Tom":   99.9,
		"Bob":   88.8,
		"Kevin": 66.6,
	}

	fmt.Println(mapName2)

	mapName3 := make(map[string]string)
	mapName3["Tom"] = "sahnghai"
	mapName3["Kevin"] = "shenzhen"
	mapName3["Bob"] = "yunnan"

	fmt.Println(mapName3)

	// map基本操作

	// 获取map长度
	fmt.Printf("mapName1的长度为: %d \n", len(mapName1))

	
}
```

##### 8.3.2.2 访问指定key的元素

- 当访问 key 存在与映射时则返回对应的值，否则返回值类型的零值

```go
package main

import "fmt"

func main() {
	// 声明map
	var mapName1 map[string]int
	// 初始化
	mapName1 = make(map[string]int, 10)
	mapName1["Tom"] = 23
	mapName1["Kevin"] = 20
	mapName1["Bob"] = 18

	fmt.Println(mapName1)

	//mapName2 := map[string]float64{}
	mapName2 := map[string]float64{
		"Tom":   99.9,
		"Bob":   88.8,
		"Kevin": 66.6,
	}

	fmt.Println(mapName2)

	mapName3 := make(map[string]string)
	mapName3["Tom"] = "sahnghai"
	mapName3["Kevin"] = "shenzhen"
	mapName3["Bob"] = "yunnan"

	fmt.Println(mapName3)

	// map基本操作

	// 访问指定的key
	fmt.Printf("Kevin同学的成绩是: %.2f\n", mapName2["Kevin"])
}

```

##### 8.3.2.3 修改和增加

- 使用 key 对映射赋值时当 key 存在则修改 key 对应的 value，若 key 不存在则增加 key 和 value

```go
package main

import "fmt"

func main() {
	// 声明map
	var mapName1 map[string]int
	// 初始化
	mapName1 = make(map[string]int, 10)
	mapName1["Tom"] = 23
	mapName1["Kevin"] = 20
	mapName1["Bob"] = 18

	fmt.Println(mapName1)

	//mapName2 := map[string]float64{}
	mapName2 := map[string]float64{
		"Tom":   99.9,
		"Bob":   88.8,
		"Kevin": 66.6,
	}

	fmt.Println(mapName2)

	mapName3 := make(map[string]string)
	mapName3["Tom"] = "sahnghai"
	mapName3["Kevin"] = "shenzhen"
	mapName3["Bob"] = "yunnan"

	fmt.Println(mapName3)

	// map基本操作

	// 修改&增加
	mapName1["Bob"] = 25
	mapName1["jinjian"] = 23
	fmt.Println(mapName1)
}

```

##### 8.3.2.4 判断key是否存在

- 通过 key 访问元素时可接收两个值，第一个值为 value，第二个值为 bool 类型表示元 素是否存在，若存在为 true，否则为 false

```go
package main

import "fmt"

func main() {
	// 声明map
	var mapName1 map[string]int
	// 初始化
	mapName1 = make(map[string]int, 10)
	mapName1["Tom"] = 23
	mapName1["Kevin"] = 20
	mapName1["Bob"] = 18

	fmt.Println(mapName1)

	//mapName2 := map[string]float64{}
	mapName2 := map[string]float64{
		"Tom":   99.9,
		"Bob":   88.8,
		"Kevin": 66.6,
	}

	fmt.Println(mapName2)

	mapName3 := make(map[string]string)
	mapName3["Tom"] = "sahnghai"
	mapName3["Kevin"] = "shenzhen"
	mapName3["Bob"] = "yunnan"

	fmt.Println(mapName3)

	// map基本操作

	// 判断key是否存在
	map_value, ok := mapName3["Bob"]
	if ok {
		fmt.Printf("Bob这个map_key存在,他对应的valu为: %s\n", map_value)
	}

}
```

##### 8.3.2.5 遍历map

- 可通过 for-range 对映射中个元素进行遍历，range 返回两个元素分别为映射的 key 和 value

```go
package main

import "fmt"

func main() {
	// 声明map
	var mapName1 map[string]int
	// 初始化
	mapName1 = make(map[string]int, 10)
	mapName1["Tom"] = 23
	mapName1["Kevin"] = 20
	mapName1["Bob"] = 18

	fmt.Println(mapName1)

	//mapName2 := map[string]float64{}
	mapName2 := map[string]float64{
		"Tom":   99.9,
		"Bob":   88.8,
		"Kevin": 66.6,
	}

	fmt.Println(mapName2)

	mapName3 := make(map[string]string)
	mapName3["Tom"] = "sahnghai"
	mapName3["Kevin"] = "shenzhen"
	mapName3["Bob"] = "yunnan"

	fmt.Println(mapName3)

	// map基本操作

	// 遍历map
	for map_key, map_value := range mapName3 {
		fmt.Printf("%s同学来自: %s\n", map_key, map_value)
	}
}

```

##### 8.3.2.6 删除指定key-value

- delete(map，"key") ，delete 是一个内置函数，如果 key 存在，就删除该key-value,如果key 不存在，不操作，但是也不会报错
- 如果我们要删除 map 的所有 key ,没有一个专门的方法一次删除，可以遍历一下key, 逐个删除或者 map = make(...)，make 一个新的，让原来的成为垃圾，被 gc 回收

```go
package main

import "fmt"

func main() {
	// 声明map
	var mapName1 map[string]int
	// 初始化
	mapName1 = make(map[string]int, 10)
	mapName1["Tom"] = 23
	mapName1["Kevin"] = 20
	mapName1["Bob"] = 18

	fmt.Println(mapName1)

	//mapName2 := map[string]float64{}
	mapName2 := map[string]float64{
		"Tom":   99.9,
		"Bob":   88.8,
		"Kevin": 66.6,
	}

	fmt.Println(mapName2)

	mapName3 := make(map[string]string)
	mapName3["Tom"] = "sahnghai"
	mapName3["Kevin"] = "shenzhen"
	mapName3["Bob"] = "yunnan"

	fmt.Println(mapName3)

	// map基本操作

	// 删除map
	// 删除指定map中指定的key
	delete(mapName2, "Tom")
	fmt.Println(mapName2)

	// 清空map
	for map_key, _ := range mapName3 {
		delete(mapName3, map_key)
	}
	fmt.Println(mapName3)
}

```

#### 8.3.3 map综合示例

- 统计字符串中每个字符出现的次数

```go
package main

import "fmt"

func main() {
	var (
		stringName1 string
		mapName1    map[byte]int
	)

	stringName1 = "hello goland"
	mapName1 = make(map[byte]int)

	for i := 0; i < len(stringName1); i++ {
		character := stringName1[i]
		mapName1[character] = mapName1[character] + 1
	}

	for character_name, character_count := range mapName1 {
		fmt.Printf("字符:%c出现的次数是: %d\n", character_name, character_count)
	}
}

```

### 8.4 结构体(struct)

#### 8.4.1 结构体基本介绍

- 目前我们所学的数据类型无法满足我们复杂的数据存储需求,我们迫切需要一种数据类型能存储一类事物的多个属性的场景
- Go语言的结构体（struct）是一种自定义复合数据类型，用于组织和存储不同类型的数据字段。结构体定义了数据的布局，允许你创建具有多个属性的自定义数据结构
- 结构体是由一些列属性组成的复合数据类型，每个属性都具有名称、类型和值，结构体将属 性组合在一起进行由程序进行处理
- 结构体用于组合不同类型的数据字段，以创建更复杂的数据结构
- 将一类事物的特性提取出来(比如猫类)， 形成一个新的数据类型，就是一个结构体。通过这个结构体，我们可以创建多个变量(实例/对象)



#### 8.4.2 结构体基本语法

- **声明一个结构体**
  - 结构体字段 = 属性 = field
  - 字段是结构体的一个组成部分，一般是基本数据类型、数组,也可是引用类型
  - 字段声明语法同变量，示例：字段名 字段类型
  - 字段的类型可以为：基本类型、数组或引用类型

```go
type Person struct {
    FirstName string
    LastName  string
    Age       int
}

//名为Person 的结构体，包含了三个字段：FirstName（字符串类型）、LastName（字符串类型）、Age（整数类型）

// 示例
	type student struct {
		id string
		name string
		age int
		addr string
	}
```



- **创建结构体变量**
  - 结构体是自定义的数据类型，代表一类事物.
  - 结构体变量(实例)是具体的，实际的，代表一个具体变量
- 在创建一个结构体变量后，如果没有给字段赋值，都对应一个零值(默认值)，规则同前面讲的一样: 
  - 布尔类型是 false ，数值是 0 ，
  - 字符串是 ""
  - 数组类型的默认值和它的元素类型相关，比如 score [3]int 则为[0, 0, 0] 
  - 指针，slice，和 map 的零值都是 nil ，即还没有分配空间

- 不同结构体变量的字段是独立，互不影响，一个结构体变量字段的更改，不影响另外一个, 结构体是值类型。

```go
package main

import "fmt"

func main() {
	// 声明结构体
	type student struct {
		id   int
		name string
		age  int
		addr string
	}

	// 创建化结构体变量
	// 写法一
	var studentName1 student = student{001, "Tom", 23, "shanghai"}
	fmt.Println(studentName1)

	// 写法二
	var studentName2 student
	studentName2.id = 002
	studentName2.name = "Kevin"
	studentName2.age = 20
	studentName2.addr = "shenzhen"

	fmt.Println(studentName2)

	// 只创建部分属性
	var studentName3 student
	studentName3.name = "Bob"
	studentName3.addr = "yunnan"

	fmt.Println(studentName3)
}
```

#### 8.4.3结构体与其他数据类型

##### 8.4.3.1 结构体与数组

- 结构体数组是一种数据结构，它允许你在一个数组中存储多个相同类型的结构体实例

```go
// 基本语法
var 结构体数组名 [下标]  结构体类型
```

- 结构体数组基本操作

```go
package main

import "fmt"

// 定义一个结构体
type studentName struct {
	id   int
	name string
	age  int
	addr string
}

func main() {
	// 创建一个结构体数组变量
	var student1 [3]studentName = [3]studentName{
		{1001, "Tom", 20, "shanghai"},
		{1002, "Kevin", 23, "shenzhen"},
		{1003, "Bob", 25, "yunnan"},
	}
	fmt.Println(student1)
	// 访问指定数据
	fmt.Println(student1[1].name)
	// 修改指定数据
	student1[2].name = "zhangsan"
	student1[2].age = 23
	fmt.Println(student1)
	// 遍历结构体数组
	fmt.Println()
	// 使用for-len
	for i := 0; i < len(student1); i++ {
		fmt.Println(student1[i])
	}
	fmt.Println()
	// 使用for-range
	for index, value := range student1 {
		fmt.Println(student1[index])
		fmt.Println(value)
	}
}
```

##### 8.4.3.2 结构体与切片

- 结构体数组由于数组长度固定无法后期延生,因此需要借助结构体和数组的结合实现动态延生

```go
// 基本语法
var 结构体切片名 [ ]  结构体类型
```

- 结构体切片

```go
package main

import "fmt"

// 定义一个结构体
type studentName struct {
	id   int
	name string
	age  int
	addr string
}

func main() {
	// 创建结构体切片变量
	var student1 []studentName = []studentName{
		{1001, "Tom", 20, "shanghai"},
		{1002, "Kevin", 23, "shenzhen"},
	}
	fmt.Println(student1)

	// 访问指定数据
	fmt.Println(student1[1])
	fmt.Println(student1[1].name)

	// 追加数据
	student1 = append(student1, studentName{1003, "Bob", 25, "yunnan"})
	fmt.Println(student1)

	//遍历
	// 使用for-len
	for i := 0; i < len(student1); i++ {
		fmt.Println(student1[i])
	}

	// 使用for-range
	for index, value := range student1 {
		fmt.Println(student1[index])
		fmt.Println(value)
	}
}

```

##### 8.4.3.3 结构体与映射

- 结构体和map结合使用，创建一种数据结构，其中map的键（key）用于快速查找结构体实例

```go
// 基本语法
make(map[key的类型]结构体)
```

- 结构体map

```go
package main

import "fmt"

// 定义一个结构体
type studentName struct {
	id   int
	name string
	age  int
	addr string
}

func main() {
	// 创建结构体map

	//var student1 map[int]studentName
	student1 := map[int]studentName{
		001: {1001, "Tom", 20, "shanghai"},
		002: {1002, "Kevin", 23, "shenzhen"},
		003: {1003, "Bob", 25, "yunnan"},
	}
	fmt.Println(student1)

	// 访问指定数据
	fmt.Println(student1[002])
	fmt.Println(student1[003].name)

	// 修改指定数据
	student1[003] = studentName{1003, "zhangsan", 25, "yunnan"}
	fmt.Println(student1)

	// 增加数据
	student1[004] = studentName{1004, "Bob", 21, "beijing"}
	fmt.Println(student1)

	// 删除指定数据
	delete(student1, 003)
	fmt.Println(student1)

	// 遍历
	for index, value := range student1 {
		fmt.Printf("编号%d中学生信息如下: %v\n", index, value)
	}
}

```

##### 8.4.3.4 结构体与指针

- 结构体与指针结合使用是一种常见的模式，特别是在需要在函数之间传递结构体的引用或在函数内部修改结构体的值时。结构体指针允许你传递和操作结构体的地址，而不是拷贝整个结构体的值，这在性能和数据一致性方面都具有优势



- 结构体指针示例

```go
package main

import "fmt"

// 定义一个结构体
type Person struct {
	Name string
	Age  int
}

// 修改结构体的值，使用指针
func modifyPerson(person *Person, name string, age int) {
	person.Name = name
	person.Age = age
}

func main() {
	// 创建一个Person结构体的实例
	alice := Person{
		Name: "Alice",
		Age:  25,
	}

	// 创建一个指向结构体的指针
	bob := &Person{
		Name: "Bob",
		Age:  30,
	}

	fmt.Printf("Alice -> %s, %d; Bob -> %s, %d\n", alice.Name, alice.Age, bob.Name, bob.Age)

	// 修改结构体的值，使用指针
	modifyPerson(&alice, "Alicia", 26)
	modifyPerson(bob, "Bobby", 31)

	fmt.Printf("Alice -> %s, %d; Bob -> %s, %d\n", alice.Name, alice.Age, bob.Name, bob.Age)
}

```

- 首先定义了一个`Person`结构体。然后，我们创建了两个不同的`Person`实例：一个使用普通结构体变量（`alice`），另一个使用结构体指针（`bob`）。

  在`modifyPerson`函数中，我们接受一个`Person`类型的指针，并通过指针来修改结构体的字段值。在`main`函数中，我们演示了如何调用这个函数来修改结构体的值。

  使用结构体指针可以避免不必要的内存拷贝，特别是当处理大型结构体时，这可以提高性能。此外，它还允许多个函数共享和修改同一个结构体实例的状态，使得程序更加灵活

#### 8.4.4 匿名字段

- 在 Go 语言中，匿名字段是一种结构体（struct）内嵌的特性，允许一个结构体类型嵌套另一个类型，而不需要提供字段名称。这使得可以访问嵌套类型的字段和方法，就好像它们是外部结构体的一部分一样。匿名字段通常与嵌套结构体一起使用，以实现组合复用
- 匿名字段通常用于实现组合关系，使得外部类型可以继承内部类型的特性
- 匿名字段通常在以下情况下使用：
  - 实现组合关系：当一个类型需要包含另一个类型的功能时，可以使用匿名字段来实现组合。
  - 重用代码：内部类型的字段和方法可以在外部类型中被重用，减少代码重复。
  - 方法覆盖：外部类型可以重写内部类型的方法，实现方法的覆盖。
- 总之，匿名字段是 Go 语言中一种强大的特性，它允许类型之间的复用和组合，提高了代码的可维护性和可扩展性

##### 8.4.4.1 基本语法

- 匿名字段的定义方式非常简单，只需在外部类型的字段列表中包含内部类型的名称，而不需要指定字段名

```go
type InnerType struct {
    // 内部类型的字段
    Field1 int
    Field2 string
}

type OuterType struct {
    // 匿名字段，类型为 InnerType
    InnerType
    // 外部类型的字段
    Field3 float64
}


// OuterType 结构体包含了一个匿名字段 InnerType，InnerType 是 OuterType 的一部分
```

##### 8.4.4.2 访问匿名字段的字段和方法

- 通过外部类型的实例，可以访问匿名字段的字段和方法，就好像它们是外部类型的一部分一样。访问的语法是使用点运算符（`.`）

```go
package main

import "fmt"

type Person struct {
    FirstName string
    LastName  string
}

type Employee struct {
    Person // 匿名字段
    EmployeeID int
}

func main() {
    emp := Employee{
        Person:     Person{FirstName: "John", LastName: "Doe"},
        EmployeeID: 12345,
    }

    fmt.Println("First Name:", emp.FirstName)
    fmt.Println("Last Name:", emp.LastName)
    fmt.Println("Employee ID:", emp.EmployeeID)
}

// Employee 结构体嵌套了 Person 结构体作为匿名字段。因此，Employee 类型继承了 Person 类型的字段，可以直接访问 FirstName 和 LastName 字段
```

##### 8.4.4.3 字段冲突

- 如果外部结构体和嵌套结构体拥有相同的字段名，则会发生字段冲突。在这种情况下，外部结构体中的字段会覆盖嵌套结构体的字段。您可以使用字段名来明确指定要访问的字段

```go
package main

import "fmt"

type A struct {
    Value int
}

type B struct {
    A  // 匿名字段
    Value string
}

func main() {
    b := B{A: A{Value: 42}, Value: "Hello"}

    fmt.Println("b.Value:", b.Value)   // 访问 B 结构体的字段
    fmt.Println("b.A.Value:", b.A.Value) // 访问 A 结构体的字段
}

// B 结构体中有一个匿名字段 A，同时也有自己的 Value 字段。通过 b.Value 可以访问 B 结构体的 Value 字段，而通过 b.A.Value 可以访问 A 结构体的 Value 字段
```

- 匿名字段还支持方法的继承和重写,我们在[[#11.4 匿名字段和方法]]

#### 8.4.5 结构体标签

- 在 Go 语言中，结构体字段的 tag 是用于在编码和解码过程中提供元信息的一种方式
- tag 是字段声明后面的一部分，使用反引号 `` 括起来。tag 可以包含一个或多个键值对，每个键值对之间用空格分隔

- tag 的一般格式如下：

```go
FieldName FieldType `tag1:"value1" tag2:"value2" ...`
```

- **JSON 标签：** 用于指定字段在 JSON 编码和解码时的行为

```go
FieldName string `json:"field_name"`

// json:"field_name" 表示在 JSON 编码和解码时，该字段将被映射为 "field_name"
```

- **环境变量标签：** 用于指定从环境变量加载配置时的字段名称

```go
FieldName string `env:"ENV_VARIABLE"`

// env:"ENV_VARIABLE" 表示在加载配置时，程序会尝试从环境变量中获取名为 "ENV_VARIABLE" 的值，将其赋给结构体字段
```

- **默认值标签：** 用于指定字段的默认值

```go
FieldName string `default:"default_value"`

// default:"default_value" 表示如果配置中没有提供对应的值，字段将被设置为 "default_value"
```

> tag的访问将在反射篇章详解

### 8.5 list(列表)链表

#### 8.5.1 列表基本概述

- 列表是一种非连续的存储容器，它存储的元素在内存中不需要相邻的位置, 由多个节点组成, 节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等
- 相比于数组，列表在插入和删除元素时更为灵活，因为它不需要像数组那样保持连续的内存空间
- 在编程中，列表可以用来表示一系列数据元素，每个元素都有一个指向下一个元素的引用（单向链表）或同时有指向前一个和后一个元素的引用（双向链表）。这种非连续的结构使得在链表中插入或删除元素的操作更为高效，尤其是在涉及大量元素移动的情况下

<img src="https://cloud.006288.xyz/PicGo//image-20240303165756553.png" alt="image-20240303165756553" style="zoom:80%;" />

#### 8.5.2 go语言中的list

- Go语言的`container/list`包提供了一个双向链表的实现，是一个常见的使用例子。在这种链表中，每个元素都包含一个指向前一个元素和后一个元素的引用，这使得在列表中的任意位置进行插入和删除操作更为方便
- `container/list`包定义了两个主要类型：`List`和`Element`
  - **List类型:**
    - `container/list`中的`List`是双向链表的主要类型。
    - 通过`list.New()`函数可以创建一个新的空链表。
  - **Element类型:**
    - `Element`表示链表中的一个元素，包含一个`Value`字段用于存储实际的数据。
    - `List`的方法返回的是`Element`类型，可以用来访问和操作链表中的元素

##### 8.5.2.1 初始化列表

- list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的

- 在Go语言的`container/list`包中，确实没有具体元素类型的限制。`List`中的元素可以是任意类型，因为`Value`字段被声明为`interface{}`类型
- 这既带来了便利，也引来一些问题，例如给列表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机

- **通过 container/list 包的 New() 函数初始化 list**

```go
// 基本语法:
变量名 := list.New()
```

- **通过 var 关键字声明初始化 list**

```go
// 基本语法
var 变量名 list.List
```

##### 8.5.2.1 在列表中插入元素

- Golang 的列表元素的插入有四种情景，分别为：
  - 在指定元素前插入
  - 在指定元素后插入
  - 在列表头部插入
  - 在列表尾部插入

> 这些方法都会返回一个 *list.Element 结构，如果在以后的使用中需要删除插入的元素，则只能通过 *list.Element 配合 Remove() 方法进行删除

```go
package main

import (
	"container/list"
)

func main() {
	// 创建一个列表
	myList := list.New()

	// 在列表头部插入元素
	myList.PushFront("hello")
	myList.PushFront(100)

	// 在列表尾部插入元素
	element := myList.PushBack("golang")

	// 在指定元素前插入元素
    // 在golang前面插入kubei元素   方法(要插入的元素,元素节点)
	myList.InsertBefore("kubei", element)

	// 在指定元素后插入元素
	// 在golang后面插入Tom元素     方法(要插入的元素,元素节点)
	myList.InsertAfter("Tom", element)
    
    
}

```

##### 8.5.2.2 删除列表中的元素

- 列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除
- 删除元素使用 remove 函数，删除的元素不能为空，如果为空，会报异常

```go
import (
	"container/list"
	"fmt"
)

func main() {
	// 创建一个列表
	myList := list.New()

	// 在列表头部插入元素
	myList.PushFront("hello")
	myList.PushFront(100)

	// 在列表尾部插入元素
	element := myList.PushBack("golang")

	// 在指定元素前插入元素
	// 在golang前面插入kubei元素
	myList.InsertBefore("kubei", element)

	// 在指定元素后插入元素
	// 在golang后面插入Tom元素
	myList.InsertAfter("Tom", element)
	
    // 删除golang元素
	myList.Remove(element)

}
```

##### 8.5.2.3 遍历列表中的元素

- 在Go语言中，链表的遍历可以通过使用`for`循环结合链表的`Next()`方法来实现

```go
// 正序遍历列表基本语法
	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println("Element = ", i.Value)
	}

//  倒序遍历列表基本语法
	for i := myList.Back(); i != nil; i = i.Prev() {
		fmt.Println("Element = ", i.Value)
	}


// myList.Front()：获取链表的第一个元素的指针，因为这是一个双向链表，所以这个指针可以向前或向后移动。
// myList.Back(): 获取链表的最后一个元素的指针
// i != nil：循环条件，只要当前元素不是nil（链表尾部之后的元素），就继续循环。
// i = i.Next()：在每次循环迭代中，将指针移动到链表中的下一个元素
// 在每次循环迭代中，打印当前元素的值。i.Value 是链表节点中存储的实际值
```

- 基本示例

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	// 创建一个列表
	myList := list.New()

	// 在列表头部插入元素
	myList.PushFront("hello")
	myList.PushFront(100)

	// 在列表尾部插入元素
	element := myList.PushBack("golang")

	// 在指定元素前插入元素
	// 在golang前面插入kubei元素
	myList.InsertBefore("kubei", element)

	// 在指定元素后插入元素
	// 在golang后面插入Tom元素
	myList.InsertAfter("Tom", element)

	// 删除golang元素
	myList.Remove(element)

	// 正序遍历列表
	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println("Element =", i.Value)
	}

	// 倒序遍历列表
	for i := myList.Back(); i != nil; i = i.Prev() {
		fmt.Println("Element =", i.Value)
	}

}
```

##### 8.5.2.4 移动列表中的元素

- Golang 的列表元素的移动有两种情景，分别为：
  - 将指定元素移动到另一元素的前面
  - 将指定元素移动到另一元素的后面
  - 将指定元素移动列表最前
  - 将指定元素移动列表最后

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	myList := list.New()

	element1 := myList.PushFront("hello")
	element2 := myList.PushFront("golng")
	element3 := myList.PushBack("kubei")

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}

	// 将指定元素移动到另一元素的前面
	myList.MoveBefore(element1, element2)

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}

	// 将指定元素移动到另一元素的后面
	myList.MoveAfter(element3, element2)

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}

	// 将指定元素移动列表最前
	myList.MoveToFront(element3)

	// 将指定元素移动列表最后
	myList.MoveToBack(element2)

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}
}

```

##### 8.5.2.5 修改列表中的元素

- 在Go语言的`container/list`包中，要修改链表中的元素值，你可以直接访问`Element`类型的`Value`字段，然后进行赋值操作
- Golang 的列表元素的修改有两种情景，分别为：
  - 修改列表的第一个元素
  - 修改列表的最后一个元素
  - 修改列表中指定的元素

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	myList := list.New()

	myList.PushFront("hello")
	myList.PushFront("golng")
	myList.PushBack("kubei")

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println("原始列表: ", i.Value)
	}

	// 修改列表第一个元素
	myList.Front().Value = "java"

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println("修改列表第一个元素后的列表: ", i.Value)
	}

	// 修改列表最后一个元素
	myList.Back().Value = "Tom"

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println("修改列表最后一个元素后的列表: ", i.Value)
	}

	// 修改列表中指定元素
	modifyElement(myList, "java", "python")

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println("修改列表中指定元素后的列表: ", i.Value)
	}

}

func modifyElement(l *list.List, oldValue, newValue interface{}) {
	for element := l.Front(); element != nil; element = element.Next() {
		if element.Value == oldValue {
			element.Value = newValue
			return
		}
	}
}
```

##### 8.5.2.6 获取列表长度

```go
package main

import (
	"container/list"
	"fmt"
)

func main() {
	myList := list.New()

	myList.PushFront("hello")
	myList.PushFront("golng")
	myList.PushBack("kubei")

	for i := myList.Front(); i != nil; i = i.Next() {
		fmt.Println(i.Value)
	}

	// 获取列表长度
	fmt.Println(myList.Len())
}
```



## 9. 函数

- 为什么需要函数: 在实际开发中，我们使用函数的目的只有一个“让我们的代码可以被重复使用”
- 函数的作用有两个：模块化编程, 代码重用

### 9.1 什么是函数

- 所谓的函数就是一个被命名的、独立的、完成特定功能的代码段（一段连续的代码），并可能给调用它的程序一个返回值
  - 被命名的：函数大多数是有名函数。当然也存在没有名字的函数叫做匿名函数。
  - 独立的、完成特定功能的代码段：在实际项目开发中，定义函数前一定要先思考一下，这个函数是为了完成某个操作或某个功能而定义的。（函数的功能一定要专一）
  - 返回值：很多函数在执行完毕后，会通过return关键字返回一个结果给调用它的位置

### 9.2 函数的基本语法

- 函数包含函数名、行参列表、函数体和返回值列表，使用 func 进行声明，函数无参数或返 回值时则形参列表和返回值列表省略

  - 函数可以接受零个或多个参数。参数由参数名称和参数类型组成，用逗号分隔。参数放在函数名后面的括号内
  - 函数可以返回一个或多个值。返回值的类型由函数声明的`returnType`决定。如果函数不返回任何值，可以省略返回类型

  - Go语言允许函数返回多个值。这在处理多个相关值时非常有用。例如，可以返回一个值和一个错误状态

- 函数通过函数名(实参列表)，在调用过程中实参的每个数据会赋值给形参中的每个变量，因 此实参列表类型和数量需要函数定义的形参一一对应。针对函数返回值可通过变量赋值的方 式接收

```go
// 声明函数
func functionName(parameter1 type1, parameter2 type2) returnType {
    // 函数体
    return 返回值列表 // 可选
}

// 调用函数
functionName(参数1,参数2...)



// 无参无返回值函数
func functionName() {
    // 函数体
}

// 有参数无返回值函数
func functionName(parameter1 type1) {
    // 函数体
}

// 多返回值
func functionName(parameter1 type1, parameter2 type2) (returnType1, returnType2...) {
    // 函数体
    return 返回值1,返回值2...
}
```

- 示例

```go
package main

import "fmt"

// 有参数有返回值函数
func jisuanqi(a float64, yunsuanfu byte, b float64) float64 {
	var result float64
	switch yunsuanfu {
	case '+':
		result = a + b
	case '-':
		result = a - b
	case '*':
		result = a * b
	case '/':
		result = a * b
	default:
		fmt.Println("输入有误")
	}
	return result

}

// 无参数无返回值
func daying() {
	fmt.Println("我是无参数无返回值函数")
}

// 有参数无返回值
func danyingshenji(daying_string string) {
	fmt.Println("我是有参数无返回值函数")

}

// 多返回值
func divideAndRemainder(a, b int) (int, int) {
	quotient := a / b
	remainder := a % b
	return quotient, remainder
}

// 函数调用
func main() {
	var a, b float64 = 3.5, 2.5
	var yunsuanfu byte = '+'

	func_result := jisuanqi(a, yunsuanfu, b)
	fmt.Printf("%.2f %c %.2f = %.2f\n", a, yunsuanfu, b, func_result)

	daying()

	demo_string := "niujinjian"
	danyingshenji(demo_string)

	var c, d int = 3, 2
	func_divideAndRemainder_result1, func_divideAndRemainder_result2 := divideAndRemainder(c, d)
	fmt.Println(func_divideAndRemainder_result1, func_divideAndRemainder_result2)

}
```

### 9.3 函数参数

#### 9.3.1 类型合并

- 在声明函数中若存在多个连续形参类型相同可只保留最后一个参数类型名

```go
func divideAndRemainder(a, b,c,int) int {
    quotient := a / (b + c)
	return quotient
}
```

#### 9.3.2 可变参数

- 某些情况下不知道调用者会传递多少个参数, 此时就需要函数能够接受和处理不定数量的参数，使用运算符`…`声明可变参数, 函数或在调用时传递可变参数即可
- 可变参数在函数内部被视为切片（slice）
- 在调用函数时，也可以使用运算符…将切片解包传递到可变参数函数中

```go
package main

import (
	"fmt"
)

// 函数接受可变参数并计算它们的和
func sum(numbers ...int) int {
	total := 0
	for _, num := range numbers {
		total += num
	}
	return total
}

func main() {
	result := sum(1, 2, 3, 4, 5)
	fmt.Println("Sum:", result)
    
    
    slice := []int{1, 2, 3, 4, 5}
	// 使用 ... 运算符将切片解包并传递给可变参数函数
	result2 := sum(slice...)
	fmt.Println("Sum:", result2)
}

```

### 9.4 函数返回值

- 在函数提中可以使用 return 关键字为函数调用这提供函数计算结果

- 多返回值
  - go 语言支持函数有多个返回值，在声明函数时使用括号包含所有返回值类型，并使用 return 返回对应数量的用逗号分割数据
- 命名返回值:
  - 在函数返回值列表中可指定变量名，变量在调用时会根据类型使用零值进行初始化，在函数体中可进行赋值，同时在调用 return 时不需要添加返回值，go 语言自动将变量的最终结果 进行返回 
  - 在使用命名返回值时，当声明函数中存在若多个连续返回值类型相同可只保留最后一个返回 值类型名
  - 在 Go 语言中，可以为函数的返回值命名，这使得在函数体内可以直接使用这些命名的返回值变量，而无需显式声明。命名返回值在使代码更加清晰易读的同时，也能够提高代码的可维护性

```go
package main

import (
	"fmt"
)

// 函数使用命名返回值
func divideAndRemainder(a, b int) (quotient int, remainder int) {
	quotient = a / b
	remainder = a % b
	return // 无需显式返回具体的变量名
}

func main() {
	numerator := 10
	denominator := 3

	quotient, remainder := divideAndRemainder(numerator, denominator)
	fmt.Printf("%d divided by %d is %d with a remainder of %d\n", numerator, denominator, quotient, remainder)
}
```

### 9.5 递归函数

- 递归是一种在函数内部调用自身的技术。从数学解题思路来说，递归就是把一个大问题拆分成多个小问题，再各个击破，在实际开发过程中，递归函数可以解决许多数学问题，如计算给定数字阶乘、产生斐波系列等
- 在 Go 语言中，可以使用递归来解决需要重复执行相似操作的问题，例如计算阶乘、斐波那契数列等。然而，使用递归需要小心，因为如果不正确地设计递归条件，可能会导致无限循环或堆栈溢出。



- 构成递归需要具备以下条件：
  - 一个问题可以被拆分成多个子问题；
  - 拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；
  - 不能无限制的调用本身，子问题需要有退出递归状态的条件

> 注意：编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。

#### 9.5.1 递推算法

- 递推算法：递推算法是一种简单的算法，即通过已知条件，利用特定条件得出中间推论，直至得到结果的算法。递推又分为顺推和逆推。

- 递推算法是通过循环结构来解决问题，它在循环内部执行一系列操作，逐步得到问题的解。迭代通常使用循环控制结构来重复执行特定的代码块，直到满足某个终止条件

  - 顺推：通过最简单的条件，然后逐步推演结果
  - 逆推：通过结果找到规律，然后推导已知条件

```go
// 使用递推算法实现斐波那契数列
// 斐波那契数列: 每个数都是前两个数之和
// 分析: 1   1    2    3    5    8    13    21   ...
// 第1位为1, 第2位为1, 第三位为2= 1 + 1, 第四位为: 3 = 1 +2 ,第n位为: f(n) = f(n-1) + f(n-2)
package main

import (
	"fmt"
)

func fibonacciIterative(n int) int {
	if n <= 1 {
		return n
	}

	a, b := 0, 1
	for i := 2; i <= n; i++ {
		a, b = b, a+b
	}
	return b
}

func main() {
	num := 8
	result := fibonacciIterative(num)
	fmt.Printf("Fibonacci of %d is %d\n", num, result)
}
```

#### 9.5.2 递归算法

- 程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量

- 递归函数使用场景:
  - 多级目录文件遍历
  - 多层数据结构数据查找
  - 网页菜单自动生成
  - 路由管理
  - 数值计算: 阶乘,斐波那契数列,幂等



- 递归有两个非常重要的概念:
  - ① 递归点：找到解决当前问题的等价函数（先解决规模比当前问题小一些的函数，依次类推，最终实现对问题的解决） => 有递有归
  - ② 递归出口：当问题解决的时候，已经到达（必须存在）最优问题，不能再次调用函数了



- 编写递归三步走:
  - ① 明确你这个函数想要干什么
    - 如：求斐波那契数列
  - ② 寻找递归结束条件
    - 如：就是在什么情况下，递归会停止循环，返回结果
  - ③ 找出函数的等价关系式
    - 如：斐波那契数列，第n位 f(n) = f(n-1) + f(n-2)



- 案例1:  使用递归算法实现斐波那契数列

```go
// 斐波那契数列: 每个数都是前两个数之和
// 分析: 1   1    2    3    5    8    13    21   ...
// 第1位为1, 第2位为1, 第三位为2= 1 + 1, 第四位为: 3 = 1 +2 ,第n位为: f(n) = f(n-1) + f(n-2)

package main

import "fmt"

func feibonaqi(num int) int {
	if num <= 2 {
		return 1
	} else {
		return feibonaqi(num-1) + feibonaqi(num-2)
	}
}

func main() {
	n := 8
	result := feibonaqi(n)
	fmt.Println(result)
}
```

- 案例2:  使用递归函数求阶乘

```go
// 阶乘是什么？一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，如：n!=1×2×3×...×(n-1)×n
// 分析:
// 1! = 1 
// 2! = 1 * 2 = 2 * 1! 
// 3! = 1 * 2 * 3 = 3 * 2!
// n! = 1 * 2 * ...(n-1) * n = n * (n-1)!

package main

import "fmt"

func jiecheng(num int) int {
	if num <= 1 {
		return 1
	} else {
		return jiecheng(num-1) * num
	}
}

func main() {
	var a int = 8
	result := jiecheng(a)
	fmt.Println(result)
}
```

- 案例3：猴子吃桃问题
  - 猴子吃桃问题。猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子

```go
// 10天 --> 1
// 9天 --->总4 吃3 剩1
// 8天 --->总10 吃6 剩4
....
// 1天 ---> 总n 吃n/2 + 1 剩(n/2 + 1) - 1 

package main

import "fmt"

func chitao(day int) int {
	if day == 10 {
		return 1
	} else {
		return (chitao(day+1) + 1) * 2
	}
}

func main() {
	num := 1
	result := chitao(num)
	fmt.Println(result)
}
```

### 9.6 匿名函数和闭包

#### 9.6.1 匿名函数

- 不需要定义名字的函数叫做匿名函数。匿名函数可以在函数内部定义，或者作为参数传递给其他函数，还可以用作函数的返回值。它们通常用于需要封装一些行为或逻辑的场景，特别是在函数内部需要定义局部函数时



- **匿名函数使用方式**
- 匿名函数作为局部变量： 匿名函数可以在函数内部定义，然后将其赋值给一个变量，从而可以在函数内部使用这个匿名函数

```go
package main

import "fmt"

func main() {
	// 将匿名函数赋值给一个变量
	Func1 := func(a, b int) int {
		result := a + b
		return result
	}
	// 在函数内调用匿名函数
	fmt.Println(Func1(10, 20))

}
```

- 在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次

```go
package main

import "fmt"

func main() {
	// 定义匿名函数时就直接调用匿名函数
	Func2 := func(a, b int) int {
		result2 := a - b
		return result2
	}(20, 10)          // 调用匿名函数
	fmt.Println(Func2)
}
```

- 如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在整个程序有效

```go
package main

import "fmt"

// 定义匿名函数
var (
	Func4 = func(a, b int) int {
		result3 := a * b
		return result3
	}
)

func main() {

	// 使用匿名函数
	fmt.Println(Func4(10, 20))
}
```

#### 9.6.2 闭包

- 闭包是指有权访问另一个函数作用域中的变量的函数

- 说到Go语言的闭包，不得不说说全局变量和局部变量

  - 全局变量的特点：
       - 常驻内存  
       - 污染全局
  - 局部变量的特点：
    - 不常驻内存
    - 不污染全局

  - Go语言的闭包主要是为了避免全局变量的滥, 闭包可以做到: 
    - 可以让变量常驻内存
    - 可以让变量不污染全局

- 函数 + 引用环境 = 闭包

- 同一个函数与不同引用环境组合，可以形成不同的闭包实例

- 创建闭包的常见方式就是在一个函数内部创建另一个函数， 内函数可以访问外函数的变量
- 闭包里作用域返回的局部变量不会被立刻销毁回收，但过度使用闭包可能会占用更多内存，导致性能下降



- 闭包示例

```go
package main

import "fmt"

func Func1() func(a int) int {
	sum := 0
	return func(a int) int {
		for i := 0; i < a; i++ {
			sum += i
		}
		return sum
	}

}

func main() {
	Func4_object := Func1()
	Func4_result := Func4_object(5)
	fmt.Println(Func4_result)
}

// 闭包是类，函数是操作，a是字段，函数和他使用的变量构成闭包
```

#### 9.6.3 匿名函数和闭包综合案例

- 场景需求:
  - 编写一个程序判断用户输入的文件后缀是否正确
  - 如果正确放回原文件,如果不正确则修改文件后缀名,并放回修改后的文件名

```go
package main

import (
	"fmt"
	"path/filepath"
	"strings"
)

func File_check(file_suffix string) func(file_name string) string {

	return func(file_name string) string {
		name := filepath.Base(file_name)   // 获取文件名
		suffix := filepath.Ext(file_name)  // 获取文件名后缀
		if !strings.HasSuffix(file_name, file_suffix) {   // 如果文件名后缀不是以file_suffix结尾的就修改
            // 文件名的长度减去后缀的长度就等于纯文件名不含后缀的文件名,在加上需要修改的文件名后缀就可以了
			file_name = name[:len(name)-len(suffix)] + file_suffix
			return file_name
		} else {
			return file_name
		}
	}

}

func main() {
	var (
		file_suffix string
		file_name   string
	)
	fmt.Print("请输入你要检查的文件后缀[.jpg/.png/.txt..]")
	fmt.Scanln(&file_suffix)
	fmt.Print("请输入你要检查的文件名:")
	fmt.Scanln(&file_name)
	File_check_project := File_check(file_suffix)
	fmt.Println(File_check_project(file_name))

}

```

### 9.7 init函数和defer函数

#### 9.7.1 init函数

- 在Go语言中，`init` 函数是一个特殊的函数，它用于在程序执行开始时(执行main函数前)自动初始化（初始化包或程序）或执行特定的设置工作。
- 每个包可以包含一个或多个 `init` 函数，这些函数会在程序执行时自动被调用，但是它们不能被手动调用



- `init` 函数的特点和用法如下
  - 一个包可以包含多个 `init` 函数，它们按照它们在源文件中的顺序被调用。
  - `init` 函数没有参数，也没有返回值。
  - `init` 函数的命名是固定的，不能被改变。
  - `init` 函数通常用于执行一些初始化任务，如设置全局变量、打开数据库连接、注册HTTP路由等。
  - 在程序运行时，`init` 函数会在 `main` 函数之前被调用，确保在 `main` 函数之前完成必要的初始化工作

```go
package main

import "fmt"

var (
	name string
	age  int = 23
)

func init() {
	name = "Bob"
	fmt.Printf("第一个初始化函数完成, name: %s, \tage: %d\n", name, age)
}

func init() {
	name = "Tom"
	age = 20
	fmt.Printf("第二个初始化函数完成, name: %s, \tage: %d\n", name, age)

}

func main() {
	fmt.Printf("开始执行主函数,       name: %s, \tage: %d\n", name, age)

}
```

####  9.7.2 defer函数

- 在日常编程中经常需要创建资源(比如：数据库连接、文件句柄、锁等) ，为了在函数执行完毕后，及时的释放资源，Go 的设计者提供 defer (延时机制)
- Go语言中的 `defer` 语句用于延迟（推迟）函数的执行，通常在函数退出之前执行某些清理或释放资源的操作。
- `defer` 语句非常有用，因为它可以确保在函数的末尾执行一些必要的操作，无论函数是正常退出还是因为发生错误而退出



- defer函数注意事项

  - 当 go 执行到一个 defer 时，不会立即执行 defer 后的语句，而是将defer 后的语句压入到一个栈中, 为了方便理解，暂时称该栈为 defer 栈, 然后继续执行函数下一个语句

  - 当函数执行完毕后，在从 defer 栈中，依次从栈顶取出语句执行(注：遵守栈先入后出的机制(FILO))

  - 在 defer 将语句放入到栈时，也会将相关的值拷贝同时入栈

  - `defer` 常用于确保在函数退出时关闭文件、释放资源等操作。这样可以避免因为函数的多个出口而忘记执行清理操作，但要确保资源的释放在 `defer` 语句之前正确完成

  - `defer` 语句常用于处理函数返回的错误。在调用可能返回错误的函数后，可以使用 `defer` 来确保错误的处理代码位于函数的最后，以避免遗漏错误处理

  - 虽然 `defer` 是一个强大的工具，但不应该滥用它。只有当需要延迟执行的代码确实与函数的逻辑相关，或者需要确保资源的释放时，才应该使用 `defer`。不必要的 `defer` 语句可能会导致代码变得复杂和难以理解

  - 在循环中使用 `defer` 时需要格外小心，因为 `defer` 会在函数退出时执行，如果在循环中大量使用，可能会导致资源被推迟释放，影响程序性能

  - defer语句与return语句同时出现时，会有一些特殊的执行顺序。当函数执行到return语句时，会先对返回值进行赋值操作，然后再执行defer语句，最后才会真正返回。这意味着，如果有defer语句，它会在函数返回之前执行

```go
package main

import "fmt"

func defer_demo() int {
	sum := 0
	defer func() int {
		fmt.Print("执行第一个defer  ")
		sum += 10
		fmt.Println(sum)
		return sum
	}()
	defer func() int {
		fmt.Print("执行第二个defer  ")
		sum += 20
		fmt.Println(sum)
		return sum
	}()
	return sum
}

func main() {
	result := defer_demo()
	fmt.Println(result)
}
```

### 9.8 函数参数传递的方式

- 在Go语言中，函数参数传递有两种方式：值传递（pass by value）和引用传递（pass by reference）

#### 9.8.1 两种传递方式

- 关于两种传递方式前面章节已经有所介绍 --->[[#5.8 值类型和引用类型]]
- 在值传递中，函数接收的是实际参数（即调用函数时传递的值）的副本，而不是实际参数本身。这意味着函数内部对参数的修改不会影响到外部传递的值
- Go语言中并没有真正的引用传递的方式，但可以通过传递指针来模拟引用传递的效果。在这种情况下，函数接收的是实际参数的内存地址，允许在函数内部修改原始数据
- 不管是值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低

#### 9.8.2 值传递和引用传递注意事项

- **值传递（Pass by Value）的注意事项：**
  - 不会影响原始数据：在值传递中，函数接收的是实际参数的副本，对参数的修改不会影响到原始数据。这意味着函数内的变化不会传递到函数外部。
  - 适用于不希望函数改变参数的情况：值传递适用于那些希望保持参数不变的情况，确保函数不会修改原始数据
  - 副本可能占用额外的内存：在值传递中，参数的副本可能会占用额外的内存，特别是对于大型数据结构
- **引用传递（通过指针模拟的方式）的注意事项：**
  - 可以影响原始数据： 通过传递指针，函数可以直接修改原始数据。这可以用于需要在函数内部修改外部数据的情况
  - 谨慎处理指针： 使用引用传递时，要小心处理指针，确保不会导致空指针异常或其他指针相关的错误
  - 共享内存： 引用传递可能导致多个函数共享相同的内存，因此需要确保数据的同步和访问控制以避免竞态条件和数据竞争。
  - 可能引入并发问题：在多线程或并发程序中，使用指针传递可能引入并发问题，因为多个线程可以同时访问相同的内存位置
  - 注意生命周期： 引用传递通过指针引用外部数据，但要注意确保在数据仍然有效时进行引用。如果引用了已释放的内存，会导致不确定的行为
- 选择值传递还是引用传递（使用指针）取决于你的需求和特定情况。通常情况下，在Go语言中使用值传递是更常见和更安全的方式，因为它避免了共享内存和并发问题。但在需要修改原始数据或避免复制大型数据结构时，可以考虑使用指针传递。不论选择哪种方式，都需要谨慎处理函数参数以确保程序的正确性和可维护性。

```go
package main

import "fmt"

func func_modify(a int, b *int) {
	a = 20
	*b = 20
}

func main() {
	var (
		a int = 10
		b int = 10
	)
	func_modify(a, &b)
	fmt.Printf("a: %d, b: %d\n", a, b)
}
```

### 9.9 错误处理

- 在默认情况下，当发生错误后(panic) ,程序就会退出（崩溃.）
- 如果我们希望：当发生错误后，可以捕获到错误，并进行处理，保证程序可以继续执行。还可以在捕获到错误后，给管理员一个提示(邮件,短信。。。）,这就需要进行错误处理

- Go 语言追求简洁优雅，所以，Go 语言不支持传统的 try…catch…finally 这种处理
- Go语言提供了一种强大而灵活的错误处理机制，使用错误值（error values）和延迟函数（defer）来处理错误。错误值是一种实现了`error`接口的类型，通常用于表示函数调用是否成功以及失败的原因

#### 9.9.1 panic函数

- 在Go语言中，`panic` 是一个内建函数，用于引发运行时恐慌（panic）。当程序执行到 `panic` 函数时，常表示程序遇到了无法继续执行的致命错误, 会立即停止当前函数的执行，并开始沿着调用栈向上寻找适当的`recover`函数，直到整个程序崩溃或者`recover`函数被找到
- `panic` 函数接受一个参数，通常是一个实现了 `interface{}` 接口的值(空接口)，它可以是任何类型的数据



- `panic` 函数的一些重要事项：
  - 恐慌的触发条件：通常，`panic` 会在程序遇到无法处理的错误时触发。例如，数组越界、空指针解引用等。
  - 程序崩溃：当 `panic` 函数被调用时，程序会立即崩溃，并且不会继续执行剩余的代码。
  - 恐慌的捕获：要捕获并处理恐慌，可以使用 `recover` 函数。`recover` 函数必须在延迟函数（`defer`）内部调用，并且只有在恐慌发生时才能捕获恐慌。通过 `recover` 可以使程序在遇到恐慌后继续执行而不崩溃

```go
// 手动触发panin
package main

import "fmt"

func TesterError(a, b int) (result int) {
	result = a / b
	return
}

func main() {
	fmt.Println("程序开始执行")
	result := TesterError(10, 2)
	fmt.Println(result)
	// 手动触发panic
	panic("函数返回值有问题,发生panic")
	fmt.Println("程序结束")
}

 // 通常我们不会手动触发panic,但是如果我们程序运行时发生了比较严重的异常,系统会调用panic函数,终止程序运行
package main

import "fmt"

func TesterError(a int) [10]int {
	var TesterArray [10]int
	TesterArray[a] = 88
	return TesterArray
}

func main() {
	result := TesterError(11)    // 数组下标越界,触发panic,终止程序执行
	fmt.Println(result)
}
```

#### 9.9.2 error接口

- Go 语言通过 error 接口实现错误处理的标准模式，通过使用函数返回值列表中的最后一个 值返回错误信息，将错误的处理交由程序员主动进行处理
- 在Go语言中，`error` 是一个内置的接口类型，它定义了一个名为 `Error()` 的方法，用于返回一个描述错误的字符串
- `error` 接口只有一个方法，即 `Error()` 方法，该方法没有参数，返回一个字符串类型。这个字符串通常包含了有关错误的描述信息

```go
// 基本语法
type error interface {
    Error() string
}
```



- 定义自己的错误类型，只需实现`error`接口即可, `error`接口只有一个方法，即`Error`方法，因此只要实现了这个方法，就可以创建自定义的错误类型
  - 实现 `Error` 方法的方式允许创建包含更多错误状态信息的自定义错误类型。
  - 通过创建一个新的结构体类型，并为其实现 `Error` 方法，你可以自定义错误的行为和属性。
  - 这种方式使你能够创建更复杂、结构化的错误类型，提供更多的上下文信息

```go
type MyError struct {
    Msg string
}

func (e *MyError) Error() string {
    return e.Msg
}

```

- 通过 errors 包的 New 方法自定义错误
  - 使用 `errors.New` 创建错误非常简单，它只需要一个字符串参数，该字符串将成为错误的错误消息。
  - 这种方法创建的错误类型是一个基本的 `error` 接口实现，只包含错误消息。
  - 适用于简单的错误场景，不需要包含额外的错误状态信息

```go
package main

import (
	"errors"
	"fmt"
)

func Tester_error(a, b int) (result int, err error) {
	if b == 0 {
		err = nil
		err = errors.New("输入有误,除数不等于0,程序终止")
		return
	} else {
		result = a / b
		return
	}
}

func main() {
	result, err := Tester_error(10, 0)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(result)
	}

}
```

- **fmt.Errorf 函数**：`fmt` 包的 `Errorf` 函数可以用于创建格式化的错误消息

```go
package main

import (
	"errors"
	"fmt"
)

func Tester_error(a, b int) (result int, err error) {
	if b == 0 {
		err = nil
		err = errors.New("输入有误,除数不等于0,程序终止")
		return
	} else {
		result = a / b
		return
	}
}

func main() {
	result, err := Tester_error(10, 0)
	if err != nil {
		err := fmt.Errorf("程序发生错误,错误信息如下: %s\n", err)
		fmt.Println(err)
	} else {
		fmt.Println(result)
	}

}
```

- 自定义错误案例场景

```go
package main

import (
	"errors"
	"fmt"
	"os"
)

type MyError struct {
	filename string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("文件%v不存在\n", e.filename)
}

func checkfile(filename string) (string, error) {
	_, erro := os.Stat(filename)
	if errors.Is(erro, os.ErrNotExist) {
		return "", &MyError{filename: filename}
	}
	return filename, nil
}

func main() {
	var filename string
	fmt.Print("请输入你要检查的文件名: ")
	fmt.Scanln(&filename)
	result, err := checkfile(filename)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(result)
	}
}

```

- 自定义错误场景2

```go
package main

import (
	"errors"
	"fmt"
	"os"
)

// 自定义错误类型
type FileNotFoundError struct {
	FileName string
}

func (e *FileNotFoundError) Error() string {
	return fmt.Sprintf("文件 '%s' 不存在", e.FileName)
}

// 读取文件内容，可能返回文件不存在错误
func readFileContent(fileName string) (string, error) {
	content, err := os.ReadFile(fileName)
	if err != nil {
		// 如果是文件不存在的错误，则返回自定义的错误类型
		// errors.Is 是 Go 语言标准库中用于检查错误链中是否包含特定错误的函数
		// err：要检查的错误。
		// target：目标错误，用于检查是否是 err 错误链中的错误
		// errors.Is 函数的返回值是一个布尔值，表示 err 是否包含 target 错误

		// os.ErrNotExist 是一个变量，表示文件或目录不存在的错误
		// 使用指针的方式是为了确保错误链的正确形成和正确的错误匹配
		if errors.Is(err, os.ErrNotExist) {
			return "", &FileNotFoundError{FileName: fileName}
		}
		// 其他类型的错误直接返回
		return "", err
	}
	return string(content), nil
}

func main() {
	var fileName string

	fmt.Print("请输入文件名: ")
	fmt.Scanln(&fileName)

	content, err := readFileContent(fileName)
	if err != nil {
		// 处理错误
		switch err.(type) {
		case *FileNotFoundError:
			fmt.Println("文件不存在错误:", err)
		default:
			fmt.Println("未知错误:", err)
		}
	} else {
		// 处理成功的情况
		fmt.Println("文件内容:", content)
	}
}

```



#### 9.9.3 recover函数

- `recover` 是Go语言的一个内置函数，用于在发生panic时恢复程序的控制流。`recover` 的主要作用是捕获和处理panic，以防止程序异常终止
- recover仅在 defer 语句的函数中有效，用于截取错误处理流程，recover 只能捕获到最后一个错误

- **`recover` 的工作原理**：
  - `recover` 只能在延迟函数（`defer`）中调用。
  - 当程序发生恐慌时，所有的延迟函数会按照后进先出（LIFO）的顺序执行。
  - 如果 `recover` 在延迟函数内被调用，它会终止当前的恐慌，并返回 `panic` 传递的值。
  - 如果 `recover` 在非延迟函数内被调用或在没有发生恐慌的情况下被调用，它将返回 `nil`。

- **`recover` 的限制**：
  - `recover` 只能用于恢复延迟函数内的恐慌，不能用于捕获并处理在主函数中的恐慌。
  - 如果程序没有发生恐慌，或者恐慌没有被延迟函数捕获，`recover` 会返回 `nil`。
  - 一旦 `recover` 被调用并处理了恐慌，它不会再次捕获其他恐慌。在同一个延迟函数内，只能使用一次 `recover`

```go
package main

import "fmt"

func Tester_recover(a, b int) (result int) {
	defer func() {
		if err := recover(); err != nil {
			fmt.Print("输入有误，请重新输入")
			fmt.Scanln(&b)
			result = a / b
		}
	}()

	// 在defer之前设置可能引起panic的代码
	result = a / b
	return
}

func main() {
	var (
		a int
		b int
	)

	fmt.Print("请输入除数: ")
	fmt.Scanln(&a)
	fmt.Print("请输入被除数: ")
	fmt.Scanln(&b)

	result := Tester_recover(a, b)
	fmt.Println(result)
}
```

## 10. 数据嵌套

### 10.1 什么是数据嵌套

- 数据嵌套是指在一个数据结构中包含另一个数据结构的概念。这可以发生在相同和不同的数据类型和数据结构之间，例如在结构体、映射、切片、数组等数据结构中嵌套其他数据结构。数据嵌套允许创建更复杂和层次化的数据模型，使程序能够更灵活地表示和操作各种信息

### 10.2 数据嵌套的场景

#### 10.2.1 切片和数组的嵌套

```go
type Matrix [][]int

func main() {
    mat := Matrix{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }

    fmt.Println(mat[0][0]) // 访问二维切片中的元素
}


// Matrix 是一个切片的切片，形成了二维的数组结构
```

#### 10.2.2 map嵌套

```go
package main

import "fmt"

var StudentInfo map[string]map[string]string

func AddStudentInfo(studentinfo map[string]map[string]string, name, id, age, add string) map[string]map[string]string {
	if studentinfo == nil {
		studentinfo = make(map[string]map[string]string)
	}
	studentinfo[name] = make(map[string]string)
	studentinfo[name]["id"] = id
	studentinfo[name]["age"] = age
	studentinfo[name]["add"] = add

	return studentinfo
}

func PrintStudentInfo(studentinfo map[string]map[string]string, name string) {
	if studentname, ok := studentinfo[name]; ok {
		fmt.Printf("学生姓名: %s, 学生ID: %s, 学生年龄: %s, 学生地址: %s\n", name,
			studentname["id"], studentname["age"], studentname["add"])
	} else {
		fmt.Printf("学生 %s 不存在\n", name)
	}
}

func main() {
	Tominfo := AddStudentInfo(StudentInfo, "Tom", "1001", "23", "shanghai")
	PrintStudentInfo(Tominfo, "Tom")

}
```

#### 10.2.3 切片和map嵌套

- 切片嵌套map

```go
package main

import "fmt"

var TheMenu []map[string]float64

func SetMenu(themenu *[]map[string]float64, dishes string, price float64) []map[string]float64 {
	if *themenu == nil {
		*themenu = make([]map[string]float64, 0)
	}
	*themenu = append(*themenu, map[string]float64{dishes: price})
	return *themenu
}

func main() {
	var menu []map[string]float64
	SetMenu(&menu, "锅包肉", 68.8)
	SetMenu(&menu, "水煮鱼", 39.8)
	SetMenu(&menu, "地三鲜", 18.8)


	for _, showmenu := range menu {
		for dishes, price := range showmenu {
			fmt.Printf("菜品: %s, 价格: %.2f \n", dishes, price)
		}
	}
}

```

#### 10.2.4 map嵌套切片

```go
package main

import "fmt"

var mentor map[string][]string

func MentorSystem(mentorstudent map[string][]string, mentor_name, student_name string) map[string][]string {
	if mentorstudent == nil {
		mentorstudent = make(map[string][]string)
	}
	// 由于append函数返回一个新的切片，因此我们可以将返回的新切片赋值给mentorstudent[mentor_name]，以实现切片的追加操作
	mentorstudent[mentor_name] = append(mentorstudent[mentor_name], student_name)
	return mentorstudent
}

func initmentor(mentor map[string][]string, mentor_name string, student_names ...string) map[string][]string {
	for _, student_name := range student_names {
		mentor = MentorSystem(mentor, mentor_name, student_name)
	}
	return mentor
}

func main() {
	laozhang := initmentor(mentor, "laozhang", "xiaowang", "xiaoli", "xiaochen")
	laocheng := initmentor(mentor, "laocheng", "xiaoniu", "xiaohu", "xiaozhou")
	fmt.Println(laozhang)
	fmt.Println("laozhang导师的学生有:", laozhang["laozhang"])
	fmt.Println(laocheng)
	fmt.Println("laocheng导师的学生有:", laocheng["laocheng"])

}

```




## 11. 方法

### 11.1 方法的基本概述

- Go语言的方法是一种特殊类型的函数，它们与结构体或自定义类型关联，并允许在这些类型上执行操作
- Go方法与Go函数相似，但有一点不同，就是方法中包含一个接收者参数。在接收者参数的帮助下，该方法可以访问接收者的属性
- 接收方可以是结构体或自定义类型。在代码中创建方法时，接收者和接收者类型必须出现在同一个包中。而且不允许创建一个方法，其中的接收者类型已经在另一个包中定义，包括像int、string等内建类型
- 一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针.
- Golang 方法总是绑定对象实例，并隐式将实例作为第一实参 (receiver)
- 方法的概念：简单说就是一个对象里面的函数，称为方法
- 方法是面向对象编程的一部分，它们用于将行为（函数）与数据（结构体或自定义类型）封装在一起



- 函数和方法的区别:

  - **函数（Functions）**

    - **独立性**：

      - 函数是独立的代码块，不与任何特定类型相关联。

      - 函数可以在任何地方定义和调用，而不依赖于某个类型。

    - **参数**：

      - 函数可以接受零个或多个参数，这些参数不需要与某个类型关联。

      - 函数参数可以是任何类型，包括基本数据类型、结构体、接口等。

    - **调用方式**：

      - 函数通过函数名直接调用，不需要通过实例来调用。

      - 函数调用的语法是 `函数名(参数列表)`

  ```go
  func Add(a, b int) int {
      return a + b
  }
  
  result := Add(3, 5)
  ```

  - **方法（Methods）**

    - **关联类型**：
      - 方法是与特定类型关联的函数，它们定义在某个类型上。
      - 方法只能被与该类型关联的实例调用。

    - **参数**：

      - 方法的第一个参数是接收者（Receiver），指定了方法与哪种类型关联。

      - 方法可以有零个或多个其他参数，这些参数不需要与接收者的类型关联。

    - **调用方式**：

      - 方法只能通过该类型的实例来调用，通过实例的成员访问方法。

      - 方法调用的语法是 `实例名.方法名(参数列表)`

  ```go
  type Rectangle struct {
      width  float64
      height float64
  }
  
  // 方法，计算矩形面积
  func (r Rectangle) Area() float64 {
      return r.width * r.height
  }
  
  rect := Rectangle{width: 5.0, height: 3.0}
  area := rect.Area()
  
  ```

### 11.2 基本语法

- Go语言方法的定义包括以下几个部分：

  - 接收者（Receiver）：方法与一个类型关联，接收者是指定方法关联的类型。接收者可以是值接收者（Value Receiver）或指针接收者（Pointer Receiver）。

  - 方法名称：方法的名称是标识方法的唯一名称。

  - 参数列表：方法可以包含参数，就像普通函数一样。

  - 返回值：方法可以有返回值，就像普通函数一样
  - 参数和返回值可以省略。方法可以没有参数，也可以没有返回值

```go
func (receiver receiverType) funcName(parameters) (results)
		// 1. receiver 为任意名字。
		// 2. receiverType为调用者的类型。可以是T或者*T。注意T本身不能是接口或者指针。
		例如T=int，但是不能是*int。想要指针可以这样做：T=int后，单独加一个*。

// 代码解释：
// 1. 正确写法
type myint int
func (s *myint) Add() (r int)

// 2. 错误写法。因为T类型本身不能是指针。
type myintp *int
func (s myintp) Add() (r int)
```

### 11.3 方法的类型

- 方法可以分为两种主要种类：值接收者方法和指针接收者方法
- 接收者为值类型或指针类型，决定了调用方法时，方法对实例是值操作还是指针操作
  - 若接收者为值类型，那么无论用值还是指针调用该方法，方法操作的都是对象的副本。
  - 若接收者为指针类型，那么无论用值还是指针调用该方法，方法操作的都是对象的指针

#### 11.3.1 值接收者方法

- 值接收者方法使用值类型作为接收者。这意味着方法会在接收者的副本上操作，不会修改原始接收者
- 如果一个类型的方法使用值接收者，那么该类型的值和指针都可以调用该方法
- 适用于不需要修改接收者状态的方法
- 值接收者方法的一些特点和使用场景包括：
  - 方法的接收者是值类型，表示接收者的数据是不可更改的。
  - 适用于不需要修改接收者的情况，只需使用接收者的属性进行计算或操作。
  - 适用于值类型，如基本数据类型（int、float、string）或结构体（struct）

```go
package main

import (
	"fmt"
	"math"
)

type Circle struct {
	radius float64
}

func (c Circle) Area() float64 {
	return math.Pi * c.radius * c.radius
}

func main() {
	test_demo := Circle{
		radius: 4.0,
	}
	Area := test_demo.Area()
	fmt.Printf("半径为: %.2f", Area)
}
```

#### 11.3.2 指针接收者方法

- 指针接收者方法使用指针类型作为接收者。这意味着方法会在原始接收者上操作，可以修改接收者的状态。
- 如果一个类型的方法使用指针接收者，那么只有该类型的指针可以调用该方法
- 这种方法适用于需要修改接收者状态的情况。指针接收者方法的一些特点和使用场景包括：
  - 方法的接收者是指针类型，表示接收者的数据是可更改的。
  - 适用于需要修改接收者状态的情况，如修改结构体的属性。
  - 通常适用于大型数据结构，以避免复制大量数据

```go
package main

import "fmt"

type Rectangle struct {
	width  float64
	height float64
}

// 指针接收者方法，增加矩形的宽度
func (r *Rectangle) IncreaseWidth(delta float64) {
	r.width += delta
}

func main() {
	rect := Rectangle{width: 5.0, height: 3.0}

	// 使用指针接收者方法增加宽度
	rect.IncreaseWidth(2.0)
	fmt.Println("增加宽度后的矩形宽度:", rect.width)
}
```

#### 11.3.3 值接收者方法和指针接收者方法的区别

- 方法不过是一种特殊的函数，只需将其还原，就知道值接收者方法和指针接收者方法的区别了

```go
package main

import "fmt"

type Data struct {
	x int
}

func (self Data) ValueTest() { //接收者为值类型。相当于函数 func ValueTest(self Data);
	fmt.Printf("Value: %p\n", &self)
}

func (self *Data) PointerTest() { //接收者为指针类型。相当于函数 func PointerTest(self *Data);
	fmt.Printf("Pointer: %p\n", self)
}

func main() {
	d := Data{}
	p := &d
	fmt.Printf("Data: %p\n", p)

	//都是复制引用
	d.ValueTest() //值调用
	p.ValueTest() //指针调用

	//都是地址引用
	d.PointerTest() //值调用
	p.PointerTest() //指针调用
}

```

- 是值引用还是地址引用取决于 定义 方法时 **接收者的类型**。
  - 如果定义时，接收者是值类型，那么调用该方法时，操作的就是值的副本。
  - 如果定义时，接收者是指针类型，那么调用该方法时，操作的就是指针。
  - 与调用方法无关（与用实例的值还是指针来调用方法无关）



- 如何选择接收者类型:
  - 选择值接收者方法还是指针接收者方法取决于您的需求和设计决策。以下是一些有关方法选择的指导原则：
    - 如果方法不需要修改接收者的状态，或者接收者是一个小型的值类型（如基本数据类型或小型结构体），则可以使用值接收者方法。
    - 如果方法需要修改接收者的状态，或者接收者是一个大型的数据结构，可以考虑使用指针接收者方法，以避免复制大量数据。
    - 在某些情况下，可能需要同时定义值接收者方法和指针接收者方法，以根据需要提供不同的操作。
- 需要注意的是，如果使用值接收者方法来调用一个值类型的方法，Go 会自动为您创建一个接收者的副本，以保护原始接收者的数据。同样，如果您使用指针接收者方法来调用一个指针类型的方法，您会直接操作原始接收者。根据需要选择方法类型，并确保符合您的设计和需求

### 11.4 匿名字段和方法

- 匿名字段前面已经有所介绍[[#8.4.4 匿名字段]]
- 在 Go 语言中，可以通过匿名字段的方式继承一个类型的方法，但也可以在包含该匿名字段的结构体中重写或覆盖继承的方法。这使得您可以在外部类型中修改或定制继承的方法，以适应特定的需求

#### 11.4.1 方法继承

- 匿名字段不仅继承字段，还继承方法。
- 如果内部类型定义了方法，外部类型可以直接使用这些方法，不需要重新定义。

```go
package main

import "fmt"

type Parent struct {
    Name string
}

func (p *Parent) SayHello() {
    fmt.Println("Hello, I'm", p.Name)
}

type Child struct {
    Parent // 匿名字段
}

func main() {
    child := Child{Parent: Parent{Name: "Alice"}}
    child.SayHello() // 调用继承的方法
}

// Child 结构体嵌套了 Parent 结构体作为匿名字段。因此，Child 结构体可以调用 Parent 结构体定义的 SayHello() 方法
```

#### 11.4.2 方法重写

- 匿名字段允许在外部类型中重写内部类型的方法，实现方法的覆盖

```go
package main

import "fmt"

type Persion struct {
	name string
	sex byte
	age int
}

// Persion实现了一个方法
func (t *Persion) PrintInfo(){
	fmt.Printf("name=%s, byte=%c, age=%d\n", t.name, t.sex, t.age)
}

// 另一个结构体继承了该Persion，它会继承了所有成员及其方法
type Student struct {
	Persion // 匿名字段
	id int
	addr string
}

// Student也添加一个同名的方法PrintInfo
// 注意，因为接收者类型一个是 *Persion、一个是 *Student，它们是不一样的，所以函数名可以同样。
// 这样也叫方法的重写，即实现了多态。
func (t *Student) PrintInfo(){
	fmt.Println("stu = ", t)
}


func main(){

	s := Student{Persion{"hc", 'w', 24}, 1, "sz"}

	// 根据就近原则，调用的是Student.PrintInfo()
	s.PrintInfo()

	// 显示调用才能调用到Persion的PrintInfo()
	s.Persion.PrintInfo()
}

```

### 11.5 方法集

- 在 Go 语言中，每个类型都有一个方法集（method set），它定义了可以应用于该类型的方法集合。
- 方法集分为两种：值方法集（value method set）和指针方法集（pointer method set）。这些方法集决定了哪些方法可以调用，取决于方法的接收者类型（值类型或指针类型）



- 每个类型都有与之关联的方法集，这会影响到接口实现规则:
  - 类型 T 的方法集包含全部 receiver T 方法。
  - 类型 *T 的方法集包含全部 receiver T + *T 方法。
  - 如类型 S 包含匿名字段 T，则 S 和 *S 的方法集包含 T 方法。
  - 如类型 S 包含匿名字段 *T，则 S 和 *S 的方法集包含 T + *T 方法。不管嵌入 T 或` *T`，`*S `的方法集总是包含 T + *T 方法
- 如果接收者是值类型 T ，那么方法对接受者就是值操作。所以 **值类型 T 的方法集** 包含的是所有接受者为值类型 T 的方法。
- 如果接收者是指针类型 *T ，那么方法对接受者就是指针操作。所以 **指针类型 \*T 的方法集**包含的是所有接受者为值类型 T 和 指针类型 *T 的方法

#### 11.5.1 值方法集

- 类型 T 的方法集包含全部 receiver T 方法

```go
package main

import (
	"fmt"
)

type T struct {
	int
}

func (t T) test() {
	fmt.Println("类型 T 方法集包含全部 receiver T 方法。")
}

func main() {
	t1 := T{1}
	fmt.Printf("t1 is : %v\n", t1)
	t1.test()
}

```

- 如类型 S 包含匿名字段 T，则 S 和 *S 的方法集包含 T 方法。

```go
// 给定一个结构体类型 S 和一个命名为 T 的类型，方法提升像下面规定的这样被包含在结构体方法集中：如类型 S 包含 匿名字段 T，则 S 和 *S 方法集包含 T 方法
// 当类型 S 包含 匿名字段 T时，类型为 S 和 *S 的变量可以调用所有接收者为 T 的方法

package main

import (
	"fmt"
)

type S struct {
	T
}

type T struct {
	int
}

func (t T) testT() {
	fmt.Println("如类型 S 包含匿名字段 T，则 S 和 *S 方法集包含 T 方法。")
}

func main() {
	s1 := S{T{1}}
	s2 := &s1
	fmt.Printf("s1 is : %v\n", s1)
	s1.testT()   //S方法集包含T方法
	fmt.Printf("s2 is : %v\n", s2)
	s2.testT()   //*S方法集包含T方法
}


```

#### 11.5.2 指针方法集

- 类型 *T 的方法集包含全部 receiver T + *T 方法。

```go
// 类型为 *T 的变量可以调用所有接收者为 T 或 *T 的方法
package main

import (
	"fmt"
)

type T struct {
	int
}

func (t T) testT() {
	fmt.Println("类型 *T 方法集包含全部 receiver T 方法。")
}

func (t *T) testP() {
	fmt.Println("类型 *T 方法集包含全部 receiver *T 方法。")
}

func main() {
	t1 := T{1}
	t2 := &t1
	fmt.Printf("t2 is : %v\n", t2)
	t2.testT()
	t2.testP()
}
```

- 如类型 S 包含匿名字段 *T，则 S 和 *S 的方法集包含 T + *T 方法。不管嵌入 T 或` *T`，`*S `的方法集总是包含 T + *T 方法

```go
// 当类型 S 包含 匿名字段 *T 时，类型为 S 和 *S 的变量可以调用所有接收者为 T 和 *T 的方法

package main

import (
	"fmt"
)

type S struct {
	T
}

type T struct {
	int
}

func (t T) testT() {
	fmt.Println("如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 T 方法")
}
func (t *T) testP() {
	fmt.Println("如类型 S 包含匿名字段 *T，则 S 和 *S 方法集包含 *T 方法")
}

func main() {
	s1 := S{T{1}}
	s2 := &s1
	fmt.Printf("s1 is : %v\n", s1)
	s1.testT() //S方法集包含T方法
	s1.testP() //S方法集包含*T方法
	fmt.Printf("s2 is : %v\n", s2)
	s2.testT() //*S方法集包含T方法
	s2.testP() //*S方法集包含*T方法
}
```

#### 11.5.2 方法调用

- 在 Go 中，方法的调用是通过类型来确定的，具体规则如下：

  - 如果一个值（非指针）具有该类型，则可以调用该类型的所有值方法和指针方法。

  - 如果一个指针具有该类型，则可以调用该类型的所有指针方法，以及该类型的值方法（Go 会自动将指针解引用为值）

```go
package main

import "fmt"

type MyType struct {
    value int
}

func (m MyType) ValueMethod() {
    fmt.Println("ValueMethod called with value:", m.value)
}

func (m *MyType) PointerMethod() {
    fmt.Println("PointerMethod called with pointer:", m.value)
}

func main() {
    val := MyType{value: 42}
    ptr := &MyType{value: 99}

    // 值方法集：可以调用 ValueMethod
    val.ValueMethod()
    ptr.ValueMethod() // 会自动解引用指针

    // 指针方法集：可以调用 PointerMethod
    ptr.PointerMethod()

    // 也可以通过指针调用值方法
    ptr2 := &MyType{value: 123}
    ptr2.ValueMethod()
}

// MyType 类型定义了一个值方法 ValueMethod 和一个指针方法 PointerMethod。我们可以看到，值方法可以通过值和指针调用，而指针方法只能通过指针调用。此外，Go 会自动将指针解引用为值来调用值方法
```

### 11.6 方法值和方法表达式

- 方法值允许您将方法存储在变量中并稍后调用，而方法表达式允许您将方法作为函数传递并操作

#### 11.6.1 方法值

- 方法值是将方法绑定到特定接收者实例上的函数值。通过方法值，您可以在不立即调用方法的情况下引用方法。方法值可以存储在变量中，稍后再进行调用。方法值的语法是 `接收者实例.方法名`
- 方法值隐式调用，通过隐式保存接收者来进行调用

```go
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func (r Rectangle) Area() float64 {
    return r.width * r.height
}

func main() {
    rect := Rectangle{width: 5.0, height: 3.0}

    // 创建方法值并隐式调用
    areaFunc := rect.Area

    // 隐式调用方法值
    area := areaFunc()
    fmt.Println("矩形面积:", area)
}


// areaFunc 是一个方法值，它存储了 rect.Area 方法。稍后，我们可以通过 areaFunc() 调用这个方法
```

#### 11.6.2 方法表达式

- 方法表达式是一种特殊的函数，它是通过类型名称和方法名称来引用方法的。方法表达式的语法是 `Type.Method`，其中 `Type` 是类型名称，`Method` 是方法名称。方法表达式返回一个函数，可以将接收者实例作为参数传递给该函数。
- 这种方式允许您将方法作为参数传递给其他函数或方法
- 方法表达式：显示调用，不会隐式保存接收者，调用时需要显示传实例给对应的接收者类型
- 方法表达式的主要用途是允许将方法作为参数传递给其他函数，例如高阶函数、排序函数等

```go
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func (r Rectangle) Area() float64 {
    return r.width * r.height
}

func main() {
    rect := Rectangle{width: 5.0, height: 3.0}

    // 创建方法表达式
    areaFunc := Rectangle.Area

    // 调用方法表达式，并传递接收者实例
    area := areaFunc(rect)
    fmt.Println("矩形面积:", area)
}

// areaFunc 是一个方法表达式，它存储了 Rectangle.Area 方法。然后，我们通过 areaFunc(rect) 调用这个方法表达式，将 rect 作为接收者传递给它
```

### 11.7 将方法还原成函数

- 值方法转化为函数：
  - 如果有一个值方法，可以创建一个函数，该函数接受一个参数，该参数就是方法的接收者。在函数内部，您可以手动调用该方法

```go
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func (r Rectangle) Area() float64 {
    return r.width * r.height
}

// 方法转化为函数
func CalculateArea(r Rectangle) float64 {
    return r.Area()
}

func main() {
    rect := Rectangle{width: 5.0, height: 3.0}

    // 调用转化后的函数
    area := CalculateArea(rect)
    fmt.Println("矩形面积:", area)
}

```

- 指针方法转化为函数：
  - 如果您有一个指针方法，您可以创建一个函数，该函数接受一个参数，该参数是方法的接收者指针。在函数内部，您可以手动调用该方法

```go
package main

import "fmt"

type Rectangle struct {
    width  float64
    height float64
}

func (r *Rectangle) Area() float64 {
    return r.width * r.height
}

// 方法转化为函数
func CalculateArea(r *Rectangle) float64 {
    return r.Area()
}

func main() {
    rect := &Rectangle{width: 5.0, height: 3.0}

    // 调用转化后的函数
    area := CalculateArea(rect)
    fmt.Println("矩形面积:", area)
}

```

## 12. 接口

- 在Go语言中接口（interface）是一种类型，一种抽象的类型
- Go语言中提供了一种类型叫做接口类型,它定义了一组方法的签名，但不包含具体的实现。接口是一种抽象类型，它并没有暴露所含数据的布局或内部结构，当然也没有哪些数据的基本操作，它所提供的仅仅是一些方法而已。如果你拿到一个接口类型的值，你无从知道它是什么，你能知道的仅仅是它能做什么，也就是说，仅仅能知道它提供了哪些方法
- interface是`一组method的集合`，是 鸭子类型 、多态性（其实go并没有面向对象） 的一种体现。也就是常说的只要带毛的，我都认为你是鸭子
- 接口是实现多态性的关键，允许不同类型的对象实现相同的接口，从而实现通用的代码

### 12.1 接口定义

- 接口由方法签名组成，方法签名是方法的名称、参数列表和返回值列表，但没有实际的方法体。接口的定义使用 `type` 关键字，然后跟着 `interface` 关键字、接口名以及方法签名的列表

```go
type 接口类型名 interface{
    方法名1(参数列表1) 返回值列表1
    方法名2(参数列表2) 返回值列表2
}

// 接口名：使用type将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等。接口名最好要能突出该接口的类型含义。
// 方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。
// 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略

```

![image-20231007225847188](https://cloud.006288.xyz/PicGo//image-20231007225847188.png)

- 接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法。接口体现了程序设计的多态和高内聚低偶合的思想。
- Golang 中的接口，不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。因此，Golang 中没有 implement 这样的关键字

### 12.2 接口实现

- 任何类型只要实现了接口中定义的所有方法，就被认为是实现了该接口。Go 语言的接口实现是隐式的，无需显式声明实现
- 一个接口可以被多个类型实现，一个类型也可以实现多个接口

```go
package main

import "fmt"

// 定义一个接口 Phone，它包含了三个方法：Call()、Game() 和 Video()
type Phone interface {
	Call()
	Game()
	Video()
}

// 定义 Electronics 结构体
type Electronics struct {
	name string
}

// 实现 Phone 接口的 Call() 方法
func (func_1 Electronics) Call() {
	fmt.Println("打电话功能")
}

// 实现 Phone 接口的 Game() 方法
func (func_2 Electronics) Game() {
	fmt.Println("打游戏功能")
}

// 实现 Phone 接口的 Video() 方法
func (func_3 Electronics) Video() {
	fmt.Println("刷视频功能")
}
```

### 12.3 接口类型变量和接口使用

- 在Go语言中，接口类型的变量可以保存任何实现了接口的具体类型的值。这种特性使得代码更加灵活，可以处理不同类型的对象
- Go 语言中的接口是隐式实现的，不需要显式地声明一个类型实现了某个接口，只要类型包含了接口中定义的所有方法，它就被认为是实现了该接口

```go
package main

import "fmt"

// 定义一个接口 Phone，它包含了三个方法：Call()、Game() 和 Video()
type Phone interface {
	Call()
	Game()
	Video()
}

// 定义 Electronics 结构体
type Electronics struct {
	name string
}

// 实现 Phone 接口的 Call() 方法
func (func_1 Electronics) Call() {
	fmt.Println("打电话功能")
}

// 实现 Phone 接口的 Game() 方法
func (func_2 Electronics) Game() {
	fmt.Println("打游戏功能")
}

// 实现 Phone 接口的 Video() 方法
func (func_3 Electronics) Video() {
	fmt.Println("刷视频功能")
}

func main() {
	// 创建一个实现了 Phone 接口的 Electronics 实例
	iphone := Electronics{
		name: "iphone",
	}

	// 调用接口的方法
	iphone.Call()
	iphone.Game()
	iphone.Video()

}

// Electronics 结构体实现了 Phone 接口的所有方法
// 创建了一个 Electronics 类型的实例 electronics 并将其分配给 Phone 接口类型的变量 iphone
// 然后就可以通过 iphone 调用 Phone 接口中定义的方法
```

### 12.4 空接口interface{}

#### 12.4.1 空接口的定义

- `interface{}` 表示空接口，也被称为空白接口或者空接口类型。这个接口没有任何方法，因此它可以表示任何类型的值。在Go语言中，空接口非常灵活，可以用来存储任意类型的值

- 空接口定义

```go
var any interface{}

// 定义了一个空接口变量 any，它可以存储任何类型的值
```

#### 12.4.2 空接口应用场景

##### 12.4.2.1 存储任意类型的数据

- 当需要一个变量可以存储各种类型的数据时，可以使用空接口。这样就可以创建一个通用的数据容器

```go
var data interface{}
data = 42
data = "hello"
data = []int{1, 2, 3}
```

##### 12.4.2.2 空接口作为函数参数或返回值

- 当定义一个函数，需要接受或返回任意类型的值时，可以使用空接口作为函数的参数或返回值类型：

```go
func printData(data interface{}) {
    fmt.Println(data)
}

func getData() interface{} {
    return "hello"
}
```

##### 12.4.2.3 空接口作为map的值

- 使用空接口实现可以保存任意值的字典

```go
// 空接口作为map值
	var studentInfo = make(map[string]interface{})
	studentInfo["name"] = "沙河娜扎"
	studentInfo["age"] = 18
	studentInfo["married"] = false
```

##### 12.4.2.4 处理未知数据

- 当不知道一个值的具体类型，但需要对它进行某种操作时，可以使用空接口来接受该值，然后根据需要进行类型断言

```go
func processUnknownType(value interface{}) {
    switch v := value.(type) {
    case int:
        fmt.Println("这是一个整数:", v)
    case string:
        fmt.Println("这是一个字符串:", v)
    default:
        fmt.Println("未知类型")
    }
}
```

### 12.5 接口断言

- 在Go语言中，接口断言（interface assertion）是一种操作，用于确定一个接口值是否实现了特定的接口类型，并将接口值转换为该特定接口类型的值
- 类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配
  - 如果断言的类型T是一个**具体类型**，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic
  - 如果相反地断言的类型T是一个**接口类型**，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分
    

- 理解: 
  - go语言空接口interface{}可以保存任何类型的变量，当程序中需要使用该变量的时候，需要把接口类型变量的值转化为
            具体类型，可以通过接口类型断言。
  - 假如接口类型保存的值是数字，当前的值要参与数学运算，就必须t类型才可以参加运算，这就是利用接口断言来实现类型转换的例子。


```go
// x.(T), x必然是一个接口，接口有3个属性
    接口动态类型
    接口的动态值
    接口的方法集合

//具体类型的属性
    类型
    存储的对应类型的值
    方法(可能没有方法，和类型共同决定满足哪些接口)


T取值:
T可以是具体的类型，判断是否x是否是这个类型，如果是，则类型断言的结果是x的动态值(接口的属性)，它的类型是T(具体类型的属性)
如果T是接口类型，则类型断言结果的接口的类型和接口动态值还是不变，值变化接口的方法集合（通过更大）

```

- **基本语法**
- 写法一

```go
// 直接断言
t := i.(T)  

// 这个表达式可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回值给 t，如果断言失败，就会触发 panic


// 示例
package main

import "fmt"

func main() {
    var i interface{} = 10
    t1 := i.(int)
    fmt.Println(t1)

    fmt.Println("=====分隔线=====")

    t2 := i.(string)
    fmt.Println(t2)
}
```

- 写法二

```go
t, ok:= i.(T)
i
//	i 是接口类型的变量。
//	T 是你想要检查的具体类型。
//	t 是转换后的具体类型的值。
//	ok 是一个布尔值，指示接口值是否包含了指定的具体类型。如果 ok 为 true，表示断言成功；如果为 false，表示断言失败

// 这个表达式也是可以断言一个接口对象（i）里不是 nil，并且接口对象（i）存储的值的类型是 T，如果断言成功，就会返回其类型给 t，并且此时 ok 的值 为 true，表示断言成功。
// 如果接口值的类型，并不是我们所断言的 T，就会断言失败，但和第一种表达式不同的事，这个不会触发 panic，而是将 ok 的值设为 false ，表示断言失败，此时t 为 T 的零值


// 示例
var i interface{} = 42

// 类型断言
if v, ok := i.(int); ok {
    fmt.Println("i 是一个整数:", v)
} else {
    fmt.Println("i 不是一个整数")
}
```

- 写法三
  - 如果需要区分多种类型，可以使用 type switch 断言

```go
package main

import "fmt"

func findType(i interface{}) {
    switch x := i.(type) {
    case int:
        fmt.Println(x, "is int")
    case string:
        fmt.Println(x, "is string")
    case nil:
        fmt.Println(x, "is nil")
    default:
        fmt.Println(x, "not type matched")
    }
}

func main() {
    findType(10)      // int
    findType("hello") // string

    var k interface{} // nil
    findType(k)

    findType(10.23) //float64
}
```

### 12.6 接口嵌套

- 在Go语言中，接口可以嵌套在其他接口中，从而创建新的接口。**嵌套接口的所有方法都必须被实现**。这种方式可以用于组织和构建更复杂的接口，同时保持代码的可读性和可维护性

```go
package main

import "fmt"

// Reader 接口定义了 Read 方法
type Reader interface {
	Read() string
}

// Writer 接口定义了 Write 方法
type Writer interface {
	Write(data string)
}

// ReadWriter 接口嵌套了 Reader 和 Writer 接口
type ReadWriter interface {
	Reader
	Writer
}

// FileReader 类型实现了 Reader 接口
type FileReader struct {
	content string
}

func (f FileReader) Read() string {
	return f.content
}

// 实现了 Writer 接口
func (f FileReader) Write(data string) {
	fmt.Println("Writing to file:", data)
}

// ConsoleWriter 类型实现了 Writer 接口
type ConsoleWriter struct{}

func (c ConsoleWriter) Write(data string) {
	fmt.Println("Writing to console:", data)
}

// 实现了 Reader 接口
func (c ConsoleWriter) Read() string {
	return "Reading from console"
}

func main() {
	// 创建一个 ReadWriter 接口类型的变量
	var rw ReadWriter

	// 使用 FileReader 实例来初始化 rw 变量
	rw = FileReader{content: "File content"}

	// 调用 Read 方法
	content := rw.Read()
	fmt.Println("Read content:", content)

	// 调用 Write 方法
	rw.Write("Hello, World!")

	// 使用 ConsoleWriter 实例来初始化 rw 变量
	rw = ConsoleWriter{}

	// 调用 Read 和 Write 方法
	content = rw.Read()
	fmt.Println("Read content:", content)
	rw.Write("Hello, World!")
}

```

### 12.7 匿名接口

- 在Go语言中，可以创建匿名接口，也就是没有明确指定接口名称的接口。匿名接口的定义不包含接口的名称，只包含接口的方法签名,  匿名接口通常用于临时或一次性的场景，不需要为接口定义一个具体的名称。匿名接口的语法非常简洁，可以在需要的地方直接定义接口的方法和要求的行为

```go
package main

import "fmt"

type Person struct {
	Name string
}

func (p Person) Speak() string {
	return "Hello, my name is " + p.Name
}

func main() {
	// 定义一个匿名接口，并将具体类型赋值给匿名接口变量
	var speaker interface {
		Speak() string
	} = Person{Name: "Alice"}

	// 调用匿名接口的方法
	result := speaker.(Person).Speak()
	fmt.Println(result) // 输出: Hello, my name is Alice
}
```

### 12.5 接口练习

- 使用接口定义一个支付接口

```go
package main

import "fmt"

type payerr struct {
	username string
}

func (payerr *payerr) Error() string {
	return fmt.Sprintf("%s用户,您的账户余额不足,支付失败!\n", payerr.username)

}

type Paymenter interface {
	Pay(float64) (string, error)
}

type UserInfo struct {
	username string
	balance  float64
	price    float64
}

type AliPay struct {
	UserInfo
}

func (aipay *AliPay) Pay() (string, error) {
	if aipay.balance < aipay.price {
		return "", &payerr{aipay.username}
	} else {
		aipay.balance = aipay.balance - aipay.price
		return fmt.Sprintf("%s用户使用alipay付款成功,一共支付%.2f, 余额剩余: %.2f \n", aipay.username, aipay.price, aipay.balance), nil
	}
}

type WxPay struct {
	UserInfo
}

func (wxpay *WxPay) Pay() (string, error) {
	if wxpay.balance < wxpay.price {
		return "", &payerr{wxpay.username}
	} else {
		wxpay.balance = wxpay.balance - wxpay.price
		return fmt.Sprintf("%s用户使用wxpay付款成功,一共支付%.2f, 余额剩余: %.2f \n", wxpay.username, wxpay.price, wxpay.balance), nil
	}
}

type PayPal struct {
	UserInfo
}

func (paypal *PayPal) Pay() (string, error) {
	if paypal.balance < paypal.price {
		return "", &payerr{paypal.username}
	} else {
		paypal.balance = paypal.balance - paypal.price
		return fmt.Sprintf("%s用户使用paypal付款成功,一共支付%.2f, 余额剩余: %.2f \n", paypal.username, paypal.price, paypal.balance), nil
	}
}

func main() {
	username := "kubei"
	balance := 288.6
	price := 38.8
	paytype := "paypal"

	switch paytype {
	case "alipay":
		alipay := AliPay{UserInfo{username: username, balance: balance, price: price}}
		message, err := alipay.Pay()
		if err != nil {
			fmt.Println(err)
		} else {
			fmt.Println(message)
		}
	case "wxpay":
		wxpay := WxPay{UserInfo{username: username, balance: balance, price: price}}
		message, err := wxpay.Pay()
		if err != nil {
			fmt.Println(err)
		} else {
			fmt.Println(message)
		}
	case "paypal":
		paypal := PayPal{UserInfo{username: username, balance: balance, price: price}}
		message, err := paypal.Pay()
		if err != nil {
			fmt.Println(err)
		} else {
			fmt.Println(message)
		}
	default:
		fmt.Println("其他支付方式正在开发,请尽情等待...!")
	}
}

```

- 优化上面代码

```go
package main

import "fmt"

type Payerr struct {
	username string
}

func (pe *Payerr) Error() string {
	return fmt.Sprintf("%s用户账户余额不足,支付失败!", pe.username)
}

type PayInterface interface {
	Pay() (string, error)
}

type UserInfo struct {
	username string
	balance  float64
	price    float64
}

func (user *UserInfo) MakePayment(paytype string) (string, error) {
	if user.balance < user.price {
		return "", &Payerr{user.username}
	} else {
		user.balance -= user.price
		return fmt.Sprintf("%s用户使用%s付款成功, 一共支付%.2f,余额剩余%.2f \n", user.username, paytype, user.price, user.balance), nil
	}
}

type AliPay struct {
	*UserInfo
}

func (ali *AliPay) Pay() (string, error) {
	return ali.MakePayment("AliPay")
}

type WxPay struct {
	*UserInfo
}

func (wx *WxPay) Pay() (string, error) {
	return wx.MakePayment("WxPay")

}

type PayPal struct {
	*UserInfo
}

func (pp *PayPal) Pay() (string, error) {
	return pp.MakePayment("PayPal")

}

func main() {
	username := "kubei"
	balance := 23.9
	price := 88.9
	paytype := "PayPal"

	user := UserInfo{username: username, balance: balance, price: price}
	var paymenter PayInterface

	switch paytype {
	case "AliPay":
        // 使用 &users因为 AliPay 中嵌套的是指向 UserInfo 的指针，而不是 UserInfo 本身
		paymenter = &AliPay{&user}
	case "WxPay":
		paymenter = &WxPay{&user}
	case "PayPal":
		paymenter = &PayPal{&user}
	default:
		fmt.Println("其他支付方式正在开发,请尽情等待...!")
	}

	message, err := paymenter.Pay()
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Println(message)
	}
}

```



## 13. 包(package)和包管理工具(go modules)

### 13.1 包

- 包是函数和数据的集合，将有相关特性的函数和数据放在统一的文件/目录进行管理，每个 包都可以作为独立的单元维护并提供给其他项目进行使用
- **包的概念**：
  - 包是一组相关的Go代码文件的集合，它们通常被组织在同一个目录下。
  - 包中的代码可以包含变量、函数、结构体、接口等。
  - 包的名称通常与包所在的目录的名称相同。
  - 包可以是标准库中的一部分，也可以是您自己创建的
- 包的三大作用:
  - 区分相同名字的函数、变量等标识符 
  - 当程序文件很多时,可以很好的管理项目 
  - 控制函数、变量等访问范围，即作用域

#### 13.1.1 包命名和声明

- **包命名**

  - 给包命名的惯例是使用包所在目录的名字。这让用户在导入包的时候，就能清晰地知道包名。

  - 尽量使用简介明了的名字，但要避免冲突

  - 包名一般使用单数的形式，但是避免冲突的用的复数比如bytes，errors，strings等

  - 要避免包名有其他含义。比如 temp这种

  - 命名时考虑包名和成员如何配合，尽量减少包名和成员有重复

- **包声明**

  - go 的每一个文件都是属于一个包的，也就是说 go 是以包的形式来管理文件和项目目录结构的

  - Go 源文件都需要在开头使用 package 声明所在包，包名告知编译器哪些是包的源代码用于 编译库文件

  - 其次包名用于限制包内成员对外的可见性，包名也用于在包外对公开成员的 访问 包名使用简短的小写字母，常与所在目录名保持一致，一个包中可以由多个 Go 源文件，但必须使用相同包名

  - 在给一个文件打包时，该包对应一个文件夹，比如这里的 utils 文件夹对应的包名就是utils, 文件的包名通常和文件所在的文件夹名一致，一般为小写字母

  - 每个包都在一个单独的目录里。不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。这意味着，同一个目录下的所有.go 文件必须声明同一个包名

![image-20230921233007991](https://cloud.006288.xyz/PicGo//image-20230921233007991.png)

- **main包**
  - 所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。 go语言的编译器会将这种名字的包编译为二进制可执行文件。
  - main包下肯定会有名为main()的函数，main()是程序的入口。
  - 编译完会使用声明 main 包的代码所在的目录的目录名作为二进制可执行文件的文件名

#### 13.1.2 导包

- 当一个文件要使用其它包函数或变量时，需要先引入对应的包
- 可通过 import 每行导入一个包，也可使用括号包含所有包并使用一个 import 导入
- package 指令在 文件第一行，然后是 import 指令
- 在 import 包时，路径从 $GOPATH 的 src 下开始，不用带 src , 编译器会自动从src 下开始引入
- 导入方式

```go
// 引入方式 1：
import "包名" 

//引入方式 2：
import ( 
    "包名"
	"包名"
)
```

- 导入形式

```go
// 标准库包导入
import "fmt"

// 绝对路径导入
import "github.com/example/mypackage"

// 相对路径导入
import "./mypackage"

// 点导入 (导入包后，可以直接使用包中的函数、变量和类型，而不需要通过包名来访问)
import . "mypackage"

// 自定义别名导入
import fm "fmt"


// 空白标识符导入(下划线导入) :(如果导入了一个包但没有在代码中直接使用它，可以使用下划线（空白标识符）来导入，以避免编译器报错。这通常用于执行包的初始化函数)
import _ "mypackage"
```

#### 13.1.3 包文档

- 在Go语言中，包文档是一种重要的文档形式，用于为代码包提供说明和文档。包文档的目的是帮助其他开发人员理解和正确使用包中的功能

- [go语言标准库文档](https://studygolang.com/pkgdoc)

- **包文档的惯例**
  - 包注释
    - 包文档通常以包注释的形式开始，位于包声明之前。包注释是包的概要描述，应该清晰地解释包的目的和功能。
    - 包注释通常以多行注释（`/* ... */`）的形式编写
  
  ```go
  /*
   Package mypackage provides functionality for ...
  */
  package mypackage
  ```
  
  - 标识符可见性
    - 在包中，标识符的可见性由其首字母的大小写来决定。如果标识符以大写字母开头，它将在包外部可见，可以被其他包导入和使用。
    - 包文档应该清楚地指出哪些标识符是包外可见的，以及它们的用途
  - 文档示例函数
    - 包文档通常包含示例代码，以展示如何正确使用包中的功能。
    - 示例代码有助于其他开发人员更容易理解如何使用包
    - 不能声明main包
    - 文件必须以_test.go 结尾
    - 示例代码必须单独放在一个文件中，比如example_test.go，尽量见名知意的命名
  - 文档工具
    - `godoc`命令可以生成本地文档，`go doc`可以查看单个包的信息。比如; `go doc fmt` 可以在命令行查看fmt信息，还可以查看单个函数 `go doc fmt.Println` 
    - 生成本地浏览器站点在线查看 `godoc -http=:8080` 然后打开浏览器输入`localhost:8080`就能看到 (需要设置了自己的`GOPATH`和`GOROOT` ,它会查找这两个路径下的代码生成文档。可以看到有标准库的所有包、文档注释、示例、还有自己写的代码)
      - 查看单个包文档
      ![image-20230922231543564](https://cloud.006288.xyz/PicGo//image-20230922231543564.png)
      - 使用浏览器查看包文档
  
  ```go
  // 使用godoc生成本地离线包文档
  
  // 安装godoc
  go install golang.org/x/tools/cmd/godoc@latest
  
  // 浏览器访问
  godoc -http=:8888
  ```
  
  ![image-20230922232959930](https://cloud.006288.xyz/PicGo//image-20230922232959930.png)

### 13.2 包管理工具

- 除了go工具链自带的工具比如，`go build` 、`go vet` 、`go get` 、 `go doc` 等等，还有包依赖管理工具。比如 `dep`等等，go 1.11 1.12 还添加了 `go modules`

#### 13.2.1 依赖管理

- **两个概念：GOROOT 和GOPATH**

  - GOROOT: 系统环境变量，就是存放下载的go语言源码的地方（go的源码，不是我们写的）。

  - GOPATH: 环境变量，工作空间,包括bin、pkg、src。是存放我们写的代码以及下载的第三方代码
- **内部依赖：**

  - GOPATH和GOROOT，GOROOT并不是必须要设置的，但是GOPATH必须要设置，但并不是固定不变的。本项目内部依赖就会在GOPATH 所配置的路径下去寻找，编译器如果找不到会报错。总的来说内部依赖不需要太操心
- **外部依赖包：**

  - 当我们要实现一些功能的时候，不可避免的需要一些第三方包，也统称为外部依赖包。go1.5之前只支持使用GOPATH来管理外部依赖包的，对比java的maven 和gradle等 简直不太方便
- **包搜索顺序**: 

```go
在当前包下的 vendor 目录查找 
向上级目录查找，直到 GOPATH/src/vendor 目录
在 GOPATH 目录查找 
在 GOROOT 目录查找
```



- **使用GOPATH来管理外部依赖go1.5release之前:**

  - go允许import不同代码库的代码，例如github.com, k8s.io, golang.org等等；对于需要import的代码，可以使用 go get 命令取下来放到GOPATH对应的目录中去。例如go get github.com/silenceshell/hcache，会下载到$GOPATH/src/github.com/silenceshell/hcache中去，当其他项目在import github.com/silenceshell/hcache的时候也就能找到对应的代码了。
  - 对于go来说，其实并不care你的代码是内部还是外部的，总之都在GOPATH里，任何import包的路径都是从GOPATH开始的；唯一的区别，就是内部依赖的包是开发者自己写的，外部依赖的包是go get下来的。

- **Vendor 机制引入**

  - 在go1.5release之前，我们要管理多个依赖包版本时，只能通过设置多个`GOPATH`，拷贝代码来解决。比如，如果两个工程都依赖了Beego,一个1.5，一个1.8，那么必须设置俩GOPATH，并且还要记得切换

  - go语言原生包缺陷：

    - 能拉取源码的平台很有限，绝大多数依赖的是 github.com

    - 不能区分版本，以至于令开发者以最后一项包名作为版本划分

    - 依赖 列表/关系 无法持久化到本地，需要找出所有依赖包然后一个个 go get

    - 只能依赖本地全局仓库（GOPATH/GOROOT），无法将库放置于局部仓库（$PROJECT_HOME/vendor）

  - 2015年，官方引入了除了`GOPATH`之外的方式，`vendor`机制来进行管理。 这个vendor属性(默认关闭，需要设置go环境变量GO15VENDOREXPERIMENT=1)，但在1.6版本中默认开启。Go 1.7将此设置设置为标准特性，并删除了对该标志的支持

- **vendor是什么**

  - 简单说，就是在项目中多了一个vendor文件夹，go会把它默认作为GOPATH。让go编译时，优先从项目源码树根目录下的vendor目录查找代码(可以理解为切了一次GOPATH)，如果vendor中有，则不再去GOPATH中去查找

  

  - vendor存在的问题
    - 嵌套的vendor目录问题：vendor目录下面的项目里面的vendor目录怎么办？
    - vendor机制本身没有版本概念，不同版本间类型不兼容问题依旧存在。
    - 与其他 GOPATH 下的包init函数冲突问题：出现了相同的包，重复的init() 函数

  - 目前go vendor 模式的依赖工具有很多，如：`dep`(官方)、`Godep`、`Govendor`等等



- **go vender 之 dep**
  - [dep官网](https://golang.github.io/dep/)
  - [dep相关操作](https://blog.csdn.net/aixiaoyang168/article/details/83142915)

#### 13.2.2 Go Modules 模式

- Go Modules 是 Go 语言官方引入的一种依赖管理方式，用于管理和版本控制 Go 项目的依赖项。Go Modules 提供了更可靠和灵活的方式来管理和构建 Go 项目，它解决了早期依赖管理方式的一些问题
- 发布于 Go1.11(2018-08-24)，成长于 Go1.12，丰富于 Go1.13，正式于 Go1.14，推荐在生产上使用，Go 官方也鼓励所有用户从其他依赖项管理工具迁移到 Go modules
- Go moudles 目前集成在 Go 的工具链中，只要安装了 Go，自然而然也就可以使用 Go moudles。
- 利用Go 的 module 特性，你再也不需要关心传统的GOPATH了（当然GOPATH变量还是要存在的，但只需要指定一个目录），你可以任性的在硬盘任何位置新建一个Golang项目

##### 13.2.2.1 go mod基本操作

- 设置环境变量开启modules

```go
// 从 v1.11 开始，go env多了个环境变量：GO111MODULE，这里的 111其实就是 v1.11 的象征标志，

// GO111MODULE 是一个开关，通过它可以开启或关闭 go mod 模式。
        // 它有三个可选值：off、on、auto，默认值是auto。使用go env -w GO111MODULE="on" 设置

        1、GO111MODULE=off 禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。

        2、GO111MODULE=on 启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。

        3、GO111MODULE=auto，当构建源代码不在 GOPATH/src 的子目录且包含go.mod 文件，则使用 Go modules 机制，否则使用 GOPATH 和 vendor 机制
```

- 初始化工程

```go
// 在对应的工程目录中打开终端执行命令： go mod init  demoProject
看到提示 “go: creating new go.mod: module demoProject”， 说明 go mod 初始化成功了，会在项目根目录下生个文件 go.mod
// 包含go.mod文件的目录也被称为模块根，也就是说: go.mod 文件的出现定义了它所在的目录为一个模块

// go.mod示例

//置顶-代表go模块名，也即被其它模块引用的名称，位于文件第一行
module golang.****-corp.com/demo
 
//go版本
go 1.21
 
//最小需求列表(依赖模块及其版本信息)
require (
    // 对应依赖项目 项目版本号
    github.com/spf13/cobra v1.3.0
    golang.***-corp.com/finance/abcdef-common v0.0.0-20220223084623-8638e88c999e
)
 
// 用于从使用中排除一个特定的模块版本
exclude example.com/banana v1.2.4
 
//用于将一个模块版本替换为另外一个模块版本
replace example.com/apple v0.1.2 => example.com/fried v0.1.0
replace example.com/banana => example.com/fish
```

- 引入依赖

```go
// 在我们代码中，可以使用 import 语句导入所需的依赖。第一次导入依赖时，Go Modules 会自动下载并保存它们，以及它们的版本信息到 go.mod 文件中

// 项目引用了其他依赖后，执行 go mod download 手动下载所有的依赖到本地，或 go mod tidy 整理依赖完善 go.mod 文件并下载至本地，会生成 go.sum文件

//go.sum 式例 

//记录每个依赖库的版本和哈希值
github.com/spf13/cobra v1.3.0 h1:R7cSvGu+Vv+qX0gW5R/85dx2kmmJT5z5NM8ifdYjdn0=
github.com/spf13/cobra v1.3.0/go.mod h1:BrRVncBjOJa/eUcVVm9CE+oC6as8k+VYr4NY7WCi9V4=
golang.****-corp.com/finance/abcd-common v0.0.0-20220223084623-8638e88c999e h1:OvrVPaCLGUeMgY+Uzo6uLbOF5NIdKBsTDisnkyuG0rY=
golang.****-corp.com/finance/abcd-common v0.0.0-20220223084623-8638e88c999e/go.mod h1:APKYogyUvNvSCVZol17RGhkN3ktrUANIWInqJPQs10U=

// h1:hash 和 go.mod h1:hash两者，要不就是同时存在，要不就是只存在 go.mod h1:hash。那什么情况下会不存在 h1:hash 呢？

就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的h1 hash，就会出现不存在 h1 hash，只存在 go.mod h1:hash 的情况。
go.mod 和 go.sum 是 go modules 版本管理的指导性文件，因此 go.mod 和 go.sum 文件都应该提交到你的 Git 仓库中去，避免其他人使用你写项目时，重新生成的go.mod 和 go.sum 与你开发的基准版本的不一致
```

- **管理版本**：

```go
// Go Modules 会自动为您管理依赖项的版本。您可以通过指定版本号或标签来选择特定的依赖版本。Go Modules 会将所选版本的依赖项信息写入 `go.mod` 文件中。

go get dependency-package@version
```

- 更新依赖

```go
// 可以使用 go get 命令来更新依赖项，以获取它们的最新版本或特定版本的更新。Go Modules 会更新 go.mod 文件中的依赖项信息

go get -u dependency-package
```

- 下载过程

```go
// go module 默认不在 GOPATH 目录下查找依赖文件，其首先会在 $GOPATH/pkg/mod 中查找有没有所需要的依赖，没有的直接会进行下载。
// 可以使用 go mod download下载好所需要的依赖，依赖默认会下载到$GOPATH/pkg/mod中，其他项目也会使用缓存的 module。

// 使用 Go 的其他包管理工具 godep、govendor、glide、dep 等都避免不了网络代理的问题，Go Modules 也是一样，但在go.mod中可以使用replace将特定的库替换成其他库
```

- vendor 目录

```go
// 虽然 Go Modules 不再强制要求使用 vendor 目录来存储依赖项，但仍然可以使用它来存储项目的依赖项的本地副本

// 使用 go mod vendor 命令可以将依赖项复制到 vendor 目录中，并通过 -mod=vendor 标志来指示编译时使用 vendor 目录中的依赖项, 这有助于确保项目的构建稳定性
```

- 生成构建文件：

```go
// 使用 go build、go test 等命令来构建和测试项目，Go 会自动管理依赖关系，Go Modules 会根据 go.mod 文件自动下载和构建所需的依赖项，以确保构建过程的可重复性
// 可以使用 -mod=readonly 标志来确保不会意外更改依赖项的版本
```

- 迁移旧项目

```go
// 对于已经存在的旧项目，可以使用 Go Modules 进行迁移，将其转换为 Go Modules 模式。运行 go mod init 命令并将项目导入到一个新的模块中即可
```

- 清理依赖

```go
// 使用 go mod tidy 命令可以自动删除项目中不再使用的依赖项，以保持 go.mod 文件的整洁
```

##### 13.2.2.2 go module核系概念

- Go Modules 以semantic version(语义版本化)和Minimal Version Selection, MVS(最小版本选择)为核心，相比dep更具稳定性；同时也解决了vendor代码库依赖过于庞大，造成存储浪费的问题

  

###### 13.2.2.2.1 语义版本化

  - 使用semantic version来标识package的版本。具体来说:
    - 主版本号（MAJOR version）：当你做了不兼容的 API 修改。
    - 次版本号（MINOR version）：当你做了向下兼容的功能性新增。
    - 修订号（PATCH version）：当你做了向下兼容的问题修改

![image-20230923002833581](https://cloud.006288.xyz/PicGo//image-20230923002833581.png)

###### 13.2.2.2.2 最小版本选择（MVS）

- 在Minimal version selection之前，Go的选择算法很简单，且提供了 2 种不同的版本选择算法，但都不正确：

  - 第 1 种算法是 go get 的默认行为：若本地有一个版本，则使用此版本；否则下载使用最新的版本。
    - 这种模式将导致使用的版本太老：假设已经安装了B 1.1，并执行 go get 下载，那么go get 不会更新到B 1.2，这样就会导致因为B 1.1太老构建失败或有bug

  

  - 第 2 种算法是 go get -u 的行为：下载并使用所有模块的最新版本
    - 这种模式可能会因为版本太新而失败：若你运行 go get -u 来下载A依赖模块，会正确地更新到B 1.2。同时也会更新到C 1.3 和E 1.3，但这可能不是 A 想要的，因为这些版本可能未经测试，无法正常工作

  ![image-20230923003436392](https://cloud.006288.xyz/PicGo//image-20230923003436392.png)

-  上图显示了module A，B和C如何分别独立地需要module D和各自需要D的不同版本。

  - 如果启动一个需要module A的项目，那么为了构建代码，我还需要module D。module D可能有很多版本(最大版本为v1.5.0)可供选择  go list -m -versions  *** 。

    - 现在只有module A 需要module D，而module A已指定它要求的版本为v1.0.6，所需版本集合中有v1.0.6，因此Go选择的module D的版本即是它;
    - 再将module B导入项目后，Go会将项目的module D版本从集合(v1.0.6和v1.2.0)中把版本从v1.0.6升级到v1.2.0；
    - 再引入module C的工程时会怎样？Go将从当前所需版本集合(v1.0.6，v1.2.0，v1.3.2)中选择最新版本(v1.3.2)

    - 删除刚刚添加的依赖module C的代码会怎样？Go会将项目锁定到module D的版本v1.3.2上。

    - 降级到版本v1.2.0将是一个更大的更改，而Go知道版本v1.3.2可以正常并稳定运行，因此版本v1.3.2仍然是module D的“最新但非最大(latest non-greatest)“版本
      

#### 13.2.3 go module注意事项

- go mod常用命令

```go
go mod init  		 	# 初始化生成go.mod
go mod tidy  			# 更新依赖文件（添加新增的，删除未使用的）
go mod download  		# 下载依赖文件
go mod vendor  			# 将依赖转移至本地的vendor文件
go mod edit  			# 手动修改依赖文件
go mod graph 	 		# 打印依赖图
go mod verify  			# 校验依赖
go mod why 				# 解释为什么需要依赖
go build:               # 编译当前模块
go build ./...			#编译当前目录下的所有模块
go build -mod=vendor	#使用当前模块下的 vendor 目录中的包进行编译
go mod grapha			#打印所有第三方模块
go list -m -json all	#显示所有模块信息

go list std#查看所有标准包

go get常用参数：
-d：仅下载依赖包
-u：更新包并安装
-x：打印执行的命令
-v：打印构建的包
-insecure：允许使用 http 协议下载包
```

- 最佳建议：
  - 尽量不要手动修改go.mod文件，通过go命令来操作go.mod文件
  - 尽量遵守semantic version(语义化版本)发布和管理模块

- module文件(go.mod)仅维护快照，而不是日志。没有有关历史撤消或降级的信息




## 14. 面向对象编程

### 14.1 编程思想

- 在日常编程中我们通常会有面向过程和面向对象的编程思想

#### 14.1.1 面向过程

- 统的面向过程的编程思想总结起来就八个字(自顶向下，逐步细化)
- **面向过程**（Procedure Oriented 简称 PO）：是一种以过程为中心的编程思想,分析出解决问题的步骤，然后用函数把这些步骤一步一步实现。面向过程编程，数据和对数据的操作是分离的
- 将要实现的功能描述为一个从开始到结束按部就班的连续的“步骤”, 依次逐步完成这些步骤，如果某一个步骤的难度较大，又可以将该步骤再次细化为若干个子步骤，以此类推，一直到结尾并得到我们想要的结果

> 就是把要开发的系统分解为若干个步骤，每个步骤就是函数，当所有步骤全部完成以后，则这个系统就开发完毕了！

```go
package main

import "fmt"

func add(a, b int) int {
    return a + b
}

func subtract(a, b int) int {
    return a - b
}

func main() {
    result1 := add(3, 5)
    result2 := subtract(8, 2)
    fmt.Println("Addition:", result1)
    fmt.Println("Subtraction:", result2)
}

```

#### 14.1.2 面向对象

- **面向对象**（Object Oriented 简称 OO）：面向对象会把事物抽象成对象的概念，先抽象出对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法。面向对象编程，数据和对数据的操作是绑定在一起的

```go
package main

import "fmt"

type Rectangle struct {
    Width  float64
    Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func main() {
    rect := Rectangle{Width: 10, Height: 5}
    fmt.Println("Area of the rectangle:", rect.Area())
}

```

#### 14.1.3 面向对象和面向过程的区别

- 示例1

```go
//面向过程：
放衣服（方法）-->加洗衣粉（方法）--> 加水（方法）--> 漂洗（方法）--> 清洗（方法）--> 甩干（方法）

// 面向对象：
new 出两个对象 ”人“ 和 ”洗衣机“
”人“ 加入属性和方法：放衣服（方法）、加洗衣粉（方法）、加水（方法）
”洗衣机“ 加入属性和方法：漂洗（方法）、清洗（方法）、甩干（方法）

然后执行：
人.放衣服（方法）-> 人.加洗衣粉（方法）-> 人.加水（方法）-> 洗衣机.漂洗（方法）-> 洗衣机.清洗（方法）-> 洗衣机.甩干（方法
```

- 示例2

```go
//面向过程的程序设计方式：
1、确定长方形周长和面积的算法。
2、编写两个方法（函数）分别计算长方形的周长和面积。
3、求周长的方法（函数）和求面积的方法（函数）需要两个参数，分别是长方形的长和宽。

//面向对象的程序设计方式：
1、一个长方形可以看成一个长方形对象。
2、一个长方形对象有两个状态（长和宽）和两个行为（求周长和求面积）。
3、将所有长方形的共性抽取出来，设计一个长方形类。
4、通过长方形对象的行为，就可以求出某个具体的长方形对象的周长和面积
```

- 面向对象和面向过程的区别
  - 相同点:
    - 都可以实现代码重用和模块化编程
  - 不同点:
    - 面向过程
      - 面向过程的代码执行效率比面向对象高
    - 面向对象
      - 面向对象的模块化更深，数据也更封闭和安全
      - 面向对象的思维方式更加贴近现实生活，更容易解决大型的复杂的业务逻辑
      - 耦合低（易复用），扩展性强，易维护，由于面向对象有封装、继承、多态性的特点，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
  - 从前期开发的角度来看，面向对象比面向过程要更复杂，但是从维护和扩展的角度来看，面向对象要远比面向过程简单！

### 14.2 go语言面向对象编程

- Golang 也支持面向对象编程(OOP)，但是和传统的面向对象编程有区别，并不是纯粹的面向对象语言。所以我们说 Golang 支持面向对象编程特性是比较准确的
- Golang 没有类(class)，Go 语言的结构体(struct)和其它编程语言的类(class)有同等的地位，你可以理解 Golang 是基于 struct 来实现 OOP 特性的。 
- Golang 面向对象编程非常简洁，去掉了传统 OOP 语言的继承、方法重载、构造函数和析构函数、隐藏的 this 指针等等
- Golang 仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式和其它OOP语言不一样，比如继承 ：Golang 没有 extends 关键字，继承是通过匿名字段来实现。
- Golang 面向对象(OOP)很优雅，OOP 本身就是语言类型系统(type system)的一部分，通过接口(interface)关联，耦合性低，也非常灵活。

#### 14.2.1 面向对象两个概念

##### 14.2.1.1 类

- Go语言中没有类（class）的概念，而是通过结构体（struct）和方法（method）的组合来实现面向对象的特性, 可以创建结构体，并为结构体定义方法，从而模拟类和对象的行为
- 类是一系列事物的统称，同类事物必定具有相同的特征
- 可以通过属性和方法（函数）来描述类。属性就是特征，方法（函数）就是行为

```go
// 定义一个student类
type Student struct {
	name string
	id   int
	age  int
	add  string
}

func (s Student)student_info()  {
	fmt.Printf("学生的姓名为: %s,学号为: %d,年龄为: %d,地址为: %s\n",s.name,s.id,s.age,s.add)
}


// 实例化类得到对象
对象名 = 类名()
```

##### 14.2.1.2 对象

- 类的实例化就是通过类得到对象

- 类的实例化就是把抽象的事务具体为现实世界中的实体。
- 类只是对象的一种规范，类本身基本上什么都做不了，必须利用类得到对象，这个过程就叫作类的实例化

```go
// 实例化类
	Tom := Student{name: "Tom", id: 001, age: 23, add: "shanghai"}
	Tom.student_info()
```

- 在Go语言中，你不能像在传统的面向对象语言（比如Java、Python等）中那样在类的外面直接添加属性。在Go中，你必须在结构体中定义属性，然后通过结构体的实例（对象）来访问这些属性

```go
package main

import "fmt"

// 定义一个student类
type Student struct {
	name string
	id   int
	age  int
	add  string
}

func (s *Student) student_info() {
	fmt.Printf("学生的姓名为: %s,学号为: %d,年龄为: %d,地址为: %s\n", s.name, s.id, s.age, s.add)
}

func main() {
	// 实例化类
	Tom := Student{name: "Tom", id: 001, age: 23, add: "shanghai"}
	Tom.student_info()

	// 获取属性
	fmt.Printf("学生的姓名为: %s\n", Tom.name)
	fmt.Printf("学生的地址为: %s\n", Tom.add)

	// 修改属性
	Tom.age = 20
	fmt.Printf("%s学生的年龄为: %d\n", Tom.name, Tom.age)
	Tom.student_info()
}

```

##### 14.2.1.3 面向对象编程：类与对象的关系

- **对象**
  - 对象是由数据（描述事物的属性）和作用于数据的操作（体现事物的行为）组成的封装体，描述客观事物的一个实体，是构成系统的基本单元

- **类**
  - 类可以看作是C语言里面结构体（struct）的升级版，在C语言结构体中只能定义变量，在C++中，类不仅可以定义变量，也可以定义函数。 

- 类是对一组有相同数据和相同操作的对象的定义，是对象的模板，其包含的方法和数据描述一组对象的共同行为和属性。类是在对象之上的抽象，对象则是类的具体化，是类的实例。类可有其子类，也可有其他类，形成类层次结构。

- **类与对象的区别：**

  - 类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。

  - 类是一组具有相同属性和行为的对象的抽象。我们可以将类看做是创建对象蓝图，对象根据这个蓝图去具体实现某个东西。



- 举例说明

```go
晴雨伞和剑伞具有一些共同的属性：遮阳、遮雨等。伞是对晴雨伞和剑伞的一种抽象，晴雨伞和剑伞是伞这个类的两种具体实现。
所以，类的实例化结果就是对象，而对一类对象的抽象就是类，类描述了一组有相同属性和相同方法的对象
```

![image-20231012221552503](https://cloud.006288.xyz/PicGo//image-20231012221552503.png)

#### 14.2.3 面向对象的特征

- 面向对象编程的三大特征:  封装、继承、多态

##### 14.2.3.1 封装

###### 14.2.3.1.1 什么是封装

- 封装是面向对象编程的一种基本特性，它指的是将数据（结构体的字段）和操作数据的方法（结构体的方法）捆绑在一起，形成一个单一的单元对外提供。在Go语言中，你可以使用结构体的字段和方法来实现封装
- 将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来 和对象进行交互。封装本质上是一种管理，让用户更方便使用类

![image-20231012233328609](https://cloud.006288.xyz/PicGo//image-20231012233328609.png)



- 在Go语言中，封装是通过标识符的命名约定来实现的，而不是像其他语言通过关键字（如[public、private、protected](https://blog.csdn.net/MWooooo/article/details/129005065)）来控制访问权限   ==(Go语言依赖于命名约定，而不是关键字，来实现封装)==
  - **首字母大写**：如果一个标识符（变量、常量、函数、结构体、方法等）以大写字母开头，那么它是可导出的（public），可以在包外部访问。这种规则类似于其他编程语言中的public访问权限
  - **首字母小写**：如果一个标识符以小写字母开头，它是不可导出的（private），只能在包内部访问

```go
package mypackage

type Person struct {
    FirstName string // 可导出的字段
    age       int    // 不可导出的字段
}

type person2 struct {      // 不可导出的类
    name string            // 不可导出的字段
    Age int				   // 可导出的字段
}

func (p *Person) SetAge(newAge int) {
    p.age = newAge
}

func (p Person) GetAge() int {
    return p.age
}
```

###### 14.2.3.2 封装的意义

- **数据隐私和安全性**：封装允许你隐藏数据的具体实现细节，只暴露必要的操作接口。通过将数据字段设置为私有（小写字母开头，仅在包内可见），你可以防止外部代码直接修改对象的内部状态，从而确保数据的安全性和一致性
- **简化接口**：封装可以将对象的复杂性隐藏在简单的接口背后。外部代码只需要知道如何与对象进行交互，而不需要了解对象的内部实现。这简化了使用对象的过程，降低了使用者的认知负担
- **代码组织和维护**: 封装提供了良好的代码组织结构，将相关的数据和行为组织在一起，使得代码更易读、易懂
- **版本控制和兼容性**：通过封装，可以控制对象的外部接口，使得对象的内部实现可以被灵活地修改而不影响外部代码
- **多态性**：封装和接口一起使用，可以实现多态性

##### 14.2.3.2 继承

###### 14.2.3.2.1 什么是继承

- 继承是一种允许通过继承原有类的某些特性或全部特性而产生全新的类，原有的类称为父类，产生的新类称为子类。
- 子类不仅可以直接继承父类的共性，而且也可以创建它特有的个性。
- 在Go语言中，没有直接的继承机制，但可以使用组合（composition ）和接口（interfaces）来模拟继承
- [[结构体相关知识点#8.4 结构体(struct)]]

> 组合（composition ）其实就是在结构体阶段讲到的嵌套结构体也叫匿名字段[[#8.4.4 匿名字段]]

```go
package main

import "fmt"

type StoreA struct {
	id        int
	describle string
}

func (sa *StoreA) Show_data() {
	fmt.Printf("数据id为: %d, 数据描述为: %s\n", sa.id, sa.describle)
}

type StoreB struct {
	StoreA
	year int
}

func main() {
	// 实例化一个对象
	result := StoreB{StoreA{id: 1001, describle: "测试数据"}, 2023}
	result.Show_data()
}

// StoreB继承了StoreA结构体的字段和方法,可以直接在StoreB上直接调用
```

- 继承的意义:
  - 继承的主要目的是实现代码的重用和扩展。通过继承，子类可以继承父类的属性和方法，避免了重复编写相同的代码。同时，继承也使得代码的层次结构更加清晰，提高了代码的可读性和可维护性

###### 14.2.3.2.2 继承属性使用场景

- **继承父类并进行成员操作**

```go

package main

import "fmt"

// 父类
type Persion struct {
	id   int
	name string
	age  int
}

// 子类
type Student struct {
	Persion     // 继承属性	结构体嵌套
	score   int // 添加专属属性
}

func main() {
	// 顺序初始化
	var s1 Student = Student{Persion{101, "小明", 18}, 98}
	fmt.Println(s1) // {{101 小明 18} 98}

	// 自动推导类型
	s2 := Student{Persion{102, "张三", 19}, 90}
	fmt.Println(s2) // {{102 张三 19} 90}

	// 指定初始化: 没有初始化的部分使用默认值
	s3 := Student{score: 100}
	fmt.Println(s3) // {{0  0} 100}

	var s4 Student = Student{Persion{101, "小明", 18}, 98}
	// 成员操作 .
	s4.score = 89
	fmt.Println(s4) // {{101 小明 18} 89}

	// 通过子类访问父类属性时完整写法应该是"子类.父类.属性"但是go语言编译器已经做了优化可以直接使用"子类.属性"访问
	
	//s4.Persion.id = 110
	s4.id = 110
	fmt.Println(s4) //	{{110 小明 18} 89}
	
	
	s4.age = 22

	s4.Persion = Persion{100, "李四", 20}
	fmt.Println(s4) // {{100 李四 20} 89}

}
```

> - 编译器会先看Student对应的类型有没有Name,如果有，则直接调用Student类型字段 如果没有，就会去看嵌套的匿名结构体Persion中有没有声明Name字段，如果有就调用 ，没有就继续查找，找不到则报错
>
> - 当结构体和匿名结构体有相同的字段或者方法时，编译器采用就近访问原则访问，如希望访问匿名结构体的字段和方法，可以通过匿名结构体名来区分

- **匿名字段同名成员:** 
  - 子类与父类结构体有相同的成员名时, 默认赋值给子类, 采用就近原则

```go
package main

import "fmt"

// 父类
type Persion2 struct {
	id   int
	name string
	age  int
}

type Stu struct {
	Persion2
	// 子类中的name字段和父类同名,初始化时会将值赋值给子类
	name  string
	score int
}

func main() {
	var s1 Stu
	s1.name = "王五"
	fmt.Println(s1) // {{0  0} 王五 0}

	s1.Persion2.name = "wangwu"
	fmt.Println(s1) // {{0 wangwu 0} 王五 0}
}

```

- **多重继承:**
  - 如一个 struct 嵌套了多个匿名结构体，那么该结构体可以直接访问嵌套的匿名结构体的字段和方法，从而实现了多重继承

```go
package main

import "fmt"

type Father struct {
	name string
	age  int
	sex  string
}

type Monther struct {
	id   int
	addr string
}

type Son struct {
	Father
	Monther
	score int
}

type Humen struct {
	id   int
	name string
}

type Persion2 struct {
	Humen
	age int
	sex string
}

type Student2 struct {
	Persion2
	score int
}

func main() {
    // 初始化
	var son Son

	son.id = 200
	son.addr = "北京"
	son.name = "张三"
	son.age = 18
	son.sex = "男"
	son.score = 100

	fmt.Println(son) // {{张三 18 男} {200 北京} 100}

	// 自动推导
	s1 := Son{Father{"李四", 20, "女"}, Monther{201, "上海"}, 90} // {{李四 20 女} {201 上海} 90}
	fmt.Println(s1)
	
	// 初始化
	var stu Student2
    
	stu.name = "张三"
	stu.age = 20
	stu.score = 94
	fmt.Println(stu) // {{{0 张三} 20 } 94}

	// 自动推导
	stu1 := Student2{Persion2{Humen{100, "李四"}, 30, "男"}, 98}
	fmt.Println(stu1) // {{{100 李四} 30 男} 98}

}
```

###### 14.2.3.2.3 继承方法使用场景

- 继承父类的方法
- 方法相关知识点[[11. 方法]]

```go
package main

import "fmt"

type Person3 struct {
	id   int
	name string
	age  int
}

func (p *Person3) PrintInfo() {
	fmt.Printf("编号: %d\n", p.id)
	fmt.Printf("姓名: %s\n", p.name)
	fmt.Printf("年龄: %d\n", p.age)
}

type Student3 struct {
	Person3
	class int // 班级
}


func main() {
	p := Person3{110, "张三", 18}
	p.PrintInfo()
	// 编号: 110
	// 姓名: 张三
	// 年龄: 18

	s := Student3{Person3{111, "李四", 20}, 2}
	// 子类可以继承父类的属性和方法
	s.PrintInfo()
	// 编号: 111
	// 姓名: 李四
	// 年龄: 20
}
```

- 方法重写
  -  方法重写即在子类中重新书写与父类的同名方法

```go
package main

import "fmt"

// 定义一个父类
type Animal struct {
	name string
}
// 给父类绑定一个方法
func (ca Animal) Call() {
	fmt.Println("I can call")
}
// 定义子类继承父类,并且重写父类方法
type Dog struct {
	Animal
}
// 重写父类方法
func (d Dog) Call() {
	fmt.Println("I can wang wang")
}

type Cat struct {
	Animal
}

func (c Cat) Call() {
	fmt.Println("I can miao miao")
}

func main() {
	// 示例化子类
	dog := Dog{Animal{name: "dog"}}
	dog.Call()

	cat := Cat{Animal{name: "cat"}}
	cat.Call()
	// 父类方法并没有消失.当我们调用方法时,他会现在子类中查找,如果有直接调用,没有的话就去父类中查找,父类没有就报错
	animal := Animal{name: "test"}
	animal.Call()
}
```

##### 14.2.3.3 多态性

- 多态是一种使用对象的方式，子类重写父类方法，调用不同子类对象的相同父类方法，可以产生不同的执行结果
- 白话: 定义一个父类，其可能拥有多个子类对象。当我们调用一个公共方法时，传递的对象不同，则返回的结果不同
- 多态的意义: 调用灵活，有了多态，更容易编写出通用的代码，做出通用的编程，以适应需求的不断变化！

- 多态依赖继承,同时子类方法必须重写父类方法

- 多态相关知识点[[#12. 接口]]

- go语言多态性:
  - Go 不支持经典的类继承体系。但根据多态的定义和特点, 在 Go 中，多态性通过接口（interfaces）和类型断言（type assertion）来实现

```go
// 定义了一个 Notifier 接口，该接口包含了一个 Notify 方法。然后，你创建了三个结构体 WeChat、QQChat 和 EmailChat，它们分别实现了 Notifier 接口的 Notify 方法。这种结构允许不同类型的对象（WeChat、QQChat 和 EmailChat）通过相同的接口进行访问和调用
// 在 Sender 函数中，你使用了接口 Notifier 的多态性，根据输入的 send_source 创建了不同类型的对象实例，并通过接口调用了 Notify 方法，实现了多态行为。这种多态性允许使用统一的方式处理不同类型的对象

package main

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"strings"
)

type Notifier interface {
	Notify()
}

type MessageFormat struct {
	source  string
	content string
}

type WeChat struct {
	MessageFormat
}

func (wx *WeChat) Notify() {
	fmt.Printf("%s收到一条消息,消息内容是: %s\n", wx.source, wx.content)
}

type QQChat struct {
	MessageFormat
}

func (qq *QQChat) Notify() {
	fmt.Printf("%s收到一条消息,消息内容是: %s\n", qq.source, qq.content)
}

type EmailChat struct {
	MessageFormat
}

func (email *EmailChat) Notify() {
	fmt.Printf("%s收到一条消息,消息内容是: %s\n", email.source, email.content)
}

func Sender(send_source, content string) error {
	var message Notifier
	switch send_source {
	case "wx":
		message = &WeChat{MessageFormat{send_source, content}}
	case "email":
		message = &EmailChat{MessageFormat{send_source, content}}
	case "qq":
		message = &QQChat{MessageFormat{send_source, content}}
	default:
		return errors.New("输入有误!")
	}
	message.Notify()
	return nil
}

func main() {
	var send_source, content string
	// 使用使用 fmt.Scanln 读取用户输入时，只会读取到空格之前的内容
	//fmt.Print("你要使用什么发送: ")
	//fmt.Scanln(&send_source)
	//fmt.Print("你要发送的消息是: ")
	//fmt.Scanln(&content)

	fmt.Print("你要使用什么发送: ")
	reader := bufio.NewReader(os.Stdin)
	send_source, _ = reader.ReadString('\n')
	send_source = strings.TrimSpace(send_source)

	fmt.Print("你要发送的消息是: ")
	content, _ = reader.ReadString('\n')
	content = strings.TrimSpace(content)

	err := Sender(send_source, content)
	if err != nil {
		fmt.Println(err)
	}

}
```

## 15. 文件操作

### 15.1 文件概念

- 存放内存中的数据在计算机关机后就会消失。要长久保存数据，就要使用硬盘、光盘、U 盘等设备。为了便于数据的管理和检索，引入了“文件”的概念。
- 文件,对我们并不陌生,文件是数据源(保存数据的地方)的一种,比如大家经常使用的word 文档,txt 文件,excel 文件...都是文件。文件最主要的作用就是保存数据,它既可以保存一张图片,也可以保持视频,声音...
- 一篇文章、一段视频、一个可执行程序，都可以被保存为一个文件，并赋予一个文件名。操作系统以文件为单位管理磁盘中的数据。一般来说，==文件可分为文本文件、视频文件、音频文件、图像文件、可执行文件等多种类别

![image-20231018215528202](https://cloud.006288.xyz/PicGo//image-20231018215528202.png)

- 文件操作的作用:
  - 文件操作的作用就是把一些内容(数据)存储存放起来，可以让程序下一次执行的时候直接使用，而不必重新制作一份，省时省力

### 15.2 文件基本操作

- 文件操作三步走:
  - 打开文件
  - 读写文件
  - 关闭文件
- 在go语言中文件使用`os`包提供的函数来操作文件

#### 15.2.1 创建文件

- 使用`os.Create`函数来创建一个新的文件。Create采用模式0666（任何人都可读写，不可执行）创建文件，如果文件已存在会截断它（为空文件）。如果成功，返回的文件对象可用于I/O；对应的文件描述符具有O_RDWR模式。如果出错，错误底层类型是*PathError

```go
func Create(name string) (file *File, err error)
```

- 示例

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 创建一个新的文件，文件名为a.txt
	file, err := os.Create("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法创建文件:", err)
		return
	}
	defer file.Close() // 在函数结束时关闭文件

	fmt.Println("文件创建成功!")
}
```

#### 15.2.2 打开文件

- 在Go语言中，有两个主要的函数用于打开文件：`os.Open`和`os.OpenFile`

  - 使用`os.Open`函数来打开一个已经存在的文件, Open打开一个文件用于读取。如果操作成功，返回的文件对象的方法可用于读取数据；对应的文件描述符具有O_RDONLY模式。如果出错，错误底层类型是*PathError

  - OpenFile是一个更底层的文件打开函数，大多数调用者都应用Open或Create代替本函数。`os.OpenFile` 函数提供了更多的选项，可以用于以指定的模式和权限打开文件，包括读取、写入和追加等操作。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError

```go
// Open
func Open(name string) (file *File, err error)

// OpenFile
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

- 使用Open()函数打开文件

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 打开一个已经存在的文件，文件名为example.txt
	file, err := os.Open("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法打开文件:", err)
		return
	}
	defer file.Close() // 在函数结束时关闭文件

	// 读取文件内容...
}
```

- 使用OpenFile函数打开文件

  - OpenFile( )函数有三个参数：

    - 第一个参数表示：打开文件的路径
    - 第二个参数表示：模式
    
    ```go
    // 位掩码参数flag用于指定文件的访问模式，可用的值在os中定义为常量
    const (
        O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件
        O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件
        O_RDWR int = syscall.O_RDWR // 读写模式打开文件
        O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部
        O_CREATE int = syscall.O_CREAT // 如果不存在将创建一个新文件
        O_EXCL int = syscall.O_EXCL // 和O_CREATE配合使用，文件必须不存在
        O_SYNC int = syscall.O_SYNC // 打开文件用于同步I/O
        O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件
    )
    // O_RDONLY、O_WRONLY、O_RDWR应该只指定一个，剩下的通过“|”操作符来指定。该函数内部会给flags加上syscall.O_CLOEXEC，在fork子进程时会关闭通过OpenFile打开的文件，即子进程不会重用该文件描述
    ```
    
    - 第三个参数表示: 权限，取值范围（0-7）
    
    ```go
    // 主要用在linux系统下,在windows下效果较小几乎没有作用
    // 位掩码参数perm指定了文件的模式和权限位，类型是os.FileMode
    const (
        // 单字符是被 String 方法用于格式化的属性缩写
        ModeDir FileMode = 1 << (32 - 1 - iota) // d: 目录
        ModeAppend // a: 只能写入，且只能写入到末尾
        ModeExclusive // l: 用于执行
        ModeTemporary // T: 临时文件（非备份文件）
        ModeSymlink // L: 符号链接（不是快捷方式文件）
        ModeDevice // D: 设备
        ModeNamedPipe // p: 命名管道（FIFO）
        ModeSocket // S: Unix域socket
        ModeSetuid // u: 表示文件具有其创建者用户id权限
        ModeSetgid // g: 表示文件具有其创建者组id的权限
        ModeCharDevice // c: 字符设备，需已设置ModeDevice
        ModeSticky // t: 只有root/创建者能删除/移动文件
     
        // 覆盖所有类型位（用于通过&获取类型位），对普通文件，所有这些位都不应被设置
        ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice
        ModePerm FileMode = 0777 // 覆盖所有Unix权限位（用于通过&获取类型位）
    )
    
    
    表示如下：
    0： 没有任何权限
    1： 执行权限(如果是可执行文件，是可以运行的)
    2： 写权限
    3:  写权限与执行权限
    4： 读权限
    5:  读权限与执行权限
    6:  读权限与写权限
    7:  读权限，写权限，执行权限

- 示例

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 打开或创建一个文件，文件名为example.txt，以读写的方式打开，如果文件不存在则创建
	file, err := os.OpenFile("example.txt", os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法打开文件:", err)
		return
	}
	defer file.Close() // 在函数结束时关闭文件

	// 读取或写入文件内容...
}

// os.OpenFile 函数用于打开名为 example.txt 的文件
// os.O_RDWR 表示以读写方式打开文件
// os.O_CREATE 表示如果文件不存在则创建文件
// 0666 是文件的权限
```

#### 15.2.3 文件读取

- 在Go语言中，你可以使用`os`包和`bufio`包来读取文件的内容

![image-20231022222646927](https://cloud.006288.xyz/PicGo//image-20231022222646927.png)

##### 15.2.3.1 读取整个文件

- 直接将数据直接读取入内存，是效率最高的一种方式，但此种方式，仅适用于小文件，对于大文件，则不适合，因为比较浪费内存

###### 15.2.3.2.1 直接指定文件名读取

- **使用 os.ReadFile**

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.ReadFile("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(file))
}
```

- **使用 ioutil.ReadFile**

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	file, err := ioutil.ReadFile("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println(string(file))
}
```

> Go 1.16 开始，ioutil.ReadFile就等价于 os.ReadFile，二者是完全一致的

![image-20231022223612920](https://cloud.006288.xyz/PicGo//image-20231022223612920.png)

###### 15.2.3.1.2 先创建句柄在读取文件

- 从1.6开始go已经弃用ioutil.ReadAll采用io.ReadAll

![image-20231022224746355](https://cloud.006288.xyz/PicGo//image-20231022224746355.png)

- 仅读取文件,可以使用高级函数os.Open

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
    // 创建句柄
	file, err := os.Open("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()

	filecontent, err := io.ReadAll(file)
	fmt.Println(string(filecontent))
}
```

- 使用io.OpenFile()函数

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
    // 创建句柄
	file, err := os.OpenFile("E:/devtoos/gocode/code/project01/file/a.txt", os.O_RDWR, 0666)
	if err != nil {
		fmt.Println(err)
	}
	defer file.Close()

	filecontent, err := io.ReadAll(file)
	fmt.Println(string(filecontent))
}
```

##### 15.2.3.2 每次只读取一行

- 一次性读取所有的数据，太耗费内存，因此可以指定每次只读取一行数据。方法有三种：
  - bufio.ReadLine()
  - bufio.ReadBytes(’\n’)
  - bufio.ReadString(’\n’)
- 在 bufio 的源码注释中，曾说道 bufio.ReadLine() 是低级库，不太适合普通用户使用，更推荐用户使用 bufio.ReadBytes 和 bufio.ReadString 去读取单行数据

- **ReadBytes()和ReadString()的区别**
  - `ReadBytes` 和 `ReadString` 是 `bufio.Reader` 类型的两个方法，用于从输入源（比如文件、网络连接等）中读取数据。它们的主要区别在于读取的单位和返回值的类型
  - `ReadBytes(delim byte) ([]byte, error)`
    - `ReadBytes` 方法从输入源中读取数据，直到遇到指定的分隔符 `delim`。一旦读取到分隔符，它会将包含分隔符在内的所有字节数据返回为一个切片。如果在遇到分隔符之前遇到了错误，或者到达了输入流的末尾，`ReadBytes` 将返回已读取的字节数据和可能的错误
  - `ReadString(delim byte) (string, error)`
    - `ReadString` 方法与 `ReadBytes` 类似，但是它返回的是一个字符串，而不是字节切片。它从输入源中读取数据，直到遇到指定的分隔符 `delim`。一旦读取到分隔符，它将返回包含分隔符在内的所有字符数据作为字符串。如果在遇到分隔符之前遇到了错误，或者到达了输入流的末尾，`ReadString` 将返回已读取的字符串和可能的错误



###### 15.2.3.2.1 使用 bufio.ReadBytes

- `ReadBytes('\n')`函数会逐行读取文件内容，直到遇到换行符（'\n'）或文件结束

> `ReadBytes('\n')` 方法会读取到文件的最后一行，但是如果这一行没有换行符（'\n'），它就不会被视为一个完整的行。为了处理文件最后一行没有换行符的情况，你可以在读取文件内容后检查 `io.EOF` 错误，如果遇到 `EOF` 错误，说明已经读取到文件末尾，可以处理最后一行的内容

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
)

func main() {
	// 打开文件，创建文件句柄
	fi, err := os.Open("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		panic(err) // 如果打开文件失败，抛出异常并退出程序
	}
	defer fi.Close() // 在函数结束时关闭文件句柄，释放资源

	// 创建 Reader 对象，用于逐行读取文件内容
	r := bufio.NewReader(fi)

	// 循环读取文件的每一行内容
	for {
		// 逐行读取文件内容，直到遇到换行符（'\n'）
		lineBytes, err := r.ReadBytes('\n')
		line := strings.TrimSpace(string(lineBytes)) // 去掉每行前后的空白字符

		// 处理每一行的内容，这里假设直接打印到控制台
		fmt.Println(line) // 打印每一行的内容
		
		// 如果读取到文件末尾，退出循环
		if err == io.EOF {
			break // 如果到达文件末尾，退出循环
		}
		if err != nil {
			fmt.Println("读取文件错误:", err)
			break
		}
	}
}
```

- 使用 bufio.ReadString
  - `bufio.ReadString` 函数可以用来按照指定的分隔符读取文件的内容，直到遇到指定的分隔符（例如换行符 `\n`）为止

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
)

func main() {
	// 打开文件，创建文件句柄
	fi, err := os.Open("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		panic(err) // 如果打开文件失败，抛出异常并退出程序
	}
	defer fi.Close() // 在函数结束时关闭文件句柄，释放资源

	// 创建 Reader 对象，用于逐行读取文件内容
	r := bufio.NewReader(fi)

	// 循环读取文件的每一行内容
	for {
		// 逐行读取文件内容，直到遇到换行符（'\n'）
		lineBytes, err := r.ReadString('\n')
		line := strings.TrimSpace(lineBytes) // 去掉每行前后的空白字符

		// 处理每一行的内容，这里假设直接打印到控制台
		fmt.Println(line) // 打印每一行的内容

		// 如果读取到文件末尾，退出循环
		if err == io.EOF {
			break // 如果到达文件末尾，退出循环
		}
		if err != nil {
			fmt.Println("读取文件错误:", err)
			break
		}
	}
}

```

##### 15.2.3.3 每次读取固定字节数

- 每次仅读取一行数据，可以解决内存占用过大的问题，但要注意的是，并不是所有的文件都有换行符 `\n`
- 因此对于一些不换行的大文件来说，通用的做法是：
  - 先创建一个文件句柄，可以使用 os.Open 或者 os.OpenFile
  - 然后 bufio.NewReader 创建一个 Reader
  - 然后在 for 循环里调用 Reader 的 Read 函数，每次仅读取固定字节数量的数据

- `Read` 方法从输入源中读取最多 `len(b)` 个字节的数据，并将其存储到切片 `b` 中。如果输入源中的数据不足以填满整个切片，`Read` 方法会返回读取的字节数和 `io.EOF` 错误（表示已经到达了输入流的末尾）

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	// 打开一个文件，文件名为example.txt
	file, err := os.Open("E:/devtoos/gocode/code/project01/file/a.txt")
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法打开文件:", err)
		return
	}
	defer file.Close() // 在函数结束时关闭文件

	// 定义一个字节切片，用于存储读取的数据
	buffer := make([]byte, 1) // 每次读取10个字节

	for {
		// 从文件中读取数据到字节切片中
		n, err := file.Read(buffer) //  将从文件中读取的数据保存到字符切片中， n:表示从文件中读取的数据的长度
		if err != nil && err != io.EOF {
			// 处理读取文件时的错误
			fmt.Println("读取文件错误:", err)
			break
		}
		if n == 0 {
			break // 如果没有数据可读，退出循环
		}

		// 处理读取的数据，这里假设直接打印到控制台
		fmt.Print(string(buffer[:n]))
	}
}

```

#### 15.2.4 文件写入

##### 15.2.4.1 使用File.Write写入

- 在Go语言中，`File.Write()` 方法用于将数据写入文件。这个方法接受一个字节切片（`[]byte`）作为参数，将字节切片中的数据写入文件

- func (f *File) Write(b []byte) (n int, err error)   
  - `f` 是文件的指针，表示要写入数据的文件。
  - `b` 是要写入的数据，以字节切片（`[]byte`）的形式传递。
  - `n` 是写入的字节数。
  - `err` 是可能的错误。如果写入操作成功，`err` 将为 `nil`

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 打开文件，如果文件不存在会自动创建，如果文件存在会清空文件内容
	file, err := os.Create("output.txt")
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法创建文件:", err)
		return
	}
	defer file.Close() // 在函数结束时关闭文件

	// 要写入的数据
	data := []byte("Hello, Golang!")

	// 将数据写入文件
	bytesWritten, err := file.Write(data)
	if err != nil {
		// 处理写入文件时的错误
		fmt.Println("无法写入文件:", err)
		return
	}

	fmt.Printf("写入了 %d 个字节到文件\n", bytesWritten)
}

```

##### 15.2.4.2 使用File.WriteString写入

- `File.WriteString()` 方法用于将字符串数据写入文件。这个方法接受一个字符串作为参数，将字符串中的数据以字节形式写入文件
- func (f *File) Write(b []byte) (n int, err error):
  - `f` 是文件的指针，表示要写入数据的文件。
  - `b` 是要写入的数据，以字节切片（`[]byte`）的形式传递。
  - `n` 是写入的字节数。
  - `err` 是可能的错误。如果写入操作成功，`err` 将为 `nil`

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 打开文件，如果文件不存在会自动创建，如果文件存在会清空文件内容
	file, err := os.Create("output.txt")
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法创建文件:", err)
		return
	}
	defer file.Close() // 在函数结束时关闭文件

	// 要写入的字符串数据
	str := "Hello, Golang!"

	// 将字符串写入文件
	bytesWritten, err := file.WriteString(str)
	if err != nil {
		// 处理写入文件时的错误
		fmt.Println("无法写入文件:", err)
		return
	}

	fmt.Printf("写入了 %d 个字节到文件\n", bytesWritten)
}

```

##### 15.2.4.3 使用File.WriteAt写入

- 在Go语言中，`File.WriteAt()` 方法用于将数据写入文件的指定位置。该方法允许你在文件的任意位置写入数据，而不仅仅是在文件的末尾。`WriteAt()`
- func (f *File) WriteAt(b []byte, off int64) (n int, err error)
  - `f` 是文件的指针，表示要写入数据的文件。
  - `b` 是要写入的数据，以字节切片（`[]byte`）的形式传递。
  - `off` 是写入的起始位置（偏移量），表示从文件的第几个字节开始写入数据。
  - `n` 是写入的字节数。
  - `err` 是可能的错误。如果写入操作成功，`err` 将为 `nil`

> 通常writeAt会和seek结合使用

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 打开文件，如果文件不存在会自动创建，如果文件存在会清空文件内容
	file, err := os.Create("output.txt")
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法创建文件:", err)
		return
	}
	defer file.Close() // 在函数结束时关闭文件

	// 要写入的数据
	data := []byte("Golang!")

	// 写入数据到文件的指定位置（从文件的第6个字节开始写入）
	bytesWritten, err := file.WriteAt(data, 5)
	if err != nil {
		// 处理写入文件时的错误
		fmt.Println("无法写入文件:", err)
		return
	}

	fmt.Printf("从第%d个字节开始写入了 %d 个字节到文件\n", 5, bytesWritten)
}

```



- 偏移量seek
  - 在Go语言中，`Seek()` 方法用于在文件中移动指针的位置
  - `func (f *File) Seek(offset int64, whence int) (ret int64, err error)`
    - `f` 是文件的指针，表示要操作的文件。
    - `offset` 是偏移量，表示从文件的起始位置（`whence` 为 `io.SeekStart`）、当前位置（`whence` 为 `io.SeekCurrent`）或者文件末尾（`whence` 为 `io.SeekEnd`）移动多少个字节。
    - whence 参数指定了相对于哪个位置进行偏移。可以取以下三个常量值：
      - `io.SeekStart` 表示相对于文件的起始位置。
      - `io.SeekCurrent` 表示相对于当前位置。
      - `io.SeekEnd` 表示相对于文件末尾

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 打开文件以供读写
	file, err := os.OpenFile("sample.txt", os.O_WRONLY, 0644)
	if err != nil {
		fmt.Println("无法打开文件:", err)
		return
	}
	defer file.Close()

	// 移动文件指针到第10个字节位置（相对文件的起始位置）
	_, err = file.Seek(10, os.SEEK_SET)
	if err != nil {
		fmt.Println("无法移动文件指针:", err)
		return
	}

	// 要写入的数据
	data := []byte("Golang!")

	// 在指定位置写入数据
	_, err = file.WriteAt(data, 10)
	if err != nil {
		fmt.Println("无法写入文件:", err)
		return
	}

	fmt.Println("数据已成功写入文件的指定位置")
}
```

##### 15.2.4.4 使用ioutil.WriteFile写入

- `ioutil.WriteFile` 函数是Go标准库`io/ioutil`包中提供的一个方便的函数，用于将数据写入文件, 不需要打开文件、处理文件指针等繁琐的操作。它将提供的字节切片（`[]byte`）数据写入指定的文件路径。如果文件不存在，`WriteFile` 函数会创建文件；如果文件已经存在，它会覆盖文件内容
- `func WriteFile(filename string, data []byte, perm os.FileMode) error`
  - `filename` 表示文件的路径和名称。
  - `data` 是要写入文件的字节切片。
  - `perm` 是文件权限，通常使用八进制表示（例如 `0644`）

> `ioutil.WriteFile` 适合用于一次性写入文件内容的场景，不需要进行文件的打开和关闭操作。如果你需要更多的文件操作控制，如在文件的特定位置写入数据，你可以使用 `os.File` 的方法，例如 `WriteAt` 和 `Seek`。

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	// 要写入的数据
	data := []byte("Hello, Golang!")

	// 将数据写入文件（文件名为output.txt）
	err := ioutil.WriteFile("output.txt", data, 0644)
	if err != nil {
		// 处理错误
		fmt.Println("无法写入文件:", err)
		return
	}

	fmt.Println("数据已成功写入文件")
}

```

##### 15.2.4.5 使用bufio.NewWriter写入

- 在 Go 语言中，`bufio.NewWriter` 函数是 `bufio` 包提供的一个函数，用于创建一个新的写入缓冲区。它接受一个实现 `io.Writer` 接口的对象，并返回一个新的 `*bufio.Writer` 对象。这个新的 `Writer` 对象带有缓冲功能，可以提高写入性能，特别是在处理小而频繁的写入操作时
- `bufio.NewWriter` 函数接受一个实现了 `io.Writer` 接口的对象 `wr`，并返回一个新的 `Writer` 对象，该对象包装了 `wr` 并添加了缓冲功能

```go
func NewWriter(wr io.Writer) *Writer
```

- 其中，`wr` 是实现 `io.Writer` 接口的对象，可以是文件、网络连接或其他支持写入操作的对象

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	// 打开文件
	file, err := os.Create("example.txt")
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	// 创建带缓冲区的 Writer
	bufferedWriter := bufio.NewWriter(file)

	// 写入数据到缓冲区
	data := []byte("Hello, Golang!")
	_, err = bufferedWriter.Write(data)
	if err != nil {
		fmt.Println("Error writing to buffer:", err)
		return
	}

	// 将缓冲区中的数据刷新到底层 Writer（文件）
	err = bufferedWriter.Flush()
	if err != nil {
		fmt.Println("Error flushing buffer:", err)
		return
	}

	fmt.Println("Data has been written to file.")
}
```

##### 15.2.4.6 文件写入 方式的区别

- `File.Write`、`File.WriteString`、`File.WriteAt`、`ioutil.WriteFile` 以及 `bufio.NewWriter` 的共同点和区别:

  - 共同点

  ```go
  这些方法和函数都用于将数据写入文件。
  它们都提供了不同的方式来处理文件写入的需求，包括缓冲写入、直接写入、指定位置写入
  ```

  - 不同点

   ```go
   //File.Write()： 
   File 类型是 os 包提供的，它的 Write 方法直接写入指定的字节切片到文件。这是一个基本的文件写入方法，没有提供缓冲
   作用： 用于将字节切片写入文件。
   语法： func (f *File) Write(b []byte) (n int, err error)
   注意： Write 将给定的字节切片完全写入文件，不考虑文件的当前位置。
   
   
   //File.WriteString()： 
   与 File.Write 类似，但是专门用于写入字符串。它会将字符串转换为字节切片并写入文件
   作用： 用于将字符串写入文件。
   语法： func (f *File) WriteString(s string) (n int, err error)
   注意： WriteString 将给定的字符串写入文件，不考虑文件的当前位置。
   
   
   //File.WriteAt()： 
   允许在文件的指定位置进行写入。通过传递偏移量，可以指定从文件的哪个位置开始写入
   作用： 在指定的偏移量处写入字节切片。
   语法： func (f *File) WriteAt(b []byte, off int64) (n int, err error)
   注意： WriteAt 允许在文件的指定位置写入数据，而不是在文件的当前位置写入。
   
   //ioutil.WriteFile()： 
   该函数通过一次性写入整个字节切片来简化文件写入操作。它会覆盖文件的内容
   作用： 将字节切片写入文件，如果文件不存在则创建，如果文件存在则截断。
   语法： func WriteFile(filename string, data []byte, perm os.FileMode) error
   注意： WriteFile 是一个便捷函数，它组合了打开、写入和关闭文件的操作，适用于一次性写入整个文件的情况。
   
   //bufio.NewWriter()： 
   该函数创建了一个带有缓冲区的 Writer，用于提高写入性能。可以使用这个 Writer 对象进行写入，并最后使用 Flush 方法将缓冲区中的数据刷新到底层的 Writer（比如文件）
   作用： 创建一个带有缓冲区的 Writer。
   语法： func NewWriter(w io.Writer) *Writer
   注意： bufio.NewWriter 用于包装其他 io.Writer，提供缓冲写入的能力，可以显著提高写入效率，特别是在频繁小量写入的情况下。需要调用 Flush 方法将缓冲区中的数据刷新到底层的 io.Writer。
   ```

  

#### 15.2.5 文件名修改

- 在Go语言中，你可以使用`os.Rename`函数来修改文件名

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 原始文件名
	oldFileName := "old_file.txt"
	// 新文件名
	newFileName := "new_file.txt"

	// 尝试重命名文件
	err := os.Rename(oldFileName, newFileName)
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法重命名文件:", err)
		return
	}

	fmt.Println("文件名已修改为:", newFileName)
}
```

- `os.Rename`函数也可以用于移动文件

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 原始文件路径
	oldPath := "path/to/old_file.txt"
	// 新文件路径（移动后的路径）
	newPath := "path/to/new_directory/new_file.txt"

	// 尝试移动文件
	err := os.Rename(oldPath, newPath)
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法移动文件:", err)
		return
	}

	fmt.Println("文件已成功移动到:", newPath)
}

```

#### 15.2.6 删除文件

- 在Go语言中，你可以使用 `os.Remove` 函数来删除文件

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 要删除的文件路径
	filePath := "file_to_be_deleted.txt"

	// 尝试删除文件
	err := os.Remove(filePath)
	if err != nil {
		// 处理错误，比如打印错误信息并退出程序
		fmt.Println("无法删除文件:", err)
		return
	}

	fmt.Println("文件已成功删除:", filePath)
}
```

#### 15.2.7 文件拷贝

- 在Go语言中，可以使用标准库中的 `io.Copy` 函数来复制一个文件的内容到另一个文件中

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	// 打开源文件
	sourceFile, err := os.Open("source.txt")
	if err != nil {
		fmt.Println("无法打开源文件:", err)
		return
	}
	defer sourceFile.Close()

	// 创建或覆盖目标文件
	targetFile, err := os.Create("target.txt")
	if err != nil {
		fmt.Println("无法创建目标文件:", err)
		return
	}
	defer targetFile.Close()

	// 使用io.Copy复制文件内容
	bytesCopied, err := io.Copy(targetFile, sourceFile)
	if err != nil {
		fmt.Println("无法复制文件:", err)
		return
	}

	fmt.Printf("成功复制了 %d 字节的文件内容\n", bytesCopied)
}

```

- 使用`ioutil.ReadFile`和`ioutil.WriteFile`函数拷贝文件内容
  - 该方法使用一次性读取文件，再一次性写入文件的方式，所以该方法不适用于大文件，容易内存溢出

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	sourceFileName := "source.txt"
	targetFileName := "target.txt"

	// 读取源文件的内容
	data, err := ioutil.ReadFile(sourceFileName)
	if err != nil {
		fmt.Println("无法读取源文件:", err)
		return
	}

	// 写入目标文件
	err = ioutil.WriteFile(targetFileName, data, 0644)
	if err != nil {
		fmt.Println("无法拷贝文件内容:", err)
		return
	}

	fmt.Println("使用ioutil成功拷贝了文件内容")
}

```

- 使用os包中的 `os.Read()` 和 `os.Write()`
  - 此方法是按块读取文件，块的大小也会影响到程序的性能

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	sourceFileName := "source.txt"
	targetFileName := "target.txt"

	// 打开源文件
	sourceFile, err := os.Open(sourceFileName)
	if err != nil {
		fmt.Println("无法打开源文件:", err)
		return
	}
	defer sourceFile.Close()

	// 创建或覆盖目标文件
	targetFile, err := os.Create(targetFileName)
	if err != nil {
		fmt.Println("无法创建目标文件:", err)
		return
	}
	defer targetFile.Close()

	// 定义缓冲区大小
	bufferSize := 1024
	buffer := make([]byte, bufferSize)

	// 逐块读取源文件的内容，然后写入目标文件
	for {
		bytesRead, err := sourceFile.Read(buffer)
		if err != nil {
			if err == io.EOF {
				break
			} else {
				fmt.Println("无法读取源文件:", err)
				return
			}
		}

		_, err = targetFile.Write(buffer[:bytesRead])
		if err != nil {
			fmt.Println("无法拷贝文件内容:", err)
			return
		}
	}

	fmt.Println("成功使用逐块读取和写入方式拷贝了文件内容")
}
```

#### 15.2.8 判断文件是否存在

- go判断文件或文件夹是否存在的方法为使用os.Stat（）函数返回的错误值进行判断：
  - 如果返回的错误为Mil说明文件或文件夹存在
  - 如果返回的错误类型使用os.IsNotExisto(）判断为true，说明文件或文件夹不存在
  - 如果返回的错误为其它类型，则不确定是否在存在
- 案例1

```go
package main

import (
	"fmt"
	"os"
)

func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	return !os.IsNotExist(err)
}

func main() {
	filename := "example.txt"

	if fileExists(filename) {
		fmt.Println("File exists.")
	} else {
		fmt.Println("File does not exist.")
	}
}
```

- 案例2

```go
package main

import (
	"errors"
	"fmt"
	"os"
)

// 自定义错误类型
type FileNotFoundError struct {
	FileName string
}

func (e *FileNotFoundError) Error() string {
	return fmt.Sprintf("文件 '%s' 不存在", e.FileName)
}

// 读取文件内容，可能返回文件不存在错误
func readFileContent(fileName string) (string, error) {
	content, err := os.ReadFile(fileName)
	if err != nil {
		// 如果是文件不存在的错误，则返回自定义的错误类型
		// errors.Is 是 Go 语言标准库中用于检查错误链中是否包含特定错误的函数
		// err：要检查的错误。
		// target：目标错误，用于检查是否是 err 错误链中的错误
		// errors.Is 函数的返回值是一个布尔值，表示 err 是否包含 target 错误

		// os.ErrNotExist 是一个变量，表示文件或目录不存在的错误
		// 使用指针的方式是为了确保错误链的正确形成和正确的错误匹配
		if errors.Is(err, os.ErrNotExist) {
			return "", &FileNotFoundError{FileName: fileName}
		}
		// 其他类型的错误直接返回
		return "", err
	}
	return string(content), nil
}

func main() {
	var fileName string

	fmt.Print("请输入文件名: ")
	fmt.Scanln(&fileName)

	content, err := readFileContent(fileName)
	if err != nil {
		// 处理错误
		switch err.(type) {
		case *FileNotFoundError:
			fmt.Println("文件不存在错误:", err)
		default:
			fmt.Println("未知错误:", err)
		}
	} else {
		// 处理成功的情况
		fmt.Println("文件内容:", content)
	}
}

```



### 15.3 目录操作

#### 15.3.1 创建目录

- 在Go语言中，`os.Mkdir` 函数用于创建一个新的目录

```go
func Mkdir(name string, perm FileMode) error
// name 表示要创建的目录的路径。
// perm 表示新目录的权限（文件权限位），通常以八进制表示，比如 0755
```

- 示例

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 要创建的目录路径
	dirName := "new_directory"

	// 创建目录，权限设置为 0755
	err := os.Mkdir(dirName, 0755)
	if err != nil {
		// 处理错误
		fmt.Println("无法创建目录:", err)
		return
	}

	fmt.Printf("目录 %s 创建成功\n", dirName)
}
```

- 创建多层嵌套的目录
  - `os.MkdirAll` 函数用于递归创建目录及其所有父目录。如果指定的目录路径中的某些目录不存在，它会自动创建这些目录

```go
func MkdirAll(path string, perm FileMode) error
// path 表示要创建的目录的路径，可以包含多层嵌套的目录结构。
// perm 表示新目录的权限（文件权限位），通常以八进制表示，比如 0755
```

- 示例

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 要创建的目录路径，包含多层嵌套的目录结构
	dirPath := "parent/child/grandchild"

	// 创建目录，递归创建所有父目录
	err := os.MkdirAll(dirPath, 0755)
	if err != nil {
		// 处理错误
		fmt.Println("无法创建目录:", err)
		return
	}

	fmt.Printf("目录 %s 及其所有父目录创建成功\n", dirPath)
}
```

- 批量创建目录
  - 如果需要批量创建目录，即在同一级别创建多个目录，你可以使用循环结构来批量调用 `os.Mkdir` 或 `os.MkdirAll` 函数

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 要创建的目录列表
	directories := []string{"dir1", "dir2", "dir3", "dir4"}

	// 遍历目录列表，逐个创建目录
	for _, dir := range directories {
		err := os.Mkdir(dir, 0755)
		if err != nil {
			// 处理错误
			fmt.Printf("无法创建目录 %s: %s\n", dir, err)
		} else {
			fmt.Printf("目录 %s 创建成功\n", dir)
		}
	}
}
```

- 创建临时目录

```go
package main

import (
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
)

func main() {
	content := []byte("temporary file's content")
	dir, err := ioutil.TempDir("", "example")
	if err != nil {
		log.Fatal(err)
	}

	defer os.RemoveAll(dir) // clean up

	tmpfn := filepath.Join(dir, "tmpfile")
	if err := ioutil.WriteFile(tmpfn, content, 0666); err != nil {
		log.Fatal(err)
	}
}

```



#### 15.3.2 遍历目录

- 在go语言中遍历目录和文件可以使用filepath.Walk, `filepath.Walk` 函数用于递归遍历指定目录及其子目录下的所有文件和子目录。它接受一个目录路径和一个函数作为参数，然后会对指定目录下的所有文件和子目录调用该函数

```go
func Walk(root string, walkFn WalkFunc) error
// root 是要遍历的目录的路径。
// walkFn 是一个回调函数，它接受三个参数：当前访问的文件或目录的路径、文件信息（os.FileInfo 类型）、遍历过程中可能出现的错误。可以在这个回调函数中自定义处理文件和目录
```

- 示例

```go
package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func visit(path string, info os.DirEntry, err error) error {
	if err != nil {
		fmt.Println("遍历时发生错误:", err)
		return err
	}
	if info.IsDir() {
		fmt.Printf("目录: %s\n", path)
	} else {
		fmt.Printf("文件: %s\n", path)
	}
	return nil
}

func main() {
	root := "." // 遍历当前目录
	err := filepath.WalkDir(root, visit)
	if err != nil {
		fmt.Println("遍历目录时发生错误:", err)
	}
}

```

> - `os.ReadDir` 函数用于读取指定目录下的所有文件和子目录的条目信息。返回的是一个 `[]os.DirEntry` 切片，其中每个元素都是 `os.DirEntry` 接口类型的实例
> - `os.DirEntry` 是Go语言中引入的一个接口类型，用于表示目录中的条目（文件或子目录）。它提供了访问文件信息和目录条目名称的方法。
>
> ```go
> os.DirEntry 接口包含以下方法:
> 
> // Name() string：返回目录条目的名称（文件名或子目录名）。
> // IsDir() (bool, error)：返回目录条目是否是一个子目录。如果是子目录，返回 true；如果是文件或其他类型的条目，返回 false。
> // Type() (os.FileMode, error)：返回目录条目的类型（文件类型的权限位），比如文件、目录等。
> // Info() (os.FileInfo, error)：返回目录条目的文件信息（os.FileInfo 接口类型），可以获取更多的文件信息，如文件大小、修改时间等
> ```
>
> - 示例
>
> ```go
> package main
> 
> import (
> 	"fmt"
> 	"os"
> )
> 
> func main() {
> 	dir := "." // 当前目录
> 
> 	// 读取目录的条目信息
> 	dirEntries, err := os.ReadDir(dir)
> 	if err != nil {
> 		fmt.Println("无法读取目录条目:", err)
> 		return
> 	}
> 
> 	// 遍历目录的条目并输出信息
> 	for _, entry := range dirEntries {
> 		name := entry.Name()
> 		info, err := entry.Info()
> 		if err != nil {
> 			fmt.Println("无法获取文件信息:", err)
> 			continue
> 		}
> 		isDir := info.IsDir()
> 		fileMode := info.Mode()
> 		fileSize := info.Size()
> 		modTime := info.ModTime()
> 
> 		fmt.Printf("名称: %s, 是否是目录: %t, 文件类型: %s, 文件大小: %d字节, 修改时间: %s\n", name, isDir, fileMode, fileSize, modTime)
> 	}
> }
> ```

#### 15.3.3 目录判断

- 判断目录是否存在:

  - go判断文件夹是否存在的方法为使用os.Stat（）函数返回的错误值进行判断：

    - 如果返回的错误为nil说明文件或文件夹存在

    - 如果返回的错误类型使用os.IsNotExisto(）判断为true，说明文件或文件夹不存在

    - 如果返回的错误为其它类型，则不确定是否在存在

    - 判断是否为目录
      - 在Go语言中，可以使用 `os.Stat` 函数获取文件或目录的信息，然后通过 `FileInfo` 接口的 `IsDir()` 方法判断是否为目录

```go
package main

import (
	"fmt"
	"os"
)

func directoryExists(dirname string) bool {
	info, err := os.Stat(dirname)
	if os.IsNotExist(err) {
		return false
	}
	return info.IsDir()
}

func main() {
	dirname := "example_directory"

	if directoryExists(dirname) {
		fmt.Println("Directory exists.")
	} else {
		fmt.Println("Directory does not exist.")
	}
}
```



- 判断是否为目录
  - 在Go语言中，可以使用 `os.Stat` 函数获取文件或目录的信息，然后通过 `FileInfo` 接口的 `IsDir()` 方法判断是否为目录

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	path := "github.com" // 替换为你要判断的目录路径

	// 获取文件或目录的信息
	fileInfo, err := os.Stat(path)
	if err != nil {
		fmt.Println("无法获取文件或目录信息:", err)
		return
	}

	// 判断是否为目录
	if fileInfo.IsDir() {
		fmt.Printf("%s 是一个目录\n", path)
	} else {
		fmt.Printf("%s 不是一个目录\n", path)
	}
}

```

- 判断是否为空目录
  - 在Go语言中，可以使用 `os.ReadDir` 函数读取目录下的所有文件和子目录的条目信息，然后判断是否有文件或子目录。如果一个目录下没有文件和子目录，那么它就是一个空目录

```go
package main

import (
	"fmt"
	"os"
)

func isEmptyDir(dirPath string) (bool, error) {
	entries, err := os.ReadDir(dirPath)
	if err != nil {
		return false, err
	}

	return len(entries) == 0, nil
}

func main() {
	dirPath := "github.com" // 替换为你要判断的目录路径

	isEmpty, err := isEmptyDir(dirPath)
	if err != nil {
		fmt.Println("无法判断目录是否为空:", err)
		return
	}

	if isEmpty {
		fmt.Printf("%s 是一个空目录\n", dirPath)
	} else {
		fmt.Printf("%s 不是一个空目录\n", dirPath)
	}
}
```

- 判断目录是否存在
  - 在Go语言中，可以使用 `os.Stat` 函数来判断目录是否存在。如果目录存在，`os.Stat` 函数会返回目录的信息；如果目录不存在，`os.Stat` 函数会返回一个错误

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	dirPath := "example_directory" // 替换为你要判断的目录路径

	_, err := os.Stat(dirPath)
	if err == nil {
		fmt.Printf("目录 %s 存在\n", dirPath)
	} else if os.IsNotExist(err) {
		fmt.Printf("目录 %s 不存在\n", dirPath)
	} else {
		fmt.Printf("无法确定目录 %s 是否存在: %v\n", dirPath, err)
	}
}

```

#### 15.3.4 删除目录

- 在Go语言中，可以使用 `os.RemoveAll` 函数来删除目录及其所有子目录和文件。该函数会递归地删除目录及其内容

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	dirPath := "example_directory" // 替换为你要删除的目录路径

	err := os.RemoveAll(dirPath)
	if err != nil {
		fmt.Printf("无法删除目录 %s: %v\n", dirPath, err)
	} else {
		fmt.Printf("目录 %s 删除成功\n", dirPath)
	}
}
```

### 15.4 JSON文件处理

#### 15.4.1 JSON文件介绍

- `JSON`的全称是(Javascript Object Notation), 是一种格式存储数据的文件。JSON是一种比XML更轻量级的数据交换格式，易于阅读和编写的同时，也易于程序的解析和生成。此外，虽然JSON源于JS， 由于JSON采用了完全独立于语言的文本格式,  它由键值对组成，数据是以逗号分隔，键值对是以冒号分隔

```json
{
    "key1": "value1",
    "key2": "value2",
    "key3": ["item1", "item2"],
    "key4": {
        "nestedKey1": "nestedValue1",
        "nestedKey2": "nestedValue2"
    }
}
```

- JSON只支持六种数据类型

```json
// 数字(number)：有十进制和科学记数学两种表示方式。
// 字符串(string)：使用双引号表示的Unicode字符序列。
// 布尔(bool)：true或者false。
// 对象(object)：使用花括号({})括起来的一个或多个键值对(key/value)，用逗号(,)隔开，最后一个键值对后面不能有逗号，键(key)必是双引号("")引起来的字符串，而值则可以是任意类型(如：布尔、数字、对象、数组、字符串)。
// 数组(array)：使用中括号([])括起来的值的集合，这些值可是任意类型(布尔、数字、对象、数组、字符串)。
// null:空值
```

- JSON类型与Go数据类型的对应关系：

```go
// Go的`boolean`对应JSON的bool类型
// Go的整型与浮点型对应JSON的number类
// Go的map和struct对应JSON的object，map的key必须是字符串
// Go的切片与数组对应JSON的array
// Go的`chan`与函数等复杂的类型不能作为JSON的值
```

#### 15.4.2 JSON文件基本操作

##### 15.4.2.1 序列化

- 将go语言数据转化成JSON格式

- Go语言在`encoding/json`包中提供了JSON数据序列化与反序列化的操作，最简单直接就是调用`Marshal`把一个Go的数据序列化为一个JSON数据和调用`Unmarshal`对JSON数据反序列化

```go
// func Marshal(v interface{}) ([]byte, error) 
// Marshal()函数可以接受任意值，并返回JSON化的字节数组与一个error类型


package main
import (
	"encoding/json"
	"fmt"
)
func main() {
	m := map[string]int{"Go入门": 1, "Go Ation": 2, "Go从入门到精通": 3, "Go高级编程": 4}
	data, err := json.Marshal(m)
	if err != nil {
		panic(err)
	}
    //转换为string并输出
	fmt.Println(string(data)) 
}
```

- 面调用`Marshal`函数序列化的数据输出了一行，如果数据太长，则不利于我们阅读，要想输出的JSON数据格式更友好一点，可以用`MarshalIndent`函数

```go
// func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)
// 相比于Marshal函数，MarshalIndent函数可以接收一个prefix和indent，用于设置输出JSON每一行的前缀和首行缩进

package main
import (
	"encoding/json"
	"fmt"
)
func main() {
	m := map[string]int{"Go入门": 1, "Go Ation": 2, "Go从入门到精通": 3, "Go高级编程": 4}
    //设置prefix为空，indent为tab
	data, err := json.MarshalIndent(m, "", "\t")
	if err != nil {
		panic(err)
	}
	fmt.Println(string(data))
}
```

##### 15.4.2.2 反序列化

- 将JSON数据转化成go语言数据格式

- `json`包的`Unmarshal()`函数作用与`Marshal`刚好相反，用于将一个`JSON`数据格式反序列化到一个我们定义好的Go类型变量中

```go
package main
import (
	"encoding/json"
	"fmt"
)
type Book struct {
	BookName string `json:"name"`
	Number   int    `json:"num"`
}
func main() {
	jsonStr := `[{"name":"Go入门","num": 1}, {"name":"Go Ation","num": 2}, {"name":"Go从入门到精通","num": 3}, {"name":"Go高级编程","num": 4}]`
	var books []Book
	err := json.Unmarshal([]byte(jsonStr), &books)
	if err != nil {
		panic(err)
	}
	fmt.Println(books)
}
```

##### 15.4.2.3 自定义JSON序列化（Marshal）和反序列化（Unmarshal）

- 如果是自定义的数据类型，我们可以实现`Marshaler`接口和`Unmarshaler`接口的方法，这两个接口的定义如下

```go
type Unmarshaler interface {
	UnmarshalJSON([]byte) error
}
type Marshaler interface {
	MarshalJSON() ([]byte, error)
}
```

- 当调用`Marshal`函数序列化时，会调用`MarshalJSON()`函数，我们可以在该函数中自定义序列化的逻辑

```go
package main

import (
	"encoding/json"
	"fmt"
	"strings"
)

// Reason 是一个自定义的枚举类型，表示季节
type Reason uint8

const (
	Unknown Reason = iota // 默认值为0，代表未知季节
	Spring               // 春季，值为1
	Summer               // 夏季，值为2
	Autumn               // 秋季，值为3
	Winter               // 冬季，值为4
)

// UnmarshalJSON 是自定义的反序列化逻辑，用于将JSON字符串转换为 Reason 类型的值
func (r *Reason) UnmarshalJSON(b []byte) error {
	var s string
	if err := json.Unmarshal(b, &s); err != nil {
		return err
	}
	switch strings.ToLower(s) {
	default:
		*r = Unknown
	case "spring":
		*r = Spring
	case "summer":
		*r = Summer
	case "autumn":
		*r = Autumn
	case "winter":
		*r = Winter
	}
	return nil
}

// MarshalJSON 是自定义的序列化逻辑，用于将 Reason 类型的值转换为JSON字符串
func (r Reason) MarshalJSON() ([]byte, error) {
	var s string
	switch r {
	default:
		s = "unknown"
	case Spring:
		s = "spring"
	case Summer:
		s = "summer"
	case Autumn:
		s = "autumn"
	case Winter:
		s = "winter"
	}
	return json.Marshal(s)
}

func main() {
	// 创建一个 Reason 类型的切片，包含了四个季节的值
	r := []Reason{Spring, Summer, Autumn, Winter}

	// 将切片 r 序列化为JSON字符串
	data, err := json.Marshal(r)
	if err != nil {
		panic(err)
	}
	fmt.Println("序列化后的JSON字符串:", string(data))

	// 定义一个JSON字符串
	jsonStr := `["winter","spring","test"]`

	// 将JSON字符串反序列化为 Reason 类型的切片
	var r2 []Reason
	err2 := json.Unmarshal([]byte(jsonStr), &r2)
	if err2 != nil {
		panic(err2)
	}
	fmt.Println("反序列化后的切片:", r2)
}
```

##### 15.4.2.4 Encoder与Decoder

- 调用`Marshal`只会返回一个字节数组，`Unmarshal`函数只能传入一个字节数组，如果我们想将序列化的数据写入到不同的地方(比如保存到一个文件中)，或者想从不同地方读取JSON数据(比如从一个文件读取)，那么用`Encoder`和`Decoder`会更方便

- 在Go语言的`encoding/json`包中，`Encoder` 和 `Decoder` 分别提供了将数据编码为JSON格式和将JSON格式解码为数据的功能。这两个类型实现了 `io.Writer` 和 `io.Reader` 接口，分别用于写入JSON数据和读取JSON数据

- **Encoder**

  `json.Encoder` 是一个结构体类型，用于将数据编码为JSON格式并写入输出流（例如文件、网络连接等）。它提供了 `Encode` 方法来将数据编码为JSON并写入输出流

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
)

type Person2 struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	// 创建一个Person结构体实例
	person := Person2{
		Name: "Alice",
		Age:  30,
	}

	// 打开文件，准备写入JSON数据
	file, err := os.Create("person.json")
	if err != nil {
		fmt.Println("无法创建文件:", err)
		return
	}
	defer file.Close()

	// 创建JSON编码器
	encoder := json.NewEncoder(file)

	// 使用编码器将数据编码为JSON并写入文件
	err = encoder.Encode(person)
	if err != nil {
		fmt.Println("JSON编码失败:", err)
		return
	}

	fmt.Println("JSON数据已写入文件")
}
```

- **Decoder**
  - `json.Decoder` 是一个结构体类型，用于从输入流（例如文件、网络连接等）中读取JSON数据并解码为Go语言中的数据结构。它提供了 `Decode` 方法来将JSON数据从输入流解码为Go语言的数据

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
)

type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func main() {
	// 打开文件，准备读取JSON数据
	file, err := os.Open("person.json")
	if err != nil {
		fmt.Println("无法打开文件:", err)
		return
	}
	defer file.Close()

	// 创建JSON解码器
	decoder := json.NewDecoder(file)

	// 创建一个Person结构体实例，用于存储解码后的数据
	var person Person

	// 使用解码器将JSON数据从文件中解码为Person结构体
	err = decoder.Decode(&person)
	if err != nil {
		fmt.Println("JSON解码失败:", err)
		return
	}

	fmt.Println("解码得到的Person结构体:", person)
}
```

## 16. 并发编程

- 之前我们写的程序都是单任务执行的,也就是说一个函数或者方法执行完成后另一个函数和方法才能执行,但相让这是不符合实际业务场景的,随着硬件技术的发展,多核CPU的出现,单任务处理已经无法高效的利用cpu性能.为了更好的利用系统资源,我们就需要进程多任务执行

### 16.1 相关概念叙述

#### 16.1.1 进程(Process)

- 一个正在运行的程序或者软件就是一个进程，它是操作系统进行资源分配的基本单位，也就是说每启动一个进程，操作系统都会给其分配一定的运行资源(内存资源)保证进程的运行

> 一个程序运行后至少有一个进程，一个进程默认有一个线程，进程里面可以创建多个线程，线程是依附在进程里面的，没有进程就没有线程

- 进程的状态

![image-20231129220911863](https://cloud.006288.xyz/PicGo//image-20231129220911863.png)

- 进程补充知识:
  - 孤儿进程: 父进程在子进程结束之前结束,则子进程变成了孤儿进程
  - 僵尸进程: 父进程未回收子进程残留在内存中的资源

- 进程的注意点:
  - **进程之间通常不会直接共享全局变量**。进程是操作系统中独立运行的程序实例，每个进程都有自己的地址空间，包括代码、数据、堆栈等。由于每个进程有独立的地址空间，它们不会直接共享全局变量
  - **主进程会等待所有的子进程执行结束再结束**。为了保证子进程能够正常的运行，主进程会等所有的子进程执行完成以后再销毁，设置守护主进程的目的是主进程退出子进程销毁，不让主进程再等待子进程去执行

#### 16.1.2 线程

- 线程是进程中执行代码的一个分支，每个执行分支（线程）要想工作执行代码需要cpu进行调度 ，也就是说线程是cpu调度的基本单位，每个进程至少都有一个线程，而这个线程就是我们通常说的主线程
- 它们共享进程的资源，但拥有自己的执行流。线程之间可以并发执行，但它们共享同一进程的内存空间

![image-20231129221159775](https://cloud.006288.xyz/PicGo//image-20231129221159775.png)

- 进程与线程的区别:
  - **本质区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
  - **包含关系**：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
  - **资源开销**：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
  - **影响关系**：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮

#### 16.1.3 并发

- 并发是指系统中存在多个独立的活动单元（例如进程、线程、任务），在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行。并发可以从微观和宏观两个层面来理解    ("假"的多任务)
  - **微观层面（Low-Level）：**
    - 在微观层面，我们关注的是独立执行单元（例如线程）之间的交替执行。微观层面的并发主要涉及到这些执行单元在同一时间片内的切换，即每个执行单元都有机会执行一些指令，然后切换到下一个执行单元。这通常是通过操作系统的调度器来实现的
  - **宏观层面（High-Level）：**
    - 在宏观层面，我们关注的是整个系统中多个任务或活动的同时进行。这可能涉及到多个独立的进程、线程或其他执行单元。在宏观层面，我们不太关心每个执行单元的微观行为，而是关注它们在整体上是如何协同工作的

#### 16.1.4 并行

- 并行是一种更为严格的并发形式，它涉及在同一时刻执行多个任务，通常是通过多个处理单元（如多核处理器）同时执行。在并行系统中，每个处理单元都有自己的执行环境，独立地执行任务，而不会受到其他处理单元的影响，所以无论从微观还是从宏观来看，二者都是一起执行的   (真正的多任务)
  - **微观层面（Low-Level）：**
    - 在微观层面，并行涉及到真正的同时执行，即多个指令在同一时刻内在不同的处理单元上执行。这可以通过硬件层面的多核处理器来实现，每个核心都能够独立地执行指令。在这种情况下，不同的处理单元之间可能通过共享内存或其他通信机制进行交互。
  - **宏观层面（High-Level）：**
    - 在宏观层面，系统中的多个任务或活动能够在同一时间段内真正地并行执行。这可能涉及到多个独立的进程、线程或任务，它们在不同的处理单元上运行。在这个层面，我们关注整个系统在同一时刻内执行多个任务，以提高整体性能

- 并发和并行的区别:
  - 相同点：
    - 并发和并行的目标都是最大化CPU的使用率，将cpu的性能充分压榨出来。
  - 不同点：
    - 并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在
    - 并行要求程序能够同时执行多个操作，而并发只是要求程序“看着像是”同时执行多个操作，其实是交替执行。

#### 16.1.5 主线程/协程

- **主线程**是程序启动时默认创建的线程，负责调用 `main` 函数。在 Go 语言中，`main` 函数运行在主线程中。主线程执行的同时，你可以通过 `go` 关键字启动额外的协程，使得程序能够以并发的方式执行
- **协程**是 Go 语言中的并发执行单元。它是由 Go 运行时环境（goroutine scheduler）管理的轻量级线程。与传统的线程相比，独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的, 协程的创建和销毁更为高效，且占用的资源更少。通过 `go` 关键字，可以启动一个新的协程来并发执行函数

- go语言协程的特点:
  - **轻量级：** 协程的创建和销毁成本相对较低，一个程序可以启动成千上万个协程而不会消耗大量资源。
  - **协作式调度：** Go 运行时环境使用协作式调度（cooperative scheduling），而不是抢占式调度。协程之间通过协作而不是强制方式来进行切换，避免了传统线程的锁和同步问题。
  - **共享内存通信：** 在协程之间共享数据，通常通过共享内存进行通信，但通过通道（Channel）等机制可以实现更安全和更高效的通信。
  - **简化并发编程：** Go 语言的并发模型设计旨在简化并发编程，提供了易于使用的工具和机制，例如协程、通道等

### 16.2 go语言协程(goroutine)

#### 16.2.1 goroutine介绍

- `goroutine` 是 Go 语言中的一种轻量级线程，由 Go 运行时环境（Go runtime）进行管理。Goroutine 是 Go 语言并发模型的核心，它相比于传统的线程更轻量、更易用，并且能够高效地利用多核处理器

- goroutine特性介绍:
  - **轻量级：**
    - Goroutine 是轻量级的执行单元，其创建和销毁的开销比传统线程要小得多。一个典型的 Go 程序可能会同时运行成千上万个 Goroutines，而这在传统的线程模型中可能会导致性能下降。
  - **并发：**
    - Goroutine 的设计目标是实现高并发。多个 Goroutines 可以在同一时间段内并发执行，通过 Go 运行时环境的调度器（scheduler）来进行协调。这种并发模型允许程序以更加简单和高效的方式处理大量的并发任务。
  - **与操作系统线程的关系：**
    - Goroutines 是由 Go 运行时环境映射到底层的操作系统线程上的。一个操作系统线程可以托管多个 Goroutines，这些 Goroutines 可以在一个或多个线程上并发执行。Go 运行时环境负责 Goroutines 的调度和管理，使得程序员不需要过多关注底层线程的细节。
  - **Go 运行时调度器：**
    - Go 运行时环境包含了一个调度器，负责管理和调度 Goroutines。调度器使用一种称为 M:N 调度的策略，即 M 个 Goroutines 通过 N 个操作系统线程来执行。这种策略使得 Goroutines 能够高效地利用系统资源。
  - **简单的并发模型：**
    - 使用 Goroutine 可以很容易地实现并发程序。通过使用 `go` 关键字，可以启动新的 Goroutine，而不需要显式地创建和管理线程。这使得并发程序的编写更加简洁、清晰，并减少了因线程管理而引起的错误。
  - **通信通过共享内存：**
    - Goroutines 之间的通信通过共享内存来实现，但 Go 提供了一些用于在 Goroutines 之间进行同步和通信的工具，如通道（channel）。通过通道，Goroutines 可以安全地传递数据和同步执行

- 使用goroutine创建并发示例

![image-20231129232735145](https://cloud.006288.xyz/PicGo//image-20231129232735145.png)

```go
package main

import (
	"fmt"
	"time"
)

func Task1() {
	for i := 1; i <= 10; i++ {
		fmt.Println("This is Task1......")
		time.Sleep(time.Second)
	}
}

func Task2() {
	for i := 1; i <= 10; i++ {
		fmt.Println("This is Task2......")
		time.Sleep(time.Second)
	}

}

func main() {
	// 传统单任务执行
	//for i := 1; i <= 10; i++ {
	//	fmt.Println("This is MainTask......")
	//}
	//Task1()
	//Task2()

	// 并发执行
	go Task1()
	go Task2()

	for i := 1; i <= 10; i++ {
		fmt.Println("This is MainTask......")
		time.Sleep(time.Second)
	}

}
```

- 主进程退出后,其他协程也会自动退出

```go
package main

import (
	"fmt"
	"time"
)

func Task1() {
	for i := 1; i <= 10; i++ {
		fmt.Println("This is Task1......")
		time.Sleep(time.Second)
	}
}

func Task2() {
	for i := 1; i <= 10; i++ {
		fmt.Println("This is Task2......")
		time.Sleep(time.Second)
	}

}

func main() {
	go Task1()
	go Task2()

	fmt.Println("This is MainTask......")
}
```

#### 16.2.2 goroutine调度

- 在go语言中使用CSP模型来处理并发问题。CSP 全称是 “Communicating Sequential Processes”，被 Tony Hoare 在1978年发表的***\*[论文](https://link.zhihu.com/?target=chrome-extension%3A//ikhdkkncnoglghljlkmcimlnlhkeamad/pdf-viewer/web/viewer.html%3Ffile%3Dhttps%3A%2F%2Fwww.cs.cmu.edu%2F~crary%2F819-f09%2FHoare78.pdf)\****中提出。是用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型

- Go 语言的调度器采用了 M:N 调度模型，其中 M 个 Goroutines 由 N 个 OS 线程执行。这种模型使得 Go 语言能够充分利用多核处理器，并通过 Goroutines 和调度器的协同工作来实现高效的并发。 
- `MPG`（M，P，G）是调度器、处理器和 Goroutine 之间的关系。这三者共同构成了 Go 语言的并发执行模型。M、P、G 的关系是 Go 语言并发模型的核心，使得并发编程变得更加容易和高效
- 调度器负责协调 M、P 和 G，以确保 Goroutines 在适当的时机被执行。调度器会在 Goroutines 阻塞（比如等待 I/O 操作、休眠）或者某个 M 空闲时，将 Goroutine 调度到其他 M 上执行。调度器还负责 Goroutines 的创建、销毁以及负载均衡
- 调度模型的三要素
  - **M（Machine）：**
    - `M` 代表 Machine，也称为调度器（scheduler）。M 是一个调度线程，负责在处理器上执行 Goroutines。Go 运行时系统会创建多个 M，一个 M 可以与一个底层的操作系统线程关联，M 负责调度多个 Goroutines 在处理器上并发执行。M 的数量会根据系统负载和需要进行动态调整。
  - **P（Processor）：**
    - `P` 代表 Processor，也称为处理器。P 是执行用户代码的上下文，它与一个 M 相关联。每个 M 关联一个 P，而每个 P 负责管理 Goroutines 的执行。一个程序可以有多个 P，以充分利用多核处理器的性能。P 的数量也可以根据系统负载动态调整。
  - **G（Goroutine）：**
    - `G` 代表 Goroutine，是 Go 语言中的轻量级线程。Goroutines 是并发执行的基本单位，每个 Goroutine 都由一个 G 结构体表示。Goroutines 由用户代码创建，它们在 M 上执行，由 P 进行管理和调度

![image-20231206204721061](https://cloud.006288.xyz/PicGo//image-20231206204721061.png)

- 调度的基本过程

```go
/Goroutine 创建：
当一个 Goroutine 准备好执行时，调度器会选择一个可用的 M，将该 Goroutine 放到 M 的队列中。

处理器 P 状态检查：
调度器会检查 P 的状态。如果 P 处于空闲状态，可以直接用于执行 Goroutines。如果 P 处于忙碌状态，可能需要创建新的 P。

P 的创建和关联 M：
如果当前没有可用的 P，调度器会创建一个新的 P，并将其关联到一个 M 上。这样，新的 P 就可以用于执行 Goroutines。

Goroutine 的分配和执行：
调度器会选择一个 M，并将其关联的 P 设置为当前 P，然后将 Goroutine 从 M 的队列中分配给该 P。这个 P 现在是当前的执行上下文，即 P 上的 M 将执行 Goroutine。

调度器的协调和切换：
调度器使用协作式调度，它在 Goroutine 主动让出执行权时进行切换。调度器会在合适的时机（例如发生系统调用、发生阻塞操作、或者达到时间片末尾等情况）切换到另一个 Goroutine。这样可以避免显式的锁和线程切换，提高并发性能。

Goroutine 的状态变化：
Goroutines 可能经历不同的状态，包括运行态、等待状态、阻塞状态等。调度器负责管理这些状态的转换。

P 的释放：
当一个 Goroutine 执行完成时，P 会释放，如果没有其他 Goroutines 可执行，P 可能变为空闲状态。

M 的释放和回收：
当 M 不再需要时，它可能会被释放和回收。这样可以动态调整 M 的数量以适应系统负载
```

#### 16.2.3 goroutine并发资源竞争

- 有并发，就有资源竞争，如果两个或者多个 goroutine 在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写时，就会处于相互竞争的状态，这就是并发中的资源竞争

- 并发问题一般有下面这几种：
  - **数据竞争**。简单来说就是两个或多个线程同时读写某个变量，造成了预料之外的结果。
  - **原子性**。在一个定义好的上下文里，原子性操作不可分割。上下文的定义非常重要。有些代码，你在程序里看起来是原子的，如最简单的 i++，但在机器层面看来，这条语句通常需要几条指令来完成（Load，Incr，Store），不是不可分割的，也就不是原子性的。原子性可以让我们放心地构造并发安全的程序。
  - 内存访问同步。代码中需要控制同时只有一个线程访问的区域称为临界区。Go 语言中一般使用 sync 包里的 Mutex 来完成同步访问控制。锁一般会带来比较大的性能开销，因此一般要考虑加锁的区域是否会频繁进入、锁的粒度如何控制等问题。
  - **死锁**。在一个死锁的程序里，每个线程都在等待其他线程，形成了一个首尾相连的尴尬局面，程序无法继续运行下去。
  - 活锁。想象一下，你走在一条小路上，一个人迎面走来。你往左边走，想避开他；他做了相反的事情，他往右边走，结果两个都过不了。之后，两个人又都想从原来自己相反的方向走，还是同样的结果。这就是活锁，看起来都像在工作，但工作进度就是无法前进。
  - **饥饿**。并发的线程不能获取它所需要的资源以进行下一步的工作。通常是有一个非常贪婪的线程，长时间占据资源不释放，导致其他线程无法获得资源

##### 16.2.3.1 资源竞争分析

- 场景需求:
  // 使用协程计算1~20的阶乘
  // 将结果写入到一个map中

```go
package main

import (
	"fmt"
	"time"
)

var (
	resultmap = make(map[int]int, 10)
)

func jiecheng(num int) {
	result := 1
	for i := 1; i <= num; i++ {
		result *= i
	}
	resultmap[num] = result
}

func main() {
	// 开启10个协程
	for i := 1; i <= 30; i++ {
		go jiecheng(i)
	}

	// 休眠10秒保证主线程不会提前退出,后边采用其他方式处理
	time.Sleep(time.Second * 10)

	// 遍历结果
	for my_key, my_value := range resultmap {
		fmt.Printf("%d的阶乘为: %d \n", my_key, my_value)
	}
}
```

- 运行结果:

![image-20231206220756280](https://cloud.006288.xyz/PicGo//image-20231206220756280.png)

- 运行结果分析:

> `go build -race` 是 Go 语言中用于启用数据竞争检测的编译选项。通过使用 `-race` 标志，Go 编译器会在生成的可执行文件中插入一些额外的代码，用于检测并发程序中的数据竞争问题。
>
> 数据竞争是指两个或多个 Goroutines 在没有适当同步的情况下同时访问共享的变量，并且至少有一个是写入操作。这种情况可能导致不确定的行为，包括竞争条件、程序崩溃或不一致的结果

通过结果可以看到,程序存在2个资源竞争关系

![image-20231206225227229](https://cloud.006288.xyz/PicGo//image-20231206225227229.png)

##### 16.2.3.2 并发资源竞争解决

- 避免和解决资源竞争的一些方法

```go
//使用互斥锁
//使用读写锁
//使用通道
//使用原子操作
```

- 补充知识**: sync.WaitGroup**
  - `sync.WaitGroup` 是 Go 语言标准库中的一个同步原语，用于等待一组协程完成任务。它提供了一种简单的机制，可以阻塞主协程，直到所有的协程都执行完成, 而不会提前退出。
  - `sync.WaitGroup` 主要有三个方法：
    - **`Add(delta int)`：** 增加等待组的计数器。`delta` 参数可以是正数也可以是负数。通常在启动协程之前调用，以表示有多少个协程需要等待。
    - **`Done()`：** 减少等待组的计数器。在每个协程完成任务时调用，表示一个协程已经完成。
    - **`Wait()`：** 阻塞调用此方法的协程，直到等待组的计数器归零。一旦计数器为零，`Wait` 方法将返回，允许主协程继续执行

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func worker(id int, wg *sync.WaitGroup) {
	defer wg.Done() // 在函数执行完毕时减少等待组的计数

	fmt.Printf("Worker %d starting\n", id)
	time.Sleep(time.Second)
	fmt.Printf("Worker %d done\n", id)
}

func main() {
	var wg sync.WaitGroup

	for i := 1; i <= 5; i++ {
		wg.Add(1) // 每启动一个 Goroutine，增加等待组的计数
		go worker(i, &wg)
	}

	// 等待所有 Goroutines 完成
	wg.Wait()

	fmt.Println("All workers have completed")
}
```

###### 15.2.3.2.1 互斥锁(Mutex)

- 也称写锁

- 通过在访问共享资源的代码块上使用互斥锁，确保在同一时刻只有一个 Goroutine 能够访问共享资源

```go
var mu sync.Mutex

// 在读写共享资源之前加锁
mu.Lock()

// 完成后解锁
mu.Unlock()
```

- 示例

![image-20231206235035001](https://cloud.006288.xyz/PicGo//image-20231206235035001.png)

###### 15.2.3.2.2 读写锁(RWMutex)

- 使用读写锁可以允许多个 Goroutines 同时读取共享资源，但只有一个 Goroutine 能够进行写操作。这可以提高读取性能

```go
var rwmu sync.RWMutex
var sharedResource int

// 读操作使用RLock
rwmu.RLock()
value := sharedResource
rwmu.RUnlock()

// 写操作使用Lock
rwmu.Lock()
sharedResource = 42
rwmu.Unlock()
```

- 读写锁使用案例

```go
package main

import (
	"fmt"
	"sync"
)

var (
	resultmap = make(map[int]int, 30)
	my_lock   sync.RWMutex
	wg        sync.WaitGroup
)

func jiecheng(num int) {
	defer wg.Done()
	result := 1
	for i := 1; i <= num; i++ {
		result *= i
	}
	my_lock.Lock()
	resultmap[num] = result
	my_lock.Unlock()
}

func main() {
	// 开启30个协程
	for i := 1; i <= 30; i++ {
		wg.Add(1)
		go jiecheng(i)
	}

	wg.Wait()

	my_lock.RLock()
	// 遍历结果
	for my_key, my_value := range resultmap {
		fmt.Printf("%d的阶乘为: %d \n", my_key, my_value)
	}
	my_lock.RUnlock()

}
```

> 通道和原子操作处理资源竞争,我们单独一章来讲

### 16.3 通道(channel)

- 管道（Channel）是 Go 语言中用于在不同 goroutine 之间进行通信的重要机制。它提供了一种安全、同步的方式来传递数据
- 如果说 goroutine 是 Go语言程序的并发体的话，那么 channels 就是它们之间的通信机制

#### 16.3.1 基本概念

- 管道是一种数据类型, 是一种通信机制, 它可以看作是一个先进先出（FIFO）的队列，数据从一个端口进入，从另一个端口出去
- 管道的类型： 在 Go 中有两种类型的管道，分别是无缓冲管道和有缓冲管道:
  - 无缓冲管道： 不存储任何元素，数据发送和接收操作是同步的，发送者会阻塞直到接收者准备好。
  - 有缓冲管道： 存储一定数量的元素，可以在缓冲未满时进行发送，缓冲未空时进行接收，发送和接收操作是异步的
- 管道方向： 管道可以有发送（write）和接收（read）两个方向，通过类型声明来指定

##### 16.3.1.1 管道创建

- 管道本身需要一个类型进行修饰，就像切片类型需要标识元素类型。通道的元素类型就是在其内部传输的数据类型，声明如下：
  - 管道声明
    - var 通道变量 chan 通道类型
      - 通道类型：通道内的数据类型。
      - 通道变量：保存通道的变量
  - 管道初始化(管道创建)
    - 管道是引用类型，需要使用 make 进行创建
    - 通道实例 := make(chan 数据类型)
      - 数据类型：通道内传输的元素类型。
      - 通道实例：通过make创建的通道句柄
- chan 类型的空值是 nil，声明后需要配合 make 后才能使用

```go
// 无缓存管道创建


var ch chan int      					// 声明一个传递int类型的channel, 值为nil
ch = make(chan int) 					// 使用内置函数make()初始化channel

ch := make(chan int)                    // 直接使用make创建管道

ch := make(chan interface{})         // 创建一个空接口类型的通道, 可以存放任意格式

type Equip struct{ /* 一些字段 */ }
ch := make(chan *Equip)             // 创建Equip指针类型的通道, 可以存放*Equip


// 有缓存管道创建
ch := make(chan int, bufferSize)    // 创建一个带有缓存的通道, bufferSize表示管道的缓冲容量，决定了可以存储在管道中的元素个数。如果 bufferSize 是 0，那么管道就是无缓冲的

ch := make(chan int, 10)
```

##### 16.3.1.2 管道读写和遍历

- 管道是双向可用的，在函数间传递时，可以通过操作符（<-）来控制管道的可读和可写

```go
ch <- value          // 将一个数据value写入至channel，这会导致阻塞，直到有其他goroutine从这个channel中读取数据
value := <-ch       // 从channel中读取数据，如果channel之前没有写入数据，也会导致阻塞，直到channel中被写入数据为止


func ChanParamRW(ch chan int) {
	// 管道可读写
}

func ChanParamR(ch <- chan int) {
	// 只能从管道读取数据
}

func ChanParaW(ch chan<- int) {
	// 只能向管道写入数据
}
```

- 通道关闭
  - 在 Go 语言中，通道的关闭是一种信号机制，用于通知接收方不再有数据将被发送到通道中。通道的关闭操作可以通过内置函数 `close()` 来完成
  - 通道一旦关闭，就不能再向其写入送数据，但可以继续从中读取数据
  - **关闭通道的时机**：
    - 通道的关闭时机通常由程序逻辑来决定。通常在生产者知道不再向通道发送数据的时候关闭通道
  - **闭通道的重要性**：
    - 通知接收者： 通过关闭通道，发送者可以通知接收者不再有数据将被发送。接收者在接收完通道中已有的数据后，通过判断通道是否关闭来确定是否继续等待。
    - 避免死锁： 关闭通道可以避免在遍历通道时发生死锁。通过关闭通道，遍历的 `for range` 循环会在通道为空时正常结束
  - 一个通道可以被多次关闭，但尝试关闭一个已经关闭的通道会引发运行时 panic。这是由于关闭一个已经关闭的通道可能是程序逻辑错误的结果。因此，在关闭通道之前，最好检查一下通道的状态，确保它还没有被关闭

```go
// 关闭通道
ch := make(chan int)
close(ch) // 关闭通道

// 判断通道是否已经关闭
// 使用多重返回值，可以判断一个通道是否已经关闭
value, ok := <-ch
if !ok {
    fmt.Println("通道已关闭")
}
```

- 通道遍历
  - 遍历通道可以使用 `for` 循环结合 `range` 关键字。通道的遍历通常在一个独立的 goroutine 中进行，这样可以避免主 goroutine 阻塞

```go
package main

import (
	"fmt"
	"sync"
)

var (
	wg2 sync.WaitGroup
)

func main() {
	ch := make(chan int)
	wg2.Add(1)
	go func() {
		defer wg2.Done()
		for i := 0; i <= 10; i++ {
			ch <- i

		}
		close(ch)
	}()

	go func() {
		for value := range ch {
			fmt.Println(value)
		}
	}()

	wg2.Wait()
}
```

##### 16.3.1.3 通道阻塞

- 在 Go 语言中，带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为 0 的带缓冲通道。通道阻塞是指在进行通道操作时程序无法继续执行的情况。通道阻塞可以发生在以下几种情况

  - **无缓冲管道：**
    - 当发送者发送数据时，它会阻塞直到有一个接收者准备好接收数据。
    - 当接收者接收数据时，它会阻塞直到有一个发送者准备好发送数据。
    - 这种同步的性质确保了数据的安全传递，保证发送和接收操作是一一对应的。

  - **有缓冲管道：**
    - 有缓冲的管道允许发送者在管道满之前发送多个数据，而接收者可以在管道空之前接收多个数据，从而实现异步通信。
      - 当缓冲满时，发送者会被阻塞，直到有接收者取走数据；
      - 当缓冲空时，接收者会被阻塞，直到有发送者发送数据

![image-20231208001536393](https://cloud.006288.xyz/PicGo//image-20231208001536393.png)

- 无缓存通道空数据读取阻塞
```go
package main

import "fmt"

func main() {
	// 创建一个无缓存的通道
	ch2 := make(chan int)

	value := <-ch2  // 只有读取没有写入

	fmt.Println(value)
}


// 输出---->
fatal error: all goroutines are asleep - deadlock!
```


  - 无缓存通道数据写入阻塞

```go
package main

func main() {
	// 创建一个无缓存的通道
	ch2 := make(chan int)
	num := 10
	ch2 <- num  // 只有写入没有读取
}

// 输出---->
fatal error: all goroutines are asleep - deadlock!
```

- 有缓存通道缓存通道满了导致阻塞

```go
package main

func main() {
	// 创建一个5缓存的通道
	ch2 := make(chan int, 5)
	go func() {
		for i := 0; i <= 6; i++ {     // 我们的缓存通道大小只有5但是我们要往里面写入7个数据这就会导致通道阻塞
			ch2 <- i
		}
	}()
	
	select {}
}

// 输出 ---->
fatal error: all goroutines are asleep - deadlock!
```

- 有缓存通道缓存通道没有数据导致阻塞

```go
package main

import "fmt"

func main() {
	// 创建一个5缓存的通道
	ch2 := make(chan int, 5)
	go func() {
		value := <-ch2       // 通道中没有数据进行读取导致通道阻塞
		fmt.Println(value)
	}()
	select {}
}

// 输出 ---->
fatal error: all goroutines are asleep - deadlock!
```

#### 16.3.2 管道实现原理

- Golang以 CSP 并发模型做为并发基础，底层使用goroutine做为并发实体，goroutine非常轻量级可以创建几十万个实体。实体间通过 channel 继续匿名消息传递使之解耦，在语言层面实现了自动调度，这样屏蔽了很多内部细节，对外提供简单的语法关键字，大大简化了并发编程的思维转换和管理线程的复杂性

- 分析channel的实现可以从以下几点着手:
  - channel的数据结构
  - channel的初始化方法
  - channel的send方法（发送数据方法）
  - channel的recv方法（获取数据方法）
  - channel的close方法

##### 16.3.2.1 channel的数据结构

- 在runtime包中hchan定义了管道的数据结构

```go
type hchan struct {
  //channel分为无缓冲和有缓冲两种。
  //对于有缓冲的channel存储数据，借助的是如下循环数组的结构
	qcount   uint           // 循环数组中的元素数量
	dataqsiz uint           // 循环数组的长度
	buf      unsafe.Pointer // 指向底层循环数组的指针
	elemsize uint16 //能够收发元素的大小
  

	closed   uint32   //channel是否关闭的标志
	elemtype *_type //channel中的元素类型
  
  //有缓冲channel内的缓冲数组会被作为一个“环型”来使用。
  //当下标超过数组容量后会回到第一个位置，所以需要有两个字段记录当前读和写的下标位置
	sendx    uint   // 下一次发送数据的下标位置
	recvx    uint   // 下一次读取数据的下标位置
  
  //当循环数组中没有数据时，收到了接收请求，那么接收数据的变量地址将会写入读等待队列
  //当循环数组中数据已满时，收到了发送请求，那么发送数据的变量地址将写入写等待队列
	recvq    waitq  // 读等待队列
	sendq    waitq  // 写等待队列


	lock mutex //互斥锁，保证读写channel时不存在并发竞争问题
}



// 总结hchan结构体的主要组成部分有四个：
用来保存goroutine之间传递数据的循环链表。=====> buf。
用来记录此循环链表当前发送或接收数据的下标值。=====> sendx和recvx。
用于保存向该chan发送和从改chan接收数据的goroutine的队列。=====> sendq 和 recvq
保证channel写入和读取数据时线程安全的锁。 =====> lock


```

![image-20231210232540805](https://cloud.006288.xyz/PicGo//image-20231210232540805.png)

```go
qcount为4：表示channel中有4个元素
dataqsiz为6：表示该channel的底层数组容量大小为6
buf指针：指向给channel底层分配的数组地址
elemsize为8：在64位系统中，int在go中占用字节数为8
closed为0：该channel没有关闭
recvx为0：队首下标，下次从channel中取数据就从0位置取
sendx为4：队尾下标，下次传进channel中的数据就会缓存在这个位置
recvq指针：队列指针，这几个go协程都在等着从channel中获取值
sendq指针：队列指针，这几个go协程都在等着往channel中传入值
```

##### 16.3.2.2  channel的初始化方法

- Go 在编译时，会根据容量大小选择调用 makechan64，还是 makechan。通过源码我们可以知道，makechan64只做了size检查，然后底层最终还是调用makechan实现的

![image-20231214234003734](https://cloud.006288.xyz/PicGo//image-20231214234003734.png)

```go
// t为元素类型，size为channel容量
func makechan(t *chantype, size int) *hchan {
    elem := t.elem
    // 检查 channel size，align 的代码------------------------
    // 编译器会检查类型是否安全
    // compiler checks this but be safe.
    if elem.size >= 1<<16 {    //是否 >= 2^16
        throw("makechan: invalid channel element type")
    }
    // 检查对齐是否正确
    if hchanSize%maxAlign != 0 || elem.align > maxAlign {
        throw("makechan: bad alignment")
    }
    // 计算所需要的内存大小
    mem, overflow := math.MulUintptr(elem.size, uintptr(size))
    if overflow || mem > maxAlloc-hchanSize || size < 0 {
        panic(plainError("makechan: size out of range"))
    }
    //-------------------------------------------------------
 	//创建hchan指针
    var c *hchan
    switch {
    case mem == 0:
        // chan的size（无缓冲chan）或元素的size为0，只分配hchan的内存, 就不必创建buf
        c = (*hchan)(mallocgc(hchanSize, nil, true))
        // 竞争检测器使用此位置进行同步
        c.buf = c.raceaddr()
    case elem.ptrdata == 0:
        // 元素不是指针，分配一块连续的内存给hchan数据结构和buf
        c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
        // hchan数据结构后面紧接着就是buf
        c.buf = add(unsafe.Pointer(c), hchanSize)
    default:
        // Elements contain pointers.
        // 元素包含指针：分别分配hchan结构体和底层循环数组的内存
        c = new(hchan)
        c.buf = mallocgc(mem, elem, true)
    }
 	// 设置hchan中的elemsize、elemtype、dataqsiz、lock等属性
    // 将元素大小、类型记录下来
    c.elemsize = uint16(elem.size)
    c.elemtype = elem
 
    // 将channel容量记录下来
    c.dataqsiz = uint(size)
 
    //初始化channel的锁结构
    lockInit(&c.lock, lockRankHchan)
 
    if debugChan {
        print("makechan: chan=", c, "; elemsize=", elem.size, "; dataqsiz=", size, "\n")
    }
    //返回hchan指针
    return c
}
```

- makeChan就是根据不同容量和元素类型，来分配不同的对象来初始化 chan 对象的字段，及返回 hchan 对象

  ​																			创建一个channel,内存在堆上分配

![image-20231210231635450](https://cloud.006288.xyz/PicGo//image-20231210231635450.png)

- 小结

  - 元素大小不能超过 65536 字节，也即 64K；
  - 元素的对齐大小不能超过 `maxAlign` 也即 8 字节；
  - 计算出来的所需内存不能超过限制；

  - 创建channel时的策略

    - 如果是无缓冲channel，直接为hchan结构体分配内存并返回指针。

    - 如果是有缓冲channel，但元素不包含指针类型，则一次性为hchan结构体和底层循环数组分配连续内存并返回指针。（需要连续内存空间）

    - 如果是有缓冲channel，且元素包含指针类型，则分别分配hchan结构体内存和底层循环数组的内存并返回指针。（可以利用内存碎片）

##### 16.3.2.3  channel的send方法

- send方法表示的是从外界往channel中输入数据。也就是 ch <- a 操作
- 向channel中发送数据主要分为两大块：边界检查和数据发送

  - 如果channel的读等待队列中存在接收者goroutine，则为**同步发送**：

    - [无缓冲channel](https://www.zhihu.com/search?q=无缓冲channel&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A3141063511})，不用经过channel直接将数据发送给第一个等待接收的goroutine，并将其唤醒等待调度。
    - 有缓冲channel，但是元素个数为0，不用经过channel（假装经过channel）直接将数据发送给第一个等待接收的goroutine，并将其唤醒等待调度。
  - 如果channel的读等待队列中不存在接收者goroutine：
  
    - 如果底层循环数组未满，那么把发送者携带的数据入队队尾，此为**异步发送**
    - 如果底层循环数组已满或者是无缓冲channel，那么将当前goroutine加入写等待队列，并将其挂起，等待被唤醒，此为**阻塞发送**
  

![image-20231217001808288](https://cloud.006288.xyz/PicGo//image-20231217001808288.png)

- `Sudog` 结构
  -  是Go 语言 runtime 包中用于实现 goroutine 阻塞和唤醒的关键数据结构之一
  - `Sudog` 结构主要用于在 goroutine 阻塞时保存与该 goroutine 相关的信息，以及在唤醒时用于恢复 goroutine 的执行
  - `g`: 指向等待的 goroutine 的 `g` 结构指针。
  - `isSelect`: 表示该 `Sudog` 是否用于 `select` 语句的等待。
  - `elem`: 存储等待操作所需的数据的指针。
  - `c`: 指向关联的通道的指针。
  - `waitlink`: 在等待链表中连接等待的 `Sudog` 结构。
  - `releasetime`: 记录 goroutine 进入休眠时的时间戳，用于 block profiler




- chansend源码分析

![image-20231216235604204](https://cloud.006288.xyz/PicGo//image-20231216235604204.png)


```go
// chansend 用于通道的发送操作。
// 参数：
//   - c：通道的数据结构指针
//   - ep：要发送的数据指针
//   - block：是否阻塞模式
//   - callerpc：调用者的程序计数器
// 返回值：
//   - bool：发送是否成功，true 表示成功，false 表示失败

func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    //第一层判断，判断c是否为nil
	if c == nil {
        // 如果不能阻塞，那么就返回false表示插入数据失败
		if !block {
			return false
		}
        // 否则就挂起当前goroutine线程，这个调用线程就陷入休眠了
        // gopark 函数来使当前 goroutine 进入休眠状态
        // gopark 函数的参数依次是 unlockf、lock、reason、traceEv 和 2
        // nil 表示在休眠前不需要解锁任何 mutex（unlockf）
        // nil 表示在休眠时不需要重新加锁（lock）
        // waitReasonChanSendNilChan 表示休眠的原因是尝试在 nil 通道上执行发送操作
        // traceEvGoStop 表示休眠时要触发 GoStop 事件
        // 2 表示休眠时的调用深度
		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
		throw("unreachable")
	}
 
    // 调试模式下输出通道信息
	if debugChan {
		print("chansend: chan=", c, "\n")
	}
 
    // 如果开启了 race 检测，记录 race 相关信息
    // raceenabled 是一个全局变量，用于表示是否启用了 race 检测
    // 如果启用了 race 检测，那么会调用 racereadpc 函数，记录当前 goroutine 对通道的读取行为
    // c.raceaddr() 返回通道 c 的地址，用于 race 检测
    // callerpc 是调用 chansend 函数的程序计数器
    // funcPC(chansend) 返回 chansend 函数的入口地址
	if raceenabled {
		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))
	}
 
	// 对于不阻塞的 send，快速检测失败场景
    // 如果 channel在 未关闭且 channel 非阻塞操作,的情况下, 出现下面两种情况之一:
    	// 如果通道没有缓冲区（c.dataqsiz == 0）且接收队列为空（c.recvq.first == nil）
    	// 如果通道有缓冲区（c.dataqsiz > 0）且缓冲区已满（c.qcount == c.dataqsiz）
    // 对于这两种情况会返回false表示插入数据操作失败。
	if !block && c.closed == 0 && ((c.dataqsiz == 0 && c.recvq.first == nil) ||
		(c.dataqsiz > 0 && c.qcount == c.dataqsiz)) {
		return false
	}
 
    // 这段代码的目的是在开启 block profiler 时，记录发送操作的开始时间，以便后续在结束时计算执行时间
	var t0 int64   // 声明一个整数类型变量 t0，用于存储时间戳
    // blockprofilerate 表示 block profiler 的采样频率，如果大于零，说明开启了 block profiler
	if blockprofilerate > 0 {
        // 调用 cputicks() 函数获取当前 CPU 的时钟计数，将其赋值给变量 t0，即记录了执行发送操作的开始时间
		t0 = cputicks() 
	}
 
    // 对channel加锁，保证原子性的
	lock(&c.lock)
 
    // 如果channel关闭了，那么就解锁，然后报panic
    // 因为已经关了的channel没法插数据的
	if c.closed != 0 {
		unlock(&c.lock)
		panic(plainError("send on closed channel"))
	}
 
    // 看看接收队列中有没有等待取数据的goroutine
    // 如果有，说明buf中没数据.
    // 此时 ch<- 速度要小于 <-ch 速度
    // 因此直接从sender送到receizver中
    // 算是一个优化，不需要再经过一次拷贝
	if sg := c.recvq.dequeue(); sg != nil {
        //dequeue 方法从接收队列中取出一个等待接收的 Sudog 结构，赋值给 sg
		// 如果 sg 不为 nil，说明有 goroutine 在等待接收数据
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
        // 用 send 函数执行实际的发送操作。
        // send 函数的参数包括通道 c、等待接收的 Sudog 结构 sg、待发送的数据指针 ep、一个解锁函数（用于在发送完成后解锁通道）以及深度 3
		return true
	}
 
    // 否则说明没有等待数据的goroutine，说明buf中有数据
    // 此时 ch<- 速度要大于 <-ch 速度
 
    // 那么如果还有剩余容量可以存储数据
    // 就往尾部插入数据存起来，然后解锁，返回插入成功
    
    // 这段代码处理的是通道缓冲区有空间的情况
	if c.qcount < c.dataqsiz {
		// 调用 chanbuf 函数获取通道缓冲区中当前位置 c.sendx 对应的指针 qp。
        // 这个指针指向缓冲区的某个位置，用于存储即将发送的数据
		qp := chanbuf(c, c.sendx)
        // 如果启用了 race detector，调用 raceacquire 和 racerelease 函数来标记 qp 对应的内存区域。
        // 这是为了在 race detector 下追踪并发访问
		if raceenabled {
			raceacquire(qp)
			racerelease(qp)
		}
        // typedmemmove 是一个通用的内存拷贝函数，可以处理不同类型的数据
        // 使用 typedmemmove 函数将待发送的数据 ep 拷贝到缓冲区中。
		typedmemmove(c.elemtype, qp, ep)
        // 将通道缓冲区的发送位置 c.sendx 向后移动一个位置
		c.sendx++
        // 果发送位置达到缓冲区的末尾，则将其重置为缓冲区的起始位置，实现循环利用
		if c.sendx == c.dataqsiz {
			c.sendx = 0
		}
        // 增加缓冲区中当前存储的元素数量
		c.qcount++
		unlock(&c.lock)
		return true
	}
 
    // 如果不能阻塞，那么就返回false表示插入失败
	if !block {
		unlock(&c.lock)
		return false
	}
 
 
	// channel 满了，发送方会被阻塞。接下来会构造一个 sudog，保存下当前线程的信息，并将其入队（c.sendq字段）
	// 调用 getg 函数获取当前 goroutine 的 g 结构，将其赋值给变量 gp
	gp := getg()
    // 调用 acquireSudog 函数从 Sudog 池中获取一个空闲的 Sudog 结构，将其赋值给变量 mysg
	mysg := acquireSudog() 
    // 将 Sudog 结构的 releasetime 字段设置为 0。这个字段用于记录 goroutine 进入休眠时的时间戳
	mysg.releasetime = 0
    // 如果之前记录了开始时间 t0，则将 releasetime 设置为 -1，表示在 block profiler 模式下
	if t0 != 0 {
		mysg.releasetime = -1
	}
    
	// 将 Sudog 结构的 elem 字段设置为待发送的数据的指针 ep
	mysg.elem = ep  
    // 将 Sudog 结构的 waitlink 字段设置为 nil，表示当前 Sudog 结构不属于等待链表
	mysg.waitlink = nil
    // 将 Sudog 结构的 g 字段设置为当前 goroutine 的 g 结构
	mysg.g = gp
    // 将 Sudog 结构的 isSelect 字段设置为 false，表示不是用于 select 语句
	mysg.isSelect = false
    // 将 Sudog 结构的 c 字段设置为通道 c
	mysg.c = c
    // 将当前 goroutine 的 waiting 字段设置为当前 Sudog 结构，表示当前 goroutine 正在等待在通道上
	gp.waiting = mysg
    // 将当前 goroutine 的 param 字段设置为 nil
	gp.param = nil
 
	// enqueue 方法是对队列的入队操作,将当前的 Sudog 结构 mysg 加入通道的发送队列
	c.sendq.enqueue(mysg)
    // 调用 goparkunlock 函数，将当前 goroutine 进行休眠（parking）
	goparkunlock(&c.lock, waitReasonChanSend, traceEvGoBlockSend, 3)
 
    // 调用 KeepAlive 函数确保待发送的数据 ep 仍然存活,不会被gc掉
	KeepAlive(ep)
 
    // 从这里开始被唤醒了（channel 有机会可以发送了）
	// 检查 gp.waiting 是否与当前 Sudog 结构 mysg 匹配，确保等待列表没有被破坏
	if mysg != gp.waiting {
        // 如果不匹配，说明等待列表被破坏了，触发异常
		throw("G waiting list is corrupted")
	}
    // 将当前 goroutine 的等待字段 gp.waiting 置为 nil，表示当前 goroutine 不再等待在通道上
	gp.waiting = nil
    // 检查 goroutine 的参数字段 gp.param 是否为 nil
    // 如果 gp.param 为 nil，说明 goroutine 被唤醒但没有附带参数，这通常发生在意外的唤醒情况下
	if gp.param == nil {
        // 如果通道没有关闭（c.closed == 0），则触发异常，表示唤醒是不正常的，发生在通道没有关闭的情况下
		if c.closed == 0 {
			throw("chansend: spurious wakeup")
		}
        // 如果通道已经关闭，表示发送操作发生在关闭的通道上，触发 panic，表示在关闭的通道上执行发送操作是非法的
		panic(plainError("send on closed channel"))
	}
    // 将 goroutine 的参数字段 gp.param 置为 nil，清除之前的参数
	gp.param = nil
    // 检查 mysg.releasetime 是否大于零，即 goroutine 在休眠时有记录释放时间
	if mysg.releasetime > 0 {
        // 调用 blockevent 函数，将释放时间与开始时间 t0 之间的差作为参数传递。这是用于 block profiler
		blockevent(mysg.releasetime-t0, 2)
	}
    // 将 Sudog 结构的通道字段 mysg.c 置为 nil，解除与通道的关联
	mysg.c = nil
    // 调用 releaseSudog 函数将 mysg 放回 Sudog 池，释放该 Sudog 结构供将来使用
	releaseSudog(mysg)
	return true
}
```

- 同步发送

![image-20231217002059232](https://cloud.006288.xyz/PicGo//image-20231217002059232.png)

- 异步发送

![image-20231217002110216](https://cloud.006288.xyz/PicGo//image-20231217002110216.png)

- 阻塞发送

![image-20231217002053712](https://cloud.006288.xyz/PicGo//image-20231217002053712.png)

##### 16.3.2.4  channel的recv方法

- recv方法表示的是从channel往外传出数据。也就是 a <- ch  操作。

- 接收操作有两种写法，一种带 "ok"，反应 channel 是否关闭；一种不带 "ok"，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值

- 接收数据的流程主要由两大块组成：边界检查和接收数据，其中接收数据的处理逻辑如下。

  - 如果 channel 的写等待队列存在发送者 goroutine，此为**同步接收** 

  - - 如果是无缓冲 channel，直接从第一个发送者 goroutine 那里把数据拷贝给接收变量，**唤醒发送的 goroutine**；
    - 如果是有缓冲 channel（已满），将循环数组 buf 的队首元素拷贝给接收变量，将第一个发送者 goroutine 的数据拷贝到 buf 循环数组队尾，**唤醒发送的 goroutine**；

  - 如果 channel 的写等待队列不存在发送者 goroutine： 

  - - 如果循环数组 buf 非空，将循环数组 buf 的队首元素拷贝给接收变量，此为**异步接收**
    - 如果循环数组 buf 为空，将当前 goroutine 加入读等待队列，并**挂起等待唤醒**，此为**阻塞接收*

  ![image-20231217002259152](https://cloud.006288.xyz/PicGo//image-20231217002259152.png)

- chanrecv源码分析

```go
// entry points for <- c from compiled code
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
	chanrecv(c, elem, true)
}
 
//go:nosplit
func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {
	_, received = chanrecv(c, elem, true)
	return
}

// chanrecv1函数处理不带 "ok" 的情形， chanrecv2则通过返回 "received" 这个字段来反应 channel 是否被关闭。接收值则比较特殊，会“放到”参数 elem所指向的地址了，如果代码里忽略了接收值，这里的 elem 为 nil
```

- chanrecv函数

```go
// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。
// 如果ep是一个指向接收数据的指针，类型为 unsafe.Pointer。通道接收操作将从通道中取出的数据存储到这个指针指向的内存地址。
// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)
// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)
// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)
// callerpc uintptr：表示调用该接收操作的函数的调用者的程序计数器（program counter）值
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
 
	if debugChan {
		print("chanrecv: chan=", c, "\n")
	}
 
    // 如果是一个 nil 的 channel
	if c == nil {
        // 如果不阻塞，直接返回 (false, false)
		if !block {
			return
		}
        // 否则，接收一个 nil 的 channel，goroutine 挂起
		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
		throw("unreachable")
	}
 
    // 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回
    // 当我们观察到 channel 没准备好接收：
    // 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待
    // 2. 缓冲型，但 buf 里没有元素
    // 之后，又观察到 closed == 0，即 channel 未关闭。
    // 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，
    // 因此在这种情况下可以直接宣布接收失败，返回 (false, false)
	if !block && (c.dataqsiz == 0 && c.sendq.first == nil ||
		c.dataqsiz > 0 && atomic.Loaduint(&c.qcount) == 0) &&
		atomic.Load(&c.closed) == 0 {
		return
	}
 
	var t0 int64
	if blockprofilerate > 0 {
		t0 = cputicks()
	}
 
    // 加锁保证并发
	lock(&c.lock)
 
    // channel 已关闭，并且循环数组 buf 里没有元素
    // 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况
    // 也就是说即使是关闭状态，但在缓冲型的 channel，
    // buf 里有元素的情况下还能接收到元素
	if c.closed != 0 && c.qcount == 0 {
		if raceenabled {
			raceacquire(c.raceaddr())
		}
        // 解锁
		unlock(&c.lock)
        // 从一个已关闭的 channel 执行接收操作，且未忽略返回值
        // 那么接收的值将是一个该类型的零值
        // typedmemclr 根据类型清理相应地址的内存
		if ep != nil {
			typedmemclr(c.elemtype, ep)
		}
		return true, false
	}
 
    // 等待发送队列里有 goroutine 存在，说明 buf 是满的
    // 这有可能是：
    // 1. 非缓冲型的 channel。
    //    这时直接进行内存拷贝（从 sender goroutine -> receiver goroutine）
    // 2. 缓冲型的 channel，但 buf 满了。
    //    这时接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部
	if sg := c.sendq.dequeue(); sg != nil {

		recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true, true
	}
 
    // 如果发送队列里没有 goroutine 存在，说明 buf 没有满
 
    // 缓冲型，并且 buf 里有元素，可以正常接收
	if c.qcount > 0 {
		// 直接从循环数组里找到要接收的元素
		qp := chanbuf(c, c.recvx)
		if raceenabled {
			raceacquire(qp)
			racerelease(qp)
		}
        // 代码里，没有忽略要接收的值，不是 "<- ch"，而是 "val <- ch"，ep 指向 val
		if ep != nil {
			typedmemmove(c.elemtype, ep, qp)
		}
        // 清理掉循环数组里相应位置的值
		typedmemclr(c.elemtype, qp)
		c.recvx++
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
        // buf 数组里的元素个数减 1
		c.qcount--
		unlock(&c.lock)
		return true, true
	}
 
    // 非阻塞接收，解锁。selected 返回 false，因为没有接收到值
	if !block {
		unlock(&c.lock)
		return false, false
	}
 
    // 之后全部处理的是被阻塞的情况
    // 也就是 buf值是空的，当前没有能过获取到的值
 
	// 构造一个 sudog
	gp := getg()
	mysg := acquireSudog()
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
    // 待接收数据的地址保存下来
	mysg.elem = ep
	mysg.waitlink = nil
	gp.waiting = mysg
	mysg.g = gp
	mysg.isSelect = false
	mysg.c = c
	gp.param = nil
 
    // 将生成的sudog放入 channel 的等待接收队列 recvq
	c.recvq.enqueue(mysg)
    
    // 将当前 goroutine 挂起
	goparkunlock(&c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)
 
	// 如果能继续运行说明线程继续运行了
    // 接着从这里继续执行一些扫尾工作
	if mysg != gp.waiting {
		throw("G waiting list is corrupted")
	}
 
	gp.waiting = nil
	if mysg.releasetime > 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	closed := gp.param == nil
	gp.param = nil
	mysg.c = nil
	releaseSudog(mysg)
	return true, !closed
}
```

- 同步接收

![image-20231217002502291](https://cloud.006288.xyz/PicGo//image-20231217002502291.png)

- 异步接收

![image-20231217002536300](https://cloud.006288.xyz/PicGo//image-20231217002536300.png)

- 阻塞接收

![image-20231217002557425](https://cloud.006288.xyz/PicGo//image-20231217002557425.png)

##### 16.3.2.5 channel的close方法

- 通过 close函数，可以把 chan 关闭，底层调用 closechan 方法执行
- 闭channel的总体流程如下
  - 边界检查
  - 从recvq释放所有的readers
  - 从sendq释放所有的writers（会产生panic）
  - 唤醒所有的readers和writers
- close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。
- close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒。
- 唤醒之后，sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。

![image-20231223203543472](https://cloud.006288.xyz/PicGo//image-20231223203543472.png)

```go
func closechan(c *hchan) {
    // 判断是否为nil，报panic
	if c == nil {
		panic(plainError("close of nil channel"))
	}
 
    // 加锁保证并发
	lock(&c.lock)
    
    // 如果channel已经关闭了，那么就不能再关闭，报panic
	if c.closed != 0 {
		unlock(&c.lock)
		panic(plainError("close of closed channel"))
	}
 
    // 竞态相关
	if raceenabled {
		callerpc := getcallerpc()
		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))
		racerelease(c.raceaddr())
	}
 
    // 关闭channel，设置标志
	c.closed = 1
 
	var glist gList
 
	// 将 channel 所有等待接收队列的里 sudog 释放
	for {
        // 从接收队列里出队一个 sudog
		sg := c.recvq.dequeue()
        // 出队完毕，跳出循环
		if sg == nil {
			break
		}
 
        // 如果 elem 不为空，说明此 receiver 未忽略接收数据
		// 给它赋一个相应类型的零值
        if sg.elem != nil {
			typedmemclr(c.elemtype, sg.elem)
			sg.elem = nil
		}
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
    
        // 取出 goroutine
		gp := sg.g
		gp.param = nil
		if raceenabled {
			raceacquireg(gp, c.raceaddr())
		}
        // 相连，形成链表
		glist.push(gp)
	}
 
	// 将 channel 等待发送队列里的 sudog 释放,(这些将会panic)
 
	for {
		sg := c.sendq.dequeue()
		if sg == nil {
			break
		}
        // 发送者会 panic
		sg.elem = nil
		if sg.releasetime != 0 {
			sg.releasetime = cputicks()
		}
		gp := sg.g
		gp.param = nil
		if raceenabled {
			raceacquireg(gp, c.raceaddr())
		}
        // 形成链表
		glist.push(gp)
	}
    //解锁
	unlock(&c.lock)
 
    // 遍历链表
	// Ready all Gs now that we've dropped the channel lock.
	for !glist.empty() {
		gp := glist.pop()
		gp.schedlink = 0
        // 唤醒相应 goroutine
		goready(gp, 3)
	}
}
```

#### 16.3.3 selsect语句基本使用

- 源码包 `src/runtime/select.go` 定义了表示case语句的数据结构`scase`

- select语句 就是用来监听和channel有关的IO操作，当IO操作发生时，触发相应的case动作。有了 select语句，可以实现 main主线程 与 goroutine线程 之间的互动

```go
// select 语句的基本语法

select {
case communicationClause1:
    // 处理通信操作1的代码
case communicationClause2:
    // 处理通信操作2的代码
case communicationClause3:
    // 处理通信操作3的代码
default:
    // 没有任何通信操作时的默认代码块
}

```

- 每个 `case` 子句都描述了一个通信操作，它可以是发送到或接收从一个通道的数据
- **阻塞：** 如果没有任何通信操作可以完成，且不存在 `default` 子句，`select` 将会阻塞，等待通信操作就绪
- **随机选择：** 如果有多个通信操作可以完成，`select` 会随机选择其中一个执行。这样可以避免出现饥饿问题
- **超时：** 可以通过 `time.After` 和 `default` 子句实现超时效果
- **多通道选择：** `select` 可以同时处理多个通道的通信操作
- 对于空的 select语句，会引起死锁；
- 对于在 for中的select语句，不能添加 default，否则会引起cpu占用过高的问题



- selsec使用案例

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	ch1 := make(chan int)
	ch2 := make(chan string)

	go func() {
		time.Sleep(time.Second * 1)
		ch1 <- 8
	}()

	go func() {
		time.Sleep(time.Second * 1)
		ch2 <- "hello golang"
	}()

	select {
	case value := <-ch1:
		fmt.Println(value)
	case value2 := <-ch2:
		fmt.Println(value2)
	case <-time.After(time.Second * 3):
		fmt.Println("Timeout")

	}
}

```

- select实现原理

  - Golang实现select时，定义了一个数据结构表示每个case语句(含defaut，default实际上是一种特殊的case)，select执行过程可以类比成一个函数，函数输入case数组，输出选中的case，然后程序流程转到选中的case块
  - case语句的数据结构

  ```go
  type scase struct {
  	c    *hchan         // chan
  	elem unsafe.Pointer // data element
  }
  
  // c    *hchan:  scase.c为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel
  // elem unsafe.Pointer：表示数据元素的指针，类型为 unsafe.Pointer。在 select 语句中，它指向待发送或待接收的数据
  // 当scase.kind == caseRecv ： scase.elem表示读出channel的数据存放地址；
  // 当scase.kind == caseSend ： scase.elem表示将要写入channel的数据存放地址
  
  // 这个结构体的目的是为了在 select 语句中描述每个 case 子句，即一个通信操作。scase 中的字段描述了通信操作的目标通道和相关数据元素
  ```

  - select实现逻辑
    - 在scase数据结构下边有一个 selectgo() 函数，它是一个定义了select选择case的函数

```go
func selectgo(cas0 *scase, order0 *uint16, pc0 *uintptr, nsends, nrecvs int, block bool) (int, bool) {
    ....
}
// 参数说明
// cas0 *scase：表示 select 语句中所有通信操作的 scase 数组，每个元素描述一个通信操作。
// order0 *uint16：表示通信操作对应通道锁的锁定顺序。
// pc0 *uintptr：表示调用该函数的程序计数器（program counter）的指针。
// nsends int：表示 select 语句中发送操作的数量。
// nrecvs int：表示 select 语句中接收操作的数量。
// block bool：表示 select 语句是否是阻塞的，如果为 true，表示阻塞，如果为 false，表示非阻塞。

//返回值 (int, bool)：
// 第一个返回值是选定的通信操作的索引（数组下标），表示哪个通信操作成功。
// 第二个返回值是一个布尔值，表示是否成功选定了一个通信操作。

//selectgo 函数是 select 语句的底层实现，用于执行非阻塞或阻塞的通信操作选择。在 select 语句中，会调用这个函数来进行多路选择。返回的结果指示了哪个通信操作成功，并且是否成功选定了一个通信操作
```

- selsect基本流程

  - **初始化变量：** 函数开始时，首先会初始化一系列变量，包括通信操作的数量、阻塞标志等

  ```go
  var (
      scase *scase // 通信操作的 scase 结构体
      c     *hchan // 通道
      elem  unsafe.Pointer // 数据元素指针
      ...
  )
  ```

  - **循环选择通信操作：** 进入一个无限循环，不断地尝试选择通信操作

  ```go
  for {
      // 尝试选择通信操作
      selidx := selectnbsend(c, elem, selected, pc, order, canblock)
      
      // 处理选择的结果
      switch selidx {
      case -1:
          // 没有可用的通信操作，退出循环
          break
      case -7:
          // 阻塞等待通信操作完成
          blockselect(c, elem, pc)
      default:
          // 处理成功选择的通信操作
          ...
      }
  }
  
  ```

  - **尝试选择通信操作：** 调用 `selectnbsend` 函数进行非阻塞选择通信操作

  ```go
  func selectnbsend(c *hchan, elem unsafe.Pointer, selected *uint16, pc *uintptr, order *uint16, canblock bool) int {
      // 尝试非阻塞选择通信操作
      selectgo(cas0, order0, pc0, nsends, 0, false)
  }
  
  ```

  - **selectgo 函数的执行：** 调用 `selectgo` 函数，该函数在多个通信操作中进行选择，并返回选择的结果

  ```go
  func selectgo(cas0 *scase, order0 *uint16, pc0 *uintptr, nsends, nrecvs int, block bool) (int, bool) {
      // 根据 cas0、order0、nsends、nrecvs 等参数进行选择
      ...
  }
  ```

  - **处理选择结果：** 根据 `selectgo` 的返回值，处理选择的结果。如果返回值为 -1，表示没有可用的通信操作，退出循环。如果返回值为 -7，表示阻塞等待通信操作完成。其他情况表示成功选择了通信操作，执行相应的逻辑

  ```go
  switch selidx {
  case -1:
      // 没有可用的通信操作，退出循环
      break
  case -7:
      // 阻塞等待通信操作完成
      blockselect(c, elem, pc)
  default:
      // 处理成功选择的通信操作
      ...
  }
  ```



#### 16.3.4 管道遍历

- 在 Go 语言中，可以通过 `range` 关键字遍历通道（channel）。遍历通道时，可以在 `range` 语句中使用通道来获取通道中的元素

```go
package main

import "fmt"

func main() {
    // 创建一个通道
    ch := make(chan int)

    // 启动一个 goroutine 发送数据到通道
    go func() {
        for i := 0; i < 5; i++ {
            ch <- i
        }
        close(ch) // 关闭通道，表示不再发送数据
    }()

    // 使用 for ... range 遍历通道
    for value := range ch {
        fmt.Println(value)
    }
}
```

#### 16.3.5 管道综合案例

- 日志处理系统

  - **需求：**

    - 设计一个简单的日志处理系统，模拟实际生产环境中的日志收集、处理和存储场景。
    - **日志生成器：** 创建一个日志生成器，负责模拟不同级别的日志产生。
    - **日志处理模块：** 设计一个日志处理模块，负责处理收集到的日志，例如过滤、分析或格式化。
    - **日志存储：** 实现一个日志存储模块，将处理后的日志存储到文件或数据库中。
    - **告警器：** 设计一个告警器，用于监控日志中的异常情况并触发告警。
  - **具体要求：**
    1. 定义一个 `My_log` 结构体，包含日志的级别、时间戳、内容等信息。
    2. 创建一个日志生成器函数 `log_generate`，该函数接收一个整数参数表示生成的日志数量，并返回一个日志通道。
    3. 设计一个日志处理函数 `log_process`，该函数接收一个日志，对日志进行简单的处理，例如打印到控制台。
    4. 创建一个日志存储函数 `log_store`，该函数接收一个处理后的日志，将日志存储到文件或数据库中。
    5. 创建一个告警器函数 `log_monitor`，该函数接收一个日志通道，实时监控日志中的异常情况，并触发告警。
    6. 创建一个管道连接以上模块的函数 `logProcessingPipeline`，该函数接收一个日志通道，并按照日志生成、日志处理、日志存储、告警的顺序，依次处理日志。
    7. 在 `main` 函数中调用 `logProcessingPipeline`，并传递适当的参数来模拟日志处理流程
  - **程序基本逻辑**：
    1. `log_generate` 函数生成指定数量的随机日志，并将其发送到通道。
    2. `log_process` 函数处理日志消息，返回格式化后的字符串。
    3. `log_store` 函数将日志消息写入文件。
    4. `log_monitor` 函数监听日志通道，处理日志消息，将错误日志写入文件。
    5. `logProcessingPipeline` 函数是整个日志处理的流水线，包括生成日志、监听日志、等待完成。
    6. `main` 函数设置随机数种子，调用 `logProcessingPipeline` 处理日志，然后等待子进程处理完成

``` go
package main

import (
	"fmt"
	"math/rand"
	"os"
	"sync"
	"time"
)

type My_log struct {
	Level     string
	Timestamp time.Time
	Message   string
}

func LogGenerate(log_num int) (log_ch chan My_log) {
	log_ch = make(chan My_log)

	go func() {
		defer close(log_ch)
		log_level := []string{"INFO", "WARNING", "ERROR", "DEBUG"}
		for i := 1; i <= log_num; i++ {
			log_message := My_log{
				Level:     log_level[rand.Intn(len(log_level))],
				Timestamp: time.Now(),
				Message:   fmt.Sprintf("Log number %d", i),
			}
			log_ch <- log_message
			time.Sleep(time.Millisecond * 500)
		}
	}()
	return log_ch
}

func LogProcess(log_message My_log) string {
	return fmt.Sprintf("log_level: [%s], log_timestmap: [%v], log_message: [%s]\n", log_message.Level,
		log_message.Timestamp, log_message.Message)
}

func LogStore(log_message string) {
	file, err := os.OpenFile("log.txt", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			fmt.Println("文件关闭失败")
		}
	}(file)

	if err != nil {
		fmt.Println("文件句柄创建失败,文件打开错误")
		return
	} else {
		_, err := file.WriteString(log_message)
		if err != nil {
			fmt.Println("文件写入失败")
		} else {
			fmt.Println("文件写入成功")
		}
	}
}

func LogMonitor(log_chan <-chan My_log, done chan struct{}, wg *sync.WaitGroup) {
	defer wg.Done()
	for {
		select {
		case log, ok := <-log_chan:
			if !ok {
				fmt.Println("channel已经关闭")
				return
			} else {
				logStr := LogProcess(log)
				if log.Level == "ERROR" {
					LogStore(logStr)
				} else {
					fmt.Print(logStr)
				}
			}
		case <-done:
			return
		}
	}
}

func logBridge(log_num int) {
	log_message := LogGenerate(log_num)
	var wg sync.WaitGroup
	log_channel := make(chan struct{})

	wg.Add(1)
	go LogMonitor(log_message, log_channel, &wg)
	wg.Wait()

	close(log_channel)
}

func main() {
	log_num := 10
	var wg sync.WaitGroup

	// 增加计数，表示有一个 goroutine 即将运行
	wg.Add(1)
	go func() {
		defer wg.Done()
		logBridge(log_num)
	}()

	// 等待所有 goroutine 完成
	wg.Wait()
}
```

## 17. 反射和泛型

### 17.1 反射

#### 17.1.1 为什么需要反射

- 有时候编写一个函数,但是我们并不知道传递给我们的参数是什么类型的, 可能是没约定好,也可能是传入的类型很多，这些类型并不能统一表示, 同时Go语言目前还不支持泛型（Generics）,因此在处理不同类型的数据时，可能需要使用反射来编写通用的代码
- 在处理 JSON、XML 等数据格式时，可能需要将数据序列化为结构体或从结构体反序列化。反射可以帮助检查和操作结构体的字段

......

#### 17.1.2 反射的基本概述

- **什么是反射:**
  - 反射在维基百科上的定义是: 在计算机科学中，反射是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为
  - Go语言提供了反射机制，允许程序在运行时检查和操作变量、方法、结构等信息, 但是在编译时并不知道这些变量的具体类型。这种机制被称为反射

- **反射的弊端:**(在实际编程中，应该谨慎使用反射)
  - **性能：** 反射通常比直接的类型操作更慢，因为它需要在运行时进行类型检查和动态分析。
  - **可读性：** 使用反射的代码通常更难理解和维护，因为它隐藏了很多类型信息，并使代码变得更加复杂。
  - **错误隐患：** 由于在编译时无法检查反射操作的一些错误，因此使用反射时容易引入一些潜在的运行时错误

#### 17.1.3 反射的基本使用

- 在Go语言中主要通过`reflect`包实现

- go语言反射里最重要的两个概念是**Type**和**Value**
- **Type（类型）：**
  - **`reflect.Type`：** 表示一个Go语言类型的接口。它提供了对类型的基本信息的访问，比如类型的名称、种类（kind）、包路径等。
  - **`TypeOf` 函数：** 用于获取一个变量的类型
- **Value（值信息）：**
  - `reflect.Value` 是一个包含变量的值的接口，它提供了对变量值的访问和修改方法。
  - `reflect.ValueOf` 函数返回一个值的`reflect.Value`。
  - `Value` 接口提供了一系列方法，如 `Int()`, `Float()`, `Set()`, 等，用于获取和修改变量的值

![image-20240103230026761](https://cloud.006288.xyz/PicGo//image-20240103230026761.png)

- 基本数据类型

```go
package main

import (
	"fmt"
	"reflect"
)

// 基本数据类型
var name string = "kubei"

func main() {
	// 获取类型信息
	rType := reflect.TypeOf(name)
	fmt.Printf("rType的类型: %T \n", rType)

	// 访问类型的元数据
	rName := rType.Name()
	rKind := rType.Kind() // 获取到kind后可以进行类型判断
	rPkg := rType.PkgPath()
	fmt.Printf("变量名: %v, 变量种类: %v, 变量所属包路径: %v, \n", rName, rKind, rPkg)

	// 获取类型的值
	rValue := reflect.ValueOf(name) // 后边需要对内容进行修改所以需要传入指针
	fmt.Println("变量的值: ", rValue)

	// 通过类型值进行访问和修改变量
	rKind2 := rValue.Kind()
	rLen := rValue.Len()
	fmt.Printf("值种类: %v, 值长度: %v\n", rKind2, rLen)

	// 修改变量内容
	reflect.ValueOf(&name).Elem().SetString("Tom")
	fmt.Println("修改后和变量值: ", name)
	

}
```

- 复合数据类型

```go
// 结构体
package main

import (
	"fmt"
	"reflect"
)

// 自定义数据类型
type myData struct {
	Name string `json:"name"`
	Age  int
	Add  string
}

func main() {
	// 获取类型信息
	rType := reflect.TypeOf(myData{"kubei", 18, "shanghai"})
	fmt.Printf("rType的类型: %T \n", rType)

	// 访问类型的元数据
	rName := rType.Name()
	rKind := rType.Kind() // 获取到kind后可以进行类型判断
	rPkg := rType.PkgPath()
	fmt.Printf("变量名: %v, 变量种类: %v, 变量所属包路径: %v, \n", rName, rKind, rPkg)

	// 获取类型的值
	rValue := reflect.ValueOf(myData{"kubei", 18, "shanghai"}) // 后边需要对内容进行修改所以需要传入指针
	fmt.Println("变量的值: ", rValue)

	// 通过类型值进行访问和修改变量
	rKind2 := rValue.Kind()
	rname := rValue.FieldByName("Name")
	
	fmt.Printf("值种类: %v, Name字段的值: %v\n", rKind2, rname)

	// 修改变量内容
	mydata2 := reflect.ValueOf(&myData{"kubei", 18, "shanghai"})
	mydata2.Elem().FieldByName("Age").SetInt(24)
	fmt.Println("修改后和变量值: ", mydata2)

}
```

#### 17.1.4 反射类型转换

- 在go语言中变量、interface{}、reflect.Value是可以相互转化的

![image-20240104213924858](https://cloud.006288.xyz/PicGo//image-20240104213924858.png)

- **变量与interface{}之间的转换**

```go
package main

import "fmt"

func main() {
    var x int = 42
    var y interface{} = x

    // 从 interface{} 转换为具体类型
    z, ok := y.(int)

    if ok {
        fmt.Printf("Original value: %d, Retrieved value: %d\n", x, z)
    } else {
        fmt.Println("Type assertion failed")
    }
}
```

- **interface{} 与 reflect.Value 之间的转换**

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x interface{} = 42

    // 将 interface{} 转换为 reflect.Value
    v := reflect.ValueOf(x)

    // 从 reflect.Value 获取具体类型的值
    y := v.Interface().(int)

    fmt.Printf("Original value: %d, Retrieved value: %d\n", x, y)
}

```

#### 17.1.5 反射综合案例

- 场景需求:

  - 假设正在开发一个分布式系统，系统中包含多个微服务组件，每个组件有自己的配置信息。由于系统的规模和复杂性，配置信息可能会根据实际需求经常变动，不同的服务组件可能具有不同的配置需求。请希望设计一个通用的配置加载器，以满足以下需求：

    1. **结构体定义：** 定义一个通用的配置结构体，每个微服务组件可以根据自己的需求定义自己的配置结构体。配置结构体中的字段可以包括连接地址、端口号、超时时间等。
    2. **结构体标签：** 使用结构体标签（Struct Tags）来提供更多的配置信息。结构体标签可以包含字段的元数据，例如字段的名称、JSON 标签、默认值等。
    3. **从文件中读取结构体信息：** 扩展配置加载器，使其能够从配置文件中读取结构体所需的信息。配置文件的路径、文件格式（JSON、YAML 等）以及文件中定义的配置项应该可配置。
    4. **初始化结构体：** 在加载配置时，除了从环境变量和配置文件中读取值之外，还可以根据结构体标签中定义的默认值对结构体进行初始化。
    5. **JSON 格式化和打印：** 最后，将加载并初始化后的配置结构体进行 JSON 格式化，并打印出来。这有助于调试和查看当前配置的状态。

    这样的通用配置加载器将允许每个微服务组件根据自身需要动态加载配置，而不需要为每个组件编写特定的配置加载逻辑。此外，通过结构体标签和配置文件，可以提供更灵活和可扩展的配置管理方式

```go
package main

import (
	"encoding/json"
	"fmt"
	"os"
	"reflect"
	"strconv"
)

// Config 是通用的配置结构体，每个微服务组件可以根据自己的需求定义自己的配置结构体。
type Config struct {
	Host    string  `json:"host" default:"localhost"`
	Port    int     `json:"port" default:"8080"`
	Timeout float64 `json:"timeout" default:"10.0"`
	IsDebug bool    `json:"is_debug" default:"false"`
}

// loadConfigFromFileWithReflection 从配置文件中加载配置信息，使用反射初始化结构体。
func loadConfigFromFileWithReflection(cfg interface{}, configFile string) error {
	if configFile != "" {
		fileContent, err := os.ReadFile(configFile)
		if err != nil {
			return err
		}

		if err := json.Unmarshal(fileContent, cfg); err != nil {
			return err
		}

		// 使用反射初始化结构体
		v := reflect.ValueOf(cfg).Elem()
		for i := 0; i < v.NumField(); i++ {
			field := v.Field(i)
			defaultValue := v.Type().Field(i).Tag.Get("default")

			switch field.Kind() {
			case reflect.String:
				if field.String() == "" {
					field.SetString(defaultValue)
				}
			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
				if field.Int() == 0 {
					intValue, err := strconv.Atoi(defaultValue)
					if err == nil {
						field.SetInt(int64(intValue))
					}
				}
			case reflect.Float32, reflect.Float64:
				if field.Float() == 0.0 {
					floatValue, err := strconv.ParseFloat(defaultValue, 64)
					if err == nil {
						field.SetFloat(floatValue)
					}
				}
			case reflect.Bool:
				if !field.Bool() {
					boolValue, err := strconv.ParseBool(defaultValue)
					if err == nil {
						field.SetBool(boolValue)
					}
				}
			}
		}
	}

	return nil
}

// main 函数演示如何使用通用配置加载器。
func main() {
	// Define a sample configuration
	config := Config{}

	// Load configuration from file with reflection
	if err := loadConfigFromFileWithReflection(&config, "config.json"); err != nil {
		fmt.Println("Error loading configuration:", err)
		return
	}

	// Print formatted JSON representation of the configuration
	configJSON, _ := json.MarshalIndent(config, "", "  ")
	fmt.Println(string(configJSON))
}
```

### 17.2 泛型

#### 17.2.1 什么是泛型

- 泛型是go 1.18版本新增功能

- 泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。ーー换句话说，在编写某些代码或数据结构时先不提供值的类型，而是之后再提供 
- 泛型是一种独立于所使用的特定类型的编写代码的方法。使用泛型可以编写出适用于一组类型中的任何一种的函数和类型
- 他的目的也是为了动态处理数据, 此时我们会想到前面的接口和反射, 没错他们的作用基本相似, 但是反射有着:  
  - 用起来麻烦
  - 会降低代码的执行效率
  - 失去了编译时的类型检查，不仔细写容易出错等问题

- 泛型的出现解决了反射的问题,但是并不意味着泛型是万能的,泛型有着自己的使用场景: **如果你经常要分别为不同的类型写完全相同逻辑的代码，那么使用泛型将是最合适的选择**

- 场景案例

```go
// 我们定义了一个方法用于拼接两个字符串,可以看到该方法已经规定死了我们只能传递字符串类型的数据,如果我们调用的时候需要传递int或其他数据类型,那么他将会报错,所以我们只能在写一个适用int的方法
package main

import "fmt"

func addStrint(a, b string) string {
	return a + b
}

func addint(a, b int) int {
	return a + b
}

func main() {
	fmt.Println(addStrint("hello", "world"))
	fmt.Println(addint(5, 8))

}

// 仔细观察上面代码我们会发现他们只是数据类型不同,但是他们的代码逻辑是相同的,这样会显得代码冗余过高
// 这种场景我们就可以使用泛型来处理,代码如下
package main

import "fmt"

// 定义一个泛型的 add 函数
func add[T int | string | float64](a, b T) T {
	return a + b
}

func main() {
	fmt.Println(add[int](10, 20))

	// 使用泛型函数 add，自动推断为 string 类型
	resultString := add("hello", " world")
	fmt.Println(resultString)

	// 使用泛型函数 add，自动推断为 float64 类型
	resultFloat := add(3.14, 2.71)
	fmt.Println(resultFloat)
}

```

#### 17.2.2 泛型基本使用

##### 17.2.2.1 泛型基本语法

- 泛型为Go语言添加了三个新的重要特性:
  1. 函数和类型的类型参数。
  2. 将接口类型定义为类型集，包括没有方法的类型。
  3. 类型推断，它允许在调用函数时在许多情况下省略类型参数

- 泛型基本写法

```go
[泛型表示符 泛型约束]

// 示例
[T int | string | float64 ]

type myType interface {
	int | string | float64
}
[T myType]
```

<img src="https://cloud.006288.xyz/PicGo//image-20240223002114674.png" alt="image-20240223002114674" style="zoom: 67%;" />

- 泛型类型不能直接拿来使用，必须传入**类型实参(Type argument)** 将其确定为具体的类型之后才可使用。而传入类型实参确定具体类型的操作被称为 **实例化(Instantiations)**

##### 17.2.2.2 泛型基本使用

- 泛型列表

```go
package main

import "fmt"

type myList[T string | int] [10]T

func main() {
	fmt.Println(myList[int]{1, 2, 3, 4, 5, 6, 7, 8})

	fmt.Println(myList[string]{"a", "b", "c", "d", "e", "f", "g"})
}
```

- 泛型切片

```go
package main

import "fmt"

type mySlice[T string | int | bool] []T

func main() {
	slice1 := make(mySlice[int], 5, 10)
	for i := 0; i < len(slice1); i++ {
		slice1[i] = i
	}
	fmt.Println(slice1)

	fmt.Println(mySlice[string]{"hello", "golang", "gin"})
}
```

- 泛型map

```go
package main

import "fmt"

type myMap[KEY int | string, VALUE int | string | float64] map[KEY]VALUE

func main() {
	fmt.Println(myMap[int, string]{1: "Tom", 2: "Bob"})

	fmt.Println(myMap[string, float64]{"Tom": 88.8, "Bob": 99.9})
}
```

- 泛型结构体

```go
package main

import "fmt"

type person[T any] struct {
	name string
	sex  T
}

func (p person[T]) getSex() T {
	return p.sex
}

func main() {
	fmt.Println(person[string]{"Tom", "男"}.getSex())
}
```

- 泛型接口

```go
package main

import "fmt"

// 定义一个泛型接口
type Container[T any] interface {
	Insert(item T)
	Get() T
}

// 定义一个泛型结构体，并实现泛型接口
type Stack[T any] struct {
	items []T
}

func (s *Stack[T]) Insert(item T) {
	s.items = append(s.items, item)
}

func (s *Stack[T]) Get() T {
	if len(s.items) == 0 {
		// 返回类型参数的零值表示空值
		var zeroVal T
		return zeroVal
	}
	item := s.items[len(s.items)-1]
	s.items = s.items[:len(s.items)-1]
	return item
}

func main() {
	// 创建一个 Stack 类型的实例，并返回这个实例的指针
	stack := &Stack[int]{}
	// 调用Insert方法将1插入栈中
	stack.Insert(1)
	stack.Insert(2)
	stack.Insert(3)

	// 使用泛型接口
	var container Container[int] = stack
	fmt.Println(container.Get()) // Output: 3
	fmt.Println(container.Get()) // Output: 2
	fmt.Println(container.Get()) // Output: 1
	fmt.Println(container.Get()) // Output: 0 (zero value for int)
}

```

> 匿名函数（闭包）本身是支持泛型的，但在匿名函数内部声明的局部变量的类型必须是具体的类型，而不能是泛型类型

##### 17.2.2.3 泛型约束

- 泛型约束是指在使用泛型时对类型参数的一些限制，以确保类型参数满足特定的条件。Go语言的泛型引入了泛型约束，通过接口和类型参数的约束来限制泛型的使用

###### 17.2.2.3.1 内置的约束

- **`comparable` 约束：**
  - `comparable` 约束要求类型参数**必须是可比较的类型**。可比较的类型包括基本类型（如整数、浮点数、字符串）、指针类型、数组类型、结构体类型（只包含可比较的字段）、接口类型（只包含可比较的动态类型和动态值）、切片类型（只包含可比较的元素）、通道类型（只包含可比较的元素）、函数类型（只包含可比较的参数和返回值

```go
// comparable is an interface that is implemented by all comparable types
// (booleans, numbers, strings, pointers, channels, arrays of comparable types,
// structs whose fields are all comparable types).
// The comparable interface may only be used as a type parameter constraint,
// not as the type of a variable.
type comparable interface{ comparable }
```

- **`any` 约束：**
  - `any` 约束表示类型参数可以是任意类型，类似于泛型的通配符

```go
// any is an alias for interface{} and is equivalent to interface{} in all ways.
type any = interface{}
```

###### 17.2.2.3.2 接口约束

- 接口约束在Go语言泛型中是一种常见的约束形式，接口约束允许您在泛型函数或方法中使用接口, 它要求类型参数必须实现指定的接口, ，并确保传入的类型参数满足接口的要求

```go
package main

import "fmt"

// 定义一个接口
type Stringify interface {
	ToString() string
}

// 使用接口约束的泛型函数
func PrintToString[T Stringify](value T) {
	fmt.Println(value.ToString())
}

// 实现接口的结构体
type Person struct {
	Name string
}

func (p Person) ToString() string {
	return "Person: " + p.Name
}

func main() {
	// 使用接口约束的泛型函数
	person := Person{Name: "John"}
	PrintToString(person) // Output: Person: John

}
```

###### 17.2.2.3.3 自定义约束

- Go语言的泛型系统允许您创建自定义的约束，以便在泛型函数或方法中对类型参数施加特定的要求

```go
type myInt interface {
    int | int8 | int16 | int32 | int64
}
  
type myUint interface {
    uint | uint8 | uint16 | uint32
}
 
type myFloat interface {
    float32 | float64
}
 
type myNumber interface {
  myInt | myUint | myFloat
}
 
type myNumber2 interface {
  myInt | myUint | myFloat | string
}

func Foreach[T myNumber](list []T) {
  for _, t := range list {
    fmt.Println(t)
  }
}
```

###### 17.2.2..3.4 泛型中`~` 符号

- 在Go语言的泛型中，使用 `~` 符号的主要用途是指定泛型类型参数的方法集。自定义类型和底层类型之间存在一个不同的关系。泛型接口不会自动识别自定义类型的底层类型，因此您需要在泛型接口的类型约束中使用 `~` 符号来指定涵盖底层类型   (模糊匹配)

```go
package main

import "fmt"

type myType interface {
	~int | ~float64
}

type myInt int

func test[T myType](t T) {
	fmt.Println(t)
}

func main() {
	test[myInt](2)
}
```

## 18. 网络编程

### 18.1 网络编程基本概述

#### 18.1.1 基本概念

- **网络编程定义**:

  - 网络编程是一种计算机编程技术，它使应用程序能够在网络上进行通信。网络编程涉及到设计、开发和维护应用程序，这些应用程序使用网络协议来实现在不同计算机或设备之间传输数据的能力。

  - 当使用 Go 实现 TCP/UDP 网络编程时，是指使用 Go 语言编写程序来利用 TCP/UDP 协议进行网络通信。


- **网络编程的主要内容:**
  
  - **应用程序设计**：网络编程需要设计应用程序的功能和通信方式。应用程序通常包括客户端和服务器端。客户端应用程序用于向服务器发送请求，并接收服务器响应。服务器端应用程序接收请求并提供响应。
    - 建立连接
    - 数据交换
  - **网络协议**：网络编程需要了解和使用一系列网络协议，如TCP/IP、HTTP、SMTP等。这些协议定义了数据传输的格式和方式，以及数据的解释方式。
  
  - **编程语言和工具**：网络编程需要使用编程语言和工具来实现应用程序的功能。常用的编程语言包括Java、C++、Python等。常用的网络编程工具包括套接字（socket）编程、HTTP客户端和服务端框架、RESTful API框架等







- **网络应用的设计模式**

  - C/S架构：Client/Server架构，我们平常手机中使用的app、电脑中的QQ音乐等软件这些都是C/S架构

    - 传统的网络应用设计模式，客户机（Client）/服务器（Server）模式，需要在通讯两端各自部署客户机和服务器来完成数据通信

    ![image-20240107221659945](https://cloud.006288.xyz/PicGo//image-20240107221659945.png)

  - B/S架构：Browser/Server架构，我们进入浏览器里的浏览的网页哪些全部都是B/S架构。

    - 浏览器（Browser）/服务器（Server）模式，只需在一端部署服务器，而另外一端使用每台 PC 都默认配置的浏览器即可完成数据的传输

  ![image-20240107221730216](https://cloud.006288.xyz/PicGo//image-20240107221730216.png)

  > C/S架构与socket的关系：`socket实现C/S架构的Client和Server端的数据交互的`，注意：B/S架构是不需要socket的

#### 18.1.2 什么是套接字(socket)

- 套接字（Socket）是一种抽象层，用于在计算机网络上进行进程间通信或主机间通信。
- 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket

- socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口
- Socket 的英文意思是“孔”或“插座”，作为 BSD UNIX 的进程通信机制，取后一种意思，通常也称作“套接字”，用于描述 **IP 地址和端口**，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信



- 常用的 Socket 类型有两种，分别是流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）：
  - 流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；
  - 数据报式 Socket 是一种无连接的 Socket，对应于无连接的 UDP 服务应用

![image-20240107223834484](https://cloud.006288.xyz/PicGo//image-20240107223834484.png)

#### 18.1.3 go语言网络编程

-  **go语言网络编程的主要类型**:

  - **TCP/UDP 编程**：用以实现客户端和服务器之间的数据传输

  - **HTTP 编程**：用以实现http客户端和服务器

  - **WebSocket 编程**：用以实现客户端和服务器之间的双向通信

  - **RPC 编程**：实现远程程序调用。RPC（Remote Procedure Call）是一种网络编程模型，也就是远程过程调用。它允许一个程序调用另一个程序中的函数或方法，即使这两个程序在不同的机器上运行。RPC 抽象了网络通信的细节，使得调用远程函数就像调用本地函数一样简单。

- **go语言网络编程库**:

  - **net 包：**
    - Go 语言的标准库中的 `net` 包提供了基础的网络编程支持，包括 TCP、UDP、Unix 域套接字等。它包含了 `net.Dial`、`net.Listen`、`net.Conn` 等接口和函数，用于创建和管理网络连接
  - **net/http 包：**
    - `net/http` 包是 Go 语言标准库中用于构建 HTTP 服务器和客户端的核心包。它提供了处理 HTTP 请求和响应的方法，支持路由、中间件等
  - **github.com/gin-gonic/gin：**
    - `gin` 是一个轻量级的 Web 框架，基于 `net/http` 包。在生产环境中，`gin` 可以用于构建高性能的 HTTP 服务器，提供了路由、中间件等功能
  - **github.com/grpc/grpc-go：**
    - `gRPC` 是一个高性能、开源和通用的 RPC（远程过程调用）框架，支持多种编程语言，包括 Go。在企业环境中，`gRPC` 可以用于构建分布式系统，实现服务之间的通信
  - **github.com/gorilla/websocket：**
    - `gorilla/websocket` 是一个流行的第三方库，提供了对 WebSocket 协议的支持。WebSocket 允许在单个 TCP 连接上进行双向通信，适用于实时应用程序和实时更新
  - **github.com/labstack/echo：**
    - `echo` 是另一个流行的 Web 框架，轻量且易于使用。它基于 `net/http` 包，提供了路由、中间件等功能

### 18.2 TCP socket编程

- TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网际协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议，因为是面向连接的协议，数据像水流一样传输，会存在黏包问题

- TCP服务端

```go
// 监听端口
// 接收客户端请求建立链接
// 创建goroutine处理链接。(可以每建立一次链接就创建一个goroutine去处理)
```

- TCP客户端

```go
// 与服务端建立链接
// 发送请求数据,接收服务端数据返回
// 关闭链接
```

#### 18.2.1 TCP socket编程基本使用

- TCP服务端

```go
package tcpDemo

import (
	"fmt"
	"io"
	"net"
)

func TCPServer() {
	Addr := &net.TCPAddr{
		IP:   net.ParseIP("0.0.0.0"),
		Port: 9999,
	}

	listentPort, err := net.ListenTCP("tcp", Addr)
	if err != nil {
		fmt.Println("服务端启动失败")
		return
	}
	fmt.Println("服务端启动成功,等待客户端连接.....")

	for {
		conn, err := listentPort.Accept()
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Printf("客户端[%v]已连接\n", conn.RemoteAddr())
		go messageRead(conn)
	}
}

func messageRead(conn net.Conn) {
	defer func(conn net.Conn) {
		err := conn.Close()
		if err != nil {
			fmt.Println(err)
		}
	}(conn)

	buf := make([]byte, 1024)
	for {
		n, err := conn.Read(buf)
		if err != nil {
			if err == io.EOF {
				fmt.Printf("客户端[%v]断开连接\n", conn.RemoteAddr())
				return
			}
			fmt.Println(err)
			return
		}
		fmt.Println(string(buf[:n]))

		_, err = conn.Write([]byte("Received"))
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Printf("服务端已回复客户端[%v]\n", conn.RemoteAddr())
	}
}

```

- TCP客户端

```go
package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"strings"
)

func TCPClient() {
	// 与服务端建立链接
	conn, err := net.Dial("tcp", "192.168.1.4:9999")
	defer func(conn net.Conn) {
		err := conn.Close()
		if err != nil {

		}
	}(conn)

	if err != nil {
		fmt.Println("链接建立失败!", err)
		return
	}
	// 从标准输入中获取数据
	reader := bufio.NewReader(os.Stdin)
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			fmt.Println(err)
			return
		}
		// 去除输入数据的空格,换行,回车
		line = strings.Trim(line, " \r\n")
		if line == "exit" {
			fmt.Println("客户端断开链接")
			break
		}

		_, err = conn.Write([]byte(line))
		if err != nil {
			fmt.Println(err)
		}
		b := make([]byte, 128)
		n, err := conn.Read(b)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println("收到服务端h: ", string(b[:n]))
	}

}

func main() {
	TCPClient()
}
```

#### 18.2.2 黏包

##### 18.2.2.1 什么时黏包

- 粘包是指网络通信中，发送方发送的多个数据包在接收方的缓冲区黏在一起，多个数据包首尾相连的现象。
- 例如，基于tcp的套接字实现的客户端向服务器上传文件时，内容往往是按照一段一段的字节流发送的，如果不做任何处理，从接收方来看，根本不知道该文件的字节流从何处开始，在何处结束。
- 因此，所谓粘包问题主要是因为接收方不知道消息之间的界限，不知道一次提取多少字节的数据造成的

![image-20240110234938385](https://cloud.006288.xyz/PicGo//image-20240110234938385.png)

##### 18.2.2.2 产生黏包的原因

- 粘包产生的原因有发送方和接收方两方面：
  - 发送方引起粘包的原因主要是由tcp协议本身造成的。众所周知，**tcp协议是面向连接，面向流，提供高可靠性服务的**。tcp数据包转发使用Nagle算法，Nagle算法是为了提高tcp的传输效率
  - 简单来说，当应用层有一个数据包要发送时，Nagle算法并不会立刻发送，而是继续收集要发送的消息，直到上一个包得到确认时，才会发送数据，此时Nagle算法会将收集的多个的数据包形成一个分组，将这个分组一次性转发出去。因此，Nagle算法造成了发送方可能存在粘包现象

![image-20240111001155424](https://cloud.006288.xyz/PicGo//image-20240111001155424.png)

- 接收方引起粘包的原因主要是由于接收方对数据包的处理速度远小于数据包的接收速度导致接收缓冲区的数据积压而造成的

> Nagle算法要求一个tcp连接上最多只能有一个未被确认的未完成的小分组，在该分组ack到达之前不能发送其他的小分组，tcp需要收集这些少量的分组，并在ack到来时以一个分组的方式发送出去；其中小分组的定义是小于MSS的任何分组； 该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发哦送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组

##### 18.2.2.3 黏包现象

```go
// 服务端
package main

import (
	"bufio"
	"fmt"
	"io"
	"net"
)

func main() {
   l, err := net.Listen("tcp", ":4044")
   if err != nil {
   	panic(err)
   }
   fmt.Println("listen to 4044")
   for {
       // 监听到新的连接，创建新的 goroutine 交给 handleConn函数 处理
   	conn, err := l.Accept()
   	if err != nil {
   		fmt.Println("conn err:", err)
   	} else {
   		go handleConn(conn)
   	}
   }
}

func handleConn(conn net.Conn) {
   defer conn.Close()
   defer fmt.Println("关闭")
   fmt.Println("新连接：", conn.RemoteAddr())

   result := bytes.NewBuffer(nil)
   var buf [1024]byte
   for {
   	n, err := conn.Read(buf[0:])
   	result.Write(buf[0:n])
   	if err != nil {
   		if err == io.EOF {
   			continue
   		} else {
   			fmt.Println("read err:", err)
   			break
   		}
   	} else {
   		fmt.Println("recv:", result.String())
   	}
   	result.Reset()
   }
}


// 客户端
package main

import (
	"fmt"
	"net"
)

func main() {
	data := []byte("[这里才是一个完整的数据包]")
	conn, err := net.DialTimeout("tcp", "localhost:4044", time.Second*30)
	if err != nil {
		fmt.Printf("connect failed, err : %v\n", err.Error())
        return
	}
	for i := 0; i <1000; i++ {
		_, err = conn.Write(data)
		if err != nil {
			fmt.Printf("write failed , err : %v\n", err)
			break
		}
	}
}
```

- 运行结果

```go
listen to 4044
新连接： [::1]:53079
recv: [这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据�
recv: �][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包][这里才是一个完整的数据包][这里才是一个完整的数据包]
recv: [这里才是一个完整的数据包]
...省略其它的...



// 从服务端的控制台输出可以看出，存在三种类型的输出：
一种是正常的一个数据包输出。
一种是多个数据包“粘”在了一起，我们定义这种读到的包为粘包。
一种是一个数据包被“拆”开，形成一个破碎的包，我们定义这种包为半包
```

##### 18.2.2.4 黏包解决方法

- 应用层常用的几种解决TCP粘包问题的协议和技术如下:
  - **定长包协议**（Fixed-Length Protocol）：发送方将每个数据包固定长度，不足部分用补齐字符填充。接收方按照固定长度截取数据，确保每个数据包长度一致，从而避免粘包问题
  - **特殊标志协议**（Delimiter-based Protocol）：发送方在每个数据包尾部添加特殊标志如特定的换行符（如’\n’），接收方通过识别换行符来划分不同的数据包
  - **长度字段协议**（Length-Field Protocol）：发送方在每个数据包前部添加一个表示数据包长度的字段，接收方根据该长度字段来解析数据包边界，确保正确分离每个数据包。长度字段可以是固定长度，也可以采用变长编码方式**(推荐做法)**
  - **自定义协议**：应用层可以设计自定义的协议，通过在数据包中使用特定的标识符、头部信息或其他约定进行数据分隔和解析协议和技术可以在应用层上增加更高级的数据隔机制，使得应用程序能够正确解析和处理数据，避免粘包问题。选择适合具体应用场景和需求的协议，可以提高数据传输的可靠性和正确性**(推荐做法)**

> 这些协议和技术需要发送方和接收方之间达成一致并正确实现，以确保数据的准确分隔和解析。双方都应按照协议规范进行数据的发送和接收处理，以免仍然出现数据解析错误的情况



- **使用长度字段协议解决**

  - 在客户端发送数据时，进行封包；在服务端读取数据时，进行拆包

  - 封包:
    - 输入消息实体，在消息前面添加一个消息头，包含消息的长度信息,  返回消息长度与消息实体组成的字节流，客户端发送消息时调用进行封包

  - 拆包:
    - 输入二进制字节流，前4个字节为消息长度，后面为消息实体，返回消息实体，服务端接收消息时调用进行解包

```go
// 封包
func MakPkg(message string) ([]byte, error) {
	// 消息头(消息长度占4个字节,使用int32类型)
	messageLen := int32(len(message))
	buf := bytes.NewBuffer([]byte{})

	// 写入消息头部,将消息长度写入缓存区
	if err := binary.Write(buf, binary.LittleEndian, messageLen); err != nil {
		fmt.Println("消息头写入有误!")
		return nil, err
	}
	// 写入消息实体,将消息实体写入缓存区
	if err := binary.Write(buf, binary.LittleEndian, []byte(message)); err != nil {
		fmt.Println("消息体写入有误!")
		return nil, err
	}
	// 返回封装结果
	return buf.Bytes(), nil
}


// 拆包
func UnPkg(reader *bufio.Reader) (string, error) {
	// 读取消息长度,前四个字节
	lenByte, err := reader.Peek(4) // peek操作只读数据，但不会移动读取位置
	if err != nil {
		return "", err
	}

	var messageLen int32
	lenbByeBuf := bytes.NewBuffer(lenByte)

	// 将前四个字节读入缓存区
	if err := binary.Read(lenbByeBuf, binary.LittleEndian, &messageLen); err != nil {
		return "", err
	}

	// 检查缓存区是否可以容纳该消息
	if int32(reader.Buffered()) < messageLen + 4 {
		return "", errors.New("缓冲区长度不足以容纳整个消息")
	}

	// 读取消息体
	message := make([]byte, int(messageLen)+4)
	_, err = reader.Read(message)
	if err != nil {
		return "", err
	}
	return string(message[4:]), nil
}
```

- 如果已经有完整的消息字节切片，且希望简洁直接地进行处理可以使用下面这个

```go
// 封包函数
func packMessage(message string) []byte {
	messageLength := len(message)
	header := make([]byte, HeaderSize)
	binary.BigEndian.PutUint32(header, uint32(messageLength))

	packet := append(header, []byte(message)...)
	return packet
}

// 拆包函数
func unpackMessage(data []byte) (string, error) {
	header := data[:HeaderSize]
	messageLength := binary.BigEndian.Uint32(header)

	message := data[HeaderSize : HeaderSize+messageLength]
	return string(message), nil
}
```



> buf创建:
>
> - **`buf := make([]byte, 1024)`：**
>
>   - **适用场景：** 如果你有一个固定大小的消息或者你希望明确控制内存的分配，使用固定大小的切片是合适的。
>
>   - **优点：** 明确指定大小，适用于预知的固定大小消息。
>
>   - **缺点：** 如果消息大小不固定，可能需要多次扩展切片大小，带来额外的复杂性和内存开销
>
> - **`var pkg = new(bytes.Buffer)`：**
>
>   - **适用场景：** 如果你需要一个动态扩展的缓冲区，并且方便使用标准库中的 `bytes.Buffer` 方法，这是一个不错的选择。
>   - **优点：** 动态扩展，方便使用标准库方法，接口实现了 `io.ReadWriter`。
>   - **缺点：** 内部可能涉及额外的内存分配，因为它是动态扩展的
>
> - **`buffer := bytes.NewBuffer([]byte{})`：**
>
>   - **适用场景：** 与上述 `var pkg = new(bytes.Buffer)` 类似，创建了一个初始为空的 `bytes.Buffer`。
>   - **优点：** 明确地初始化为空，适用于从空缓冲区开始的情况。
>   - **缺点：** 与 `var pkg` 类似，可能涉及额外的内存分配
>
> > 在实际应用中，如果你不确定消息大小，且希望灵活应对动态数据，使用 `bytes.Buffer` 可能更为方便。如果消息大小是已知的，且你希望精确控制内存的使用，使用 `make([]byte, 1024)` 可能更为合适



### 18.3 UDP socket编程

- UDP协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域

> udp协议不会出现粘包，因为**udp是无连接，面向消息，提供高效服务的**。无连接意味着当有数据包要发送时，udp会立即发送，数据包不会积压；面向消息意味着数据包一般很小，因此接收端处理也不会很耗时，一般不会由于接收端来不及处理而造成粘包。**最重要的时，udp不使用合并优化算法，每个消息都有单独的包头，即使出现很短时间内收到多个数据包的情况，接收方也能根据包头信息区分数据包之间的边界。**因此，udp不会出现粘包，只可能会出现丢包

- 服务端

```go
package tcpDemo

import (
	"fmt"
	"net"
)

func UDPServer() {
	addr := net.UDPAddr{
		IP:   net.IPv4(0, 0, 0, 0),
		Port: 9999,
	}

	listenPort, err := net.ListenUDP("udp", &addr)
	if err != nil {
		fmt.Println("服务端启动失败")
		return
	}
	fmt.Println("服务端启动成功,等待客户端链接....")
	defer listenPort.Close()

	for {
		bufRead := make([]byte, 1024)
		n, addr, err := listenPort.ReadFromUDP(bufRead[:])
		if err != nil {
			continue
		}
		fmt.Printf("收到客户端[%v]的消息: %v\n", addr, string(bufRead[:n]))

		n, err = listenPort.WriteToUDP([]byte("Received"), addr)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Printf("回复[%v]客户端成功! \n", addr)
	}

}

```

- 客户端

```go
// socket_test/client/main.go
package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
)

func main() {
	addr := net.UDPAddr{
		IP:   net.IPv4(192, 168, 37, 10),
		Port: 9999,
	}

	conn, err := net.DialUDP("udp", nil, &addr)
	if err != nil {
		fmt.Println("服务端链接失败")
		return
	}
	defer conn.Close()

	fmt.Println("服务端链接成功")

	buf := bufio.NewReader(os.Stdin)
	line, err := buf.ReadString('\n')
	if err != nil {
		fmt.Println(err)
		return
	}

	_, err = conn.Write([]byte(line))
	if err != nil {
		fmt.Println("发送失败", err)
		return
	}

	bufRead := make([]byte, 1024)
	n, add, err := conn.ReadFromUDP(bufRead)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("地址: %v, 内容: %v\n", add, string(bufRead[:n]))

} 
```

### 18.4 http编程

- http协议相关概述[[chrony+rsync+nfs+nginx#7 HTTP协议]]]
- Web服务器的工作原理可以简单地归纳为
  - 客户机通过TCP/IP协议建立到服务器的TCP连接
  - 客户端向服务器发送HTTP协议请求包，请求服务器里的资源文档
  - 服务器向客户机发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端
  - 客户机与服务器断开。由客户端解释HTML文档，在客户端屏幕上渲染图形结果

#### 18.4.1 基本概述

- *Go语言*标准库内建提供了`net/http`包,涵盖了*HTTP*客户端和服务端的具体实现。
- 使用net/http包,我们可以很方便地编写HTTP客户端或服务端的程序, 只需要短短几行代码，就可以实现一个简单的http server,加上协程的加持,Go实现的http server拥有非常优秀的性能
- 除去细节，理解 HTTP 构建的网络应用只要关注两个端---客户端（clinet）和服务端（server），两个端的交互来自 clinet 的 request，以及server端的response。
- 所谓的http服务器，主要在于如何接受 clinet 的 request，并向client返回response。接收request的过程中，最重要的莫过于路由（`router`），即实现一个`Multiplexer`器。Go中既可以使用内置的mutilplexer --- `DefautServeMux`，也可以自定义。Multiplexer路由的目的就是为了找到处理器函数（`handler`），后者将对request进行处理，同时构建response
- 理解go中的http服务，最重要就是要理解Multiplexer和handler，Golang中的Multiplexer基于`ServeMux`结构，同时也实现了`Handler`接口

![image-20240124211839537](https://cloud.006288.xyz/PicGo//image-20240124211839537.png)

#### 18.4.2 快速入门

##### 18.4.2.1 启动web服务器

- Go语言创建一个服务器的步骤非常简单，只要调用ListenAndServe并传入网络地址以及负责处理请求的处理器(handler)作为参数就可以了。如果网络地址为空字符串，那么服务器默认使用80端口进行网络连接；如果处理器参数为nil,那么服务器将使用默认的多路复用器DefaultServeMux

```go
package main
 
import "net/http"
 
func main() {
	http.ListenAndServe("", nil)
}
```

- 除了可以通过ListenAndServe的参数对服务器的网络地址和处理器进行配置之外，还可以通过Server结构对服务器进行更详细的配置，其中包括为请求读取操作设置超时时间，为响应写入操作设置超时时间、为Server结构设置错误日志记录器等

```go
package main
 
import "net/http"
 
func main() {
	server := http.Server{
		Addr:    "127.0.0.1:8080",
		Handler: nil,
	}
	server.ListenAndServe()
}
```

##### 18.4.2.2 编写处理器和注册路由

- 启动了一个web服务器，但是我们访问这个服务器地址会得到：404 page not found 的信息。
- 出现这一问题的原因是我们没有为服务器编写任何处理器，服务器的多路复用器在接收到请求之后找不到任何处理器来处理请求，因此它只能返回一个404响应。为了让服务器能够产生实际的响应结果，我们需要编写处理器



- 处理器和处理器函数

  - **处理器**

    - 处理器和处理器函数是不同的，在Go语言中,**一个处**

      **器就是一个拥有ServeHTTP方法的接口**，这个ServeHTTP方法需要接收两个参数:第一个参数是一个ResponseWriter接口，而第二个参数则是一个指向Request结构的指针。

    - 换句话说，任何接口只要拥有一个ServeHTTP方法，并且该方法带有(http.ResponseWriter, *http.Request)签名,那么它就是一个处理器

    > ServeHTTP为什么要接受ResponseWriter接口和一个指向Request结构的指针作为参数呢？
    >
    > - ServeHTTP函数的两个参数传递的都是引用传递,为了让服务器能够觉察到处理器对Request结构的修改
    >
    > - ResonseWriter看起来像是ServeHTTP是以传值的方式接受ResponseWriter但, 实际上就是response这个非导出结构的接口，而ResponseWriter在使用response结构时，传递的也是指向response 结构的指针, 虽然ResponseWriter看上去是一个值，但它却是一个带有结构指针的接口

  - **处理函数**

    - 处理器函数实际上就是与处理器拥有相同行为的函数，这些函数与ServeHTTP方法拥有相同的签名, 处理器函数的实现原理也很简单：Go语言拥有一种HandlerFunc函数类型，它可以把一个带有正确签名的函数f转换成一个带有方法f的Handler

    - 处理器函数只不过是创建处理器的一种便利的方法而已

```go
package main

import (
	"fmt"
	"net/http"
)

// 编写一个处理器
type Hellohandler struct{}

func (h *Hellohandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "This is Hello package")
}

// 编写一个处理器函数
func TestHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Thisi is Test package")
}

func main() {
	handler := Hellohandler{}
	server := http.Server{
		Addr: ":8888",
	}
    
    // 注册路由
	http.Handle("/hello", &handler)
	http.HandleFunc("/test", TestHandler)
	if err := server.ListenAndServe(); err != nil {
		fmt.Println("监听失败", err)
	}

}
```

![image-20240124224343156](https://cloud.006288.xyz/PicGo//image-20240124224343156.png)

#### 18.4.2 实现原理

- 作为http服务端处理一次请求应该具备以下行为
  - 实现处理函数
  - 路由映射
  - 监听请求
  - 分发请求并处理请求

##### 18.4.2.1 ServeMux(路由器)

- 在`net/http` 包里的 `server.go` 文件里注释写着：ServeMux is an HTTP request multiplexer. 即 ServeMux 是一个 HTTP 请求的 “多路处理器”，因为 ServeMux 实现的功能就是将收到的 HTTP 请求的 URL 与注册的路由相匹配，选择匹配度最高的路由的处理函数来处理该请求

###### 18.4.2.1.1 ServeMux的定义

```go
type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry   // 基于路径匹配
	es    []muxEntry			// 基于主机名匹配
	hosts bool
}

// 字段解释:
// mu 是一个读写互斥锁，用于保护m和es字段的并发访问。sync.RWMutex允许多个读操作同时进行，但只有一个写操作可以进行

// m 是一个映射（map），用于将HTTP请求的路径（pattern）与相应的处理器（handler）关联起来(路由)。其中，string表示路径，muxEntry表示处理器的相关信息

// es 是一个切片, 用于存储与主机关联的处理函数。在处理请求时，会优先匹配具体路径模式(m)，如果没有匹配成功，则会查找并执行这个切片(es)中的处理函数

// hosts 这是一个标志，表示ServeMux是否支持主机名的匹配。如果为true，表示ServeMux会考虑请求的主机名进行匹配；如果为false，只匹配路径




// muxEntry定义:(用于存储路由信息)
type muxEntry struct {
	h       Handler
	pattern string
}

// h 类型为 Handler，表示与该条目关联的处理器。Handler 是一个接口，包含了 ServeHTTP 方法，用于处理HTTP请求
// pattern 表示与该处理器关联的路径模式。这是一个简单的字符串，用于匹配HTTP请求的路径
```

- ServeMux 暴露的方法主要是下面 4 个

```go
func (mux *ServeMux) Handle(pattern string, handler Handler)
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))
func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string)
func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)

// Handle和HandleFunc方法主要用于路由注册,我们下一小节在讲
```

###### 18.4.2.1.2 ServeMux 的方法

- Handler方法

  - 这个方法的作用是根据传入的 `Request` 对象找到匹配的路由，并返回与该路由相关联的处理程序以及匹配的模式

  - 方法的签名为 `Handler(r *Request) (h Handler, pattern string)`，它接受一个指向 `Request` 类型的指针作为参数，并返回两个值，一个是 `Handler` 类型的值（即处理器），另一个是字符串（即匹配的路径模式）

  - 源码剖析

    - 在看 `Handler` 的实现前，先看看它调用的 `handler` 方法

    ```go
    func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
        mux.mu.RLock()
        defer mux.mu.RUnlock()
     
        // 若当前 mux 中注册有带主机名的路由，就用"主机名+路由路径"去匹配
        // 也就是说带主机名的路由优先于不带的
        if mux.hosts {
            h, pattern = mux.match(host + path)
        }
        // 所以若没有匹配到，就直接把路由路径拿去匹配
        if h == nil {
            h, pattern = mux.match(path)
        }
        // 若都没有匹配到，就默认返回 NotFoundHandler，该 Handler 会往响应里写上 "404 page not found"
        if h == nil {
            h, pattern = NotFoundHandler(), ""
        }
        // 返回获得的 Handler 和路由路径
        return
    }
    ```

    - 现在再看`Handler`方法

    ```go
    func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
        
        //检查HTTP请求的方法是否为CONNECT。CONNECT是一种用于建立与代理的隧道连接的请求方法
    	if r.Method == "CONNECT" {
            // 如果 HTTP 请求方法为 CONNECT（用于隧道连接），
            // 则执行以下逻辑。
    
            // 检查是否需要对请求路径进行重定向。
            // 如果 r.URL.Path 为 /tree 且其处理器未注册，
            // 则 /tree -> /tree/ 重定向适用于 CONNECT 请求，
            // 但路径规范化不适用于 CONNECT 请求。
    		if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {
                // 如果需要重定向，创建一个 RedirectHandler
               // 指向新的 URL，并返回它以及新的路径。使用 301 永久重定向状态码。
    			return RedirectHandler(u.String(), StatusMovedPermanently), u.Path
    		}
    		//如果不需要重定向，调用 mux.handler 方法。
            // 该方法根据请求的 Host 和 Path 查找相应的处理器。
    		return mux.handler(r.Host, r.URL.Path)
    	}
        
        
        // 去掉主机名上的端口号
        host := stripHostPort(r.Host)
        // 整理 URL，去掉 ".", ".."
        path := cleanPath(r.URL.Path)
     
        // redirectToPathSlash 在 mux.m 中查看 path+"/" 是否存在
        // 如果存在，RedirectHandler 就将该请求重定向到 path+"/"
        if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {
            return RedirectHandler(u.String(), StatusMovedPermanently), u.Path
        }
     
        // 如果整理后的 URL 与请求中的路径不一样，先调用 handler 进行匹配
        // 在将请求里的 URL 改成整理后的 URL
        // 最后将该请求重定向到整理后的 URL
        if path != r.URL.Path {
            _, pattern = mux.handler(host, path)
            url := *r.URL
            url.Path = path
            return RedirectHandler(url.String(), StatusMovedPermanently), pattern
        }
        // 若以上条件都不满足则返回匹配结果
        return mux.handler(host, r.URL.Path)
    }
    ```

    - 上面handler进行路由匹配,其实是调用ServeMux的math方法进行匹配
      - 它的作用是根据给定的路径 `path` 在已注册的路由规则中查找匹配的处理器和路径模式

    ```go
    func (mux *ServeMux) match(path string) (h Handler, pattern string) {
        // 查找已注册路由映射:
        // 若 mux.m 中已存在该路由映射，直接返回该路由的 Handler，和路径
        v, ok := mux.m[path]
        if ok {
            return v.h, v.pattern
        }
     	
        // 最长匹配:
        // 找到路径能最长匹配的路由。
        // 是在 mux.es 中进行查找，而不是映射表 mux.m 中，而 mux.es 是存放所有以 “/” 结尾的路由路径的切片。因为只会在以 “/” 结尾的路由路径中才会出现需要选择最长匹配方案
        // 另外，为了减少在 mux.es 中的查询时间， mux.es 中元素是按照它们的长度由大到小顺序存放的
        for _, e := range mux.es {
            if strings.HasPrefix(path, e.pattern) {
                return e.h, e.pattern
            }
        }
        return nil, ""
    }
    
    
    // 理解:
    // 比如注册的路由有:
    mux.HandleFunc("/a/b/", ab)
    mux.HandleFunc("/a/", a)
    
    // 当一个请求的 URL 为 /a/b/c 的时候，我们希望是由 ab 来处理这个请求
    ```

- ServeHTTP 方法

  - ServeMux 结构体的ServeHTTP方法
    - ServeMux 是一个结构体，它的 `ServeHTTP` 方法要做的就是将每个请求派遣(dispatch)到它们对应的处理函数上

  ```go
  func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
      // 如果请求的 RequestURI 为 "*"，表示不合法的请求
      if r.RequestURI == "*" {
          // 如果请求协议至少是 1.1 版本，则设置 Connection 为 "close", 告诉浏览器该连接已关闭
          if r.ProtoAtLeast(1, 1) {
              w.Header().Set("Connection", "close")
          }
          // 返回 400 Bad Request
          w.WriteHeader(StatusBadRequest)
          return
      }
  
      // 调用 mux.Handler 方法获取匹配的处理器
      h, _ := mux.Handler(r)
      
      // 调用找到的处理器的 ServeHTTP 方法处理请求
      h.ServeHTTP(w, r)
  }
  
  ```

  

  - 实现`Handler` 接口的 `ServeHTTP` 方法
    - 在 Go 中要实现一个处理请求的 handler 结构体需要让该结构体实现`Handler` 接口的 `ServeHTTP` 方法
      - `ServeHTTP` 方法的作用是将 `ServeMux` 对象转换为一个实现了 `http.Handler` 接口的处理器，以便能够被直接传递给 `http.ListenAndServe` 函数，用于处理传入的 HTTP 请求
      - `ServeHTTP` 方法实现了 `http.Handler` 接口的要求，该接口定义了一个用于处理 HTTP 请求的方法 `ServeHTTP`。通过实现这个方法，`ServeMux` 就能够充当一个 HTTP 请求的中央调度器，根据请求的路径选择合适的处理器来处理请求

  ```go
  // Handler 接口
  type Handler interface {
      ServeHTTP(ResponseWriter, *Request)
  }
   
  type myHandler struct {}
   
  func (h *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
      w.Write([]byte("This message is from myHandler."))
  }
   
  func main() {
      http.Handle("/", &helloHandler{})  // 路由注册
  }
  ```

- 方法总结:
  - `Handle` 和 `HandleFunc` 方法用来将路由路径与处理函数的映射通过一个 map 记录到当前的 mux 实例里；
  -  `Handler` 方法将接收的请求中的 URL 预处理后拿去和记录的映射匹配，若匹配到，就返回该路由的处理函数和路径； 
  - `ServeHTTP` 方法将请求派遣给匹配到的处理函数处理



###### 18.4.2.1.3 默认路由(DefaultServeMux) 

- `DefaultServeMux` 是 Go 语言中的一个默认的 `ServeMux` 实例。它是一个全局的、默认的多路复用器，是 `http.ServeMux` 类型的默认对象,  用于处理 HTTP 请求的路由。
- 当使用 `http.Handle` 或 `http.HandleFunc` 注册处理器函数时，如果没有指定使用哪个 `ServeMux`，它们会默认使用 `DefaultServeMux`

- DefaultServeMux定义

```go
var DefaultServeMux = &defaultServeMux
var defaultServeMux ServeMux
 
type ServeMux struct {
    mu    sync.RWMutex
    m     map[string]muxEntry
    hosts bool
}


type muxEntry struct {
    h       Handler
    pattern string
}

// 我们可以看到DefaultServeMux并不是ServeMux的实现, 实际上是ServeMux的一个实例, 它是一个特殊的处理器
```

- `DefaultServeMux` 在本质上就是一个 `ServeMux`，但它具有一些默认的路由规则，主要负责将请求的 URL 路径重定向到相应的处理器。它是一个特殊的默认路由器，用于处理基本的 HTTP 请求路由

###### 18.4.2.1.4 新建一个路由器

- 如果想创建一个自定义的 `ServeMux` 实例，以便更灵活地定义路由规则，可以使用 `http.NewServeMux()` 函数来创建一个新的 `ServeMux`

```go
func NewServeMux() *ServeMux { return new(ServeMux) }

// new 函数会为传入的类型分配空间并返回指向该空间首地址的指针，于是就获取了一个 ServeMux 实例, 通过这个实例，你可以继续注册路由规则，以定义请求的处理逻辑
```



```go
package main

import (
	"net/http"
)

func main() {
	// 创建新的 ServeMux 实例
	myServeMux := http.NewServeMux()

	// 此时 myServeMux 就是一个空的 ServeMux 实例

	// 可以继续通过 myServeMux.HandleFunc 或其他方法注册路由规则

	// 启动 HTTP 服务器，使用自定义的 ServeMux 处理请求
	http.ListenAndServe(":8080", myServeMux)
}

```

##### 18.4.2.2 路由注册(Handle和HandleFunc)

- `http.Handle` 和 `http.HandleFunc` 是用于在 `ServeMux` 中注册处理器的两种方式。它们的作用是将给定的处理器关联到特定的路径，以便在收到请求时能够根据路径选择正确的处理器进行处理

###### 18.4.2.2.1 Handle 方法

- `Handle` 方法用于注册一个处理器（实现了 `http.Handler` 接口的对象）与指定的模式（路径）的关联

```go
func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }

// pattern: 表示路由的路径模式。
// handler: 表示与该路由模式关联的处理器
```

- 这个方法允许你注册一个完整的处理器对象，但是该处理器需要实现 `http.Handler` 接口, 实现`http.Handler` 接口其实就是实现ServeHTTP这个方法, 一个类型只要包含func(ResponseWriter, *Request) 方法即可

```go
// 示例
package main

import (
	"fmt"
	"net/http"
)

type Hellohandler struct{}

func (h *Hellohandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "This is Hello package")
}

func main() {
	handler := Hellohandler{}
	server := http.Server{
		Addr: ":8888",
	}
    // 注册路由
	http.Handle("/hello", &handler)
	if err := server.ListenAndServe(); err != nil {
		fmt.Println("监听失败", err)
	}

}

```

###### 18.4.2.2.2 HandleFunc 方法

- `HandleFunc` 方法用于注册一个处理函数（满足 `func(http.ResponseWriter, *http.Request)` 签名的函数）与指定的模式的关联

```go
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}

// pattern: 表示路由的路径模式。
// handler: 表示与该路由模式关联的处理函数
```

- 这个方法允许你注册一个处理函数，而无需创建实现 `http.Handler` 接口的对象
- 使用HandleFunc时，处理器是自定义的一个包含func(ResponseWriter, *Request)签名的函数，该函数中写自己要实现的逻辑



- HandleFunc原理分析:
  - HandlerFunc其实是调用DefaultServeMux.HandleFunc函数来处理
  - 而DefaultServeMux.HandleFunc函数其实也和Handle一样调用ServeMux.Handle函数来处理
  - 需要注意的是`mux.Handle(pattern, HandlerFunc(handler))`中的HandlerFunc(handler)只不过是将handler方法做了类型转化,  利用这种类型转换，可以将一个 handler 函数转换为一个 Handler 对象，而不需要定义一个结构体，再让这个结构实现 ServeHTTP 方法



- 总结
  - `Handle` 接受一个实现了 `http.Handler` 接口的对象，而 `HandleFunc` 接受一个满足签名的函数
    - 如果有一个已经实现了 `http.Handler` 接口的结构体或对象，使用 `Handle` 注册处理器
    - 如果你有一个满足签名的函数，可以直接使用 `HandleFunc`

##### 18.4.2.3 监听服务

- [参考文章](https://blog.csdn.net/qq_34021712/article/details/109959201)

- net/http 包提供的 http.ListenAndServe() 方法, 该方法用于在指定的 TCP 网络地址 addr 进行监听，然后调用服务端处理程序来处理传入的连 接请求。
- http.ListenAndServe() 方法有两个参数：第一个参数 addr 即监听地址；第二个参数表示服务端处理程序， 通常为空，这意味着服务端调用 http.DefaultServeMux 进行处理，而服务端编写的业务逻 辑处理程序 http.Handle() 或 http.HandleFunc() 默认注入 http.DefaultServeMux 中

###### 18.4.2.3.1 实现原理

- http.ListenAndServe()的定义

```go
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}

// addr: 要监听的 TCP 地址，格式为 "host:port"。
// handler: 处理 HTTP 请求的处理器
```

- 我们可以看到http.ListenAndServe()主要是使用传入的参数初始化了一个Server结构体, 并且调用server的ListenAndServe()方法 (调用`http.ListenAndServe()`之后真正起作用的是`Server`结构体`LisntenAndServe()`方法)
- 如果我们不传具体的参数给`http.ListenAndServe()`，那么它会自动以`":http"`(等价于`":80"`)和`DefaulServeMux`作为参数来创建`Server`结构体实例

```go
// Server结构体的定义

type Server struct {
    // 监听的TCP地址 格式为: host:port 如果为空 默认使用 :http 端口为 80
    Addr string

    // 调用的 handler（路由处理器）, 设为 nil 表示 http.DefaultServeMux
    Handler Handler // handler to invoke, http.DefaultServeMux if nil

    // 如果服务需要支持https协议 需要相应的配置
    TLSConfig *tls.Config

    // 请求超时时间,包含请求头和请求体。
    ReadTimeout time.Duration

    // 请求头超时时间。读取请求头之后，连接的读取截止日期会被重置.
    // Handler可以再根据 ReadTimeout 判断Body的超时时间。
    // 如果ReadHeaderTimeout为零，则使用ReadTimeout的值。如果两者都为零，则不会超时。
    ReadHeaderTimeout time.Duration

    // 响应超时时间。 每当读取新请求的Header时，它将重置。 
    // 与ReadTimeout一样，它也不允许处理程序根据每个请求做出决策。
    WriteTimeout time.Duration

    // 启用keep-alives时,保持连接等待下一个请求的最长时间。
    // 如果IdleTimeout为零，则使用ReadTimeout的值。如果两者都为零，则不会超时。
    IdleTimeout time.Duration

    // 解析请求头的key和value（包括请求行）时将读取的最大字节数。
    // 它不限制请求Body大小。如果为零，则使用DefaultMaxHeaderBytes。
    MaxHeaderBytes int

    // 当 '应用层协议协商 (NPN/ALPN)' 时发生协议升级时，TLSNextProto 需要指定可选的 function 去接管 TLS 连接
    // map的key为: 协商的协议名称。
    // Handler参数应用于处理HTTP请求，如果尚未设置，它将初始化请求的TLS和RemoteAddr。 
    // 函数返回时，连接将自动关闭。 如果TLSNextProto不为nil，则不会自动启用HTTP/2支持。
    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)

    //  当客户端连接状态改变时调用的回调函数。有关详细信息，请参阅ConnState类型常量。
    ConnState func(net.Conn, ConnState)

    // 日志记录对象
    ErrorLog *log.Logger

    // 为来到此服务器的请求指定 context 上下文 ，不设就是 context.Background()
    // 如果BaseContext为nil，则默认值为context.Background()。 
    // 如果为非nil，则它必须返回非nil上下文。
    BaseContext func(net.Listener) context.Context

    // 提供一个函数用于修改新连接的context上下文,提供的ctx是从基上下文派生的，具有ServerContextKey值。
    ConnContext func(ctx context.Context, c net.Conn) context.Context

    // 当服务器关闭时为true
    inShutdown atomicBool // true when when server is in shutdown

    // 关闭 keep-alives
    disableKeepAlives int32     // accessed atomically.
    nextProtoOnce     sync.Once // guards setupHTTP2_* init
    nextProtoErr      error     // result of http2.ConfigureServer if used

    // 互斥锁 保证资源的安全
    mu         sync.Mutex
    // 监听socket表
    listeners  map[*net.Listener]struct{}
    // 存活的客户端链接表
    activeConn map[*conn]struct{}
    // 用于通知服务关闭 信道
    doneChan   chan struct{}
    // 注册服务器关闭执行的一些行为
    // 通过 RegisterOnShutdown 注册，在 Shutdown 时调用当中的钩子函数
    onShutdown []func()
}

```

- 看完Server的定义后,我们看一下server.ListenAndServe()方法,毕竟前面的一切都是在为它做准备

```go
// server.ListenAndServe()定义

func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed    // 如果Server已关闭,直接返回 ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":http"   // 如果不指定服务器地址信息，默认以":http"作为地址信息
	}
	ln, err := net.Listen("tcp", addr)    // 创建TCPListener，接收客户端的连接请求
	if err != nil {
		return err
	}
	return srv.Serve(ln)    // 调用Server.Serve()函数并返回
}

// 仔细一看,这其实就是在建立TCP链接
// net.Listen() 方法监听本地的网络地址，network参数可以是 tcp、tcp4、tcp6、 unix 或者 unixpacket。address 参数可以用主机名(hostname)，但是不建议，因为这样创建的listener(监听器)最多监听主机的一个IP地址。如果 address 参数的 port 为空或者"0"，如"127.0.0.1:"或者"[::1]:0"，将自动选择一个端口号
```

- `server.ListenAndServe()`函数的主要作用就是初始化一个 `TCPListener` 结构体的实例，然后调用`Server.Serve()`方法为这个连接提供服务

```go
// Server.Serve()定义

func (srv *Server) Serve(l net.Listener) error {
    // 测试用的钩子函数，一般用不到
    if fn := testHookServerServe; fn != nil {
        fn(srv, l) // call hook with unwrapped listener
    }

    origListener := l
    // onceCloseListener 包装 net.Listener，用于防止多次关闭链接
    // sync.Once.Do(f func()) 能保证once只执行一次
    l = &onceCloseListener{Listener: l}
    // 结束的时候关闭监听socket
    defer l.Close()

    // http2相关的设置
    if err := srv.setupHTTP2_Serve(); err != nil {
        return err
    }

    // 把监听socket添加监听表
    if !srv.trackListener(&l, true) {
        return ErrServerClosed
    }
    // 结束的时候从监听表删除
    defer srv.trackListener(&l, false)

    // 获取一个非 nil 的 上下文。
    baseCtx := context.Background()
    if srv.BaseContext != nil {
        baseCtx = srv.BaseContext(origListener)
        if baseCtx == nil {
            panic("BaseContext returned a nil context")
        }
    }

    // 设置临时过期时间，当accept发生 错误的时候等待一段时间
    var tempDelay time.Duration // how long to sleep on accept failure

    // 把server本身放入上下文，用于参数传递，可以在 其他子协程中 根据 ServerContextKey 获取到 srv
    ctx := context.WithValue(baseCtx, ServerContextKey, srv)
    // 循环监听客户端到来
    for {
        // accept 阻塞等待客户单到来
        rw, err := l.Accept()
        // 如果发生错误后的处理逻辑
        if err != nil {
            // 如果从server.doneChan中读取到内容，代表服务已关闭,返回 ErrServerClosed
            select {
            case <-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            // 如果 e 是 net.Error， 并且错误是临时性的
            if ne, ok := err.(net.Error); ok && ne.Temporary() {
                // 第一次没接收到数据，睡眠5毫秒
                if tempDelay == 0 {
                    tempDelay = 5 * time.Millisecond
                } else {
                    // 每次睡眠结束，唤醒后还是没接收到数据，睡眠时间加倍
                    tempDelay *= 2
                }
                // 单次睡眠时间上限设定为1秒
                if max := 1 * time.Second; tempDelay > max {
                    tempDelay = max
                }
                // 输出重新等待
                srv.logf("http: Accept error: %v; retrying in %v", err, tempDelay)
                // 休眠一段时间
                time.Sleep(tempDelay)
                continue
            }
            // 如果e不是net.Error，或者不是临时性错误，就返回错误
            return err
        }
        // 如果接收到数据就做如下处理：
        // 如果指定了server的ConnContext，就用它修改连接的context
        connCtx := ctx
        if cc := srv.ConnContext; cc != nil {
            connCtx = cc(connCtx, rw)
            if connCtx == nil {
                panic("ConnContext returned nil")
            }
        }
        // 休眠定时器归零
        tempDelay = 0
        // 使用当前的Conn接口构建新的 conn 实例，它包含了srv服务器和rw连接。
        // conn 实例代表一个 HTTP 连接的服务端，rw是底层的网络连接
        c := srv.newConn(rw)
        // 更新连接状态
        // 第一次更新连接状态会初始化srv.activeConn为一个map[*conn]struct{} 并将活跃连接添加进去。
        // srv.activeConn是一个集合，保存服务器的活跃连接，当连接关闭 或者 被劫持 会从集合中删除。
        // 详细可以往里点看  trackConn函数。
        // 如果 server.ConnState 不为nil 也会在连接状态改变时,执行该回调函数
        c.setState(c.rwc, StateNew) // before Serve can return
        // 启动goroutine处理socket
        go c.serve(connCtx)
    }
}


// 上面代码简化后
for {
    rw, e := l.Accept()
    ...
    c, err := srv.newConn(rw)
    c.setState(c.rwc, StateNew)
    go c.serve()
}

```

- 可以看到该方法是一个死循环，循环内l.Accept()阻塞等待接收监听到的网络连接，一旦有新的连接建立，将返回新的net.Conn实例，然后把服务器实例Server和底层连接（net.Conn）封装为一个内部的conn结构体的实例，并将conn连接的状态标志为StateNew, 然后开启一个goroutine执行它的serve()方法。这里对每一个连接开启一个goroutine来处理
- l.Accept()`返回`net.Conn`为底层`TCP连接, 而srv.newConn(rw)`返回的`http.conn`可以理解为`HTTP连接
- state被维护在Server里，只不过通过conn来调用了。一共有StateNew, StateActive, StateIdle, StateHijacked, StateClosed五个状态。
  - 从new开始，当读取了一个字节之后进入active，读取完了并发送response之后，进入idle。
  - 终结有两种，主动终结closed以及被接管： Hijack让调用者接管连接,在调用Hijack()后,http server库将不再对该连接进行处理,对于该连接的管理和关闭责任将由调用者接管

------

- Server.Serve()方法net.Conn解析

```go
// net.Conn 定义

type Conn interface {
    // 读取连接中数据
    Read(b []byte) (n int, err error)

    // 发送数据
    Write(b []byte) (n int, err error)

    // 关闭链接
    Close() error

    // 返回本地连接地址
    LocalAddr() Addr

    // 返回远程连接的地址
    RemoteAddr() Addr

    // 设置与连接关联的读写期限。 
    // 等效于同时调用SetReadDeadline和SetWriteDeadline。 
    // 注意： 截止期限是绝对时间，在该绝对时间之后，I/O操作将失败而不是阻塞。 
    // 超过期限后，可以通过设置将来的期限来刷新连接。
    SetDeadline(t time.Time) error

    // 单独设置读取超时时间
    SetReadDeadline(t time.Time) error

    // 单独设置写超时时间
    SetWriteDeadline(t time.Time) error
}

// 参数t是一个未来的时间点，所以每次读或写之前，都要调用SetXXX重新设置超时时间


// net.Conn包含以下两个方法，也意味着实现了io.Reader, io.Writer接口
Read(b []byte) (n int, err error)
Write(b []byte) (n int, err error)

```

- Server.Serve()方法http.conn解析

```go
// http.conn定义

type conn struct {
    // 连接绑定的Server 不可变,不可为nil
    server *Server

    // 用于取消连接的上下文
    cancelCtx context.CancelFunc

    // rwc是底层网络连接。它从不被其他类型包装，并且是分配给CloseNotifier调用方的值。通常类型为*net.TCPConn或*tls.Conn。
    rwc net.Conn

    // remoteAddr 就是 rwc.RemoteAddr().String()。它不在 Listener 接收数据的 goroutine,里同步填充。
    // 它在 (*conn).serve() goroutine 里被立即填充.
    // 这是 Handler 的 (*Request).RemoteAddr 的值。
    remoteAddr string

    // tlsState 是使用 TLS 时 TLS 的连接状态。
    // nil 表示不用 TLS。
    tlsState *tls.ConnectionState

    // werr设置为对rwc的第一个写入错误
    // 通过 checkConnErrorWriter{w} 设置，bufw 写入。
    werr error

    // r是bufr的读取源。它是rwc的包装器，它提供io.LimitedReader-style限制(在读取请求头时)
    // 支持CloseNotifier的功能。参见*connReader文档。
    r *connReader

    //  bufr从r读取 还是前面的reader，加了缓冲
    bufr *bufio.Reader

    // bufw 写入 checkConnErrorWriter{c}, 当发生错误时填充 werr。
    bufw *bufio.Writer

    // lastMethod 是当前连接的最后一个请求的方法。是 POST 请求还是 Get请求
    lastMethod string

    // 当前的请求
    curReq atomic.Value // of *response (which has a Request in it)

    // 当前cnn状态
    curState struct{ atomic uint64 } // packed (unixtime<<8|uint8(ConnState))

    // mu guards hijackedv
    mu sync.Mutex

    // 表示这个连接是否被一个带有Hijacker接口的 Handler hijacked了，主要用于切换协议
    hijackedv bool
}


// conn可以理解为一条基于TCP的HTTP连接，封装了3个重要的数据结构：
// server *Server就是http.Server；
// rwc net.Conn表示底层连接net.Conn；
// r *connReader是读取http数据的connReader(从rwc读取数据)。

// 后续的request和response都基于该conn结构体
```

- Server.Serve()方法go  c.serve() 解析

```go
// c.serve()定义

func (c *conn) serve(ctx context.Context) {
    // remoteAddr 在这里被直接填充。
    c.remoteAddr = c.rwc.RemoteAddr().String()
    // 把 c.rwc.LocalAddr() 放入上下文，用于参数传递。
    // 可以在 后续流程 或者 其他子协程中 根据 LocalAddrContextKey 获取到。
    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())
    // 方法结束时处理,
    defer func() {
        // recover 是一个内置函数，用于重新获得 panic 协程的控制。
        // 只有在延迟函数的内部，调用 recover 才有用。
        if err := recover(); err != nil && err != ErrAbortHandler {
            const size = 64 << 10
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
            // 打印 panic 信息
            c.server.logf("http: panic serving %v: %v\n%s", c.remoteAddr, err, buf)
        }
        // 如果连接没有被劫持,需要手动关闭。
        // 被劫持的连接无需操作,因为被劫持的连接需要 用户 手动处理。
        if !c.hijacked() {
            c.close()
            c.setState(c.rwc, StateClosed)
        }
    }()

    //如果该连接是tls.Conn  ，常见连接是net.TcpConn 和 tls.Conn
    if tlsConn, ok := c.rwc.(*tls.Conn); ok {
        // 设置读超时时间
        if d := c.server.ReadTimeout; d != 0 {
            c.rwc.SetReadDeadline(time.Now().Add(d))
        }
        // 设置写超时时间
        if d := c.server.WriteTimeout; d != 0 {
            c.rwc.SetWriteDeadline(time.Now().Add(d))
        }
        // 运行客户端或服务器握手协议，如果有错误执行逻辑
        if err := tlsConn.Handshake(); err != nil {
            // If the handshake failed due to the client not speaking
            // TLS, assume they're speaking plaintext HTTP and write a
            // 400 response on the TLS conn's underlying net.Conn.
            // 如果由于客户端未使用TLS而导致握手失败，假定它们使用的是明文HTTP，并在TLS Conn的底层net.conn上编写400响应。
            if re, ok := err.(tls.RecordHeaderError); ok && re.Conn != nil && tlsRecordHeaderLooksLikeHTTP(re.RecordHeader) {
                io.WriteString(re.Conn, "HTTP/1.0 400 Bad Request\r\n\r\nClient sent an HTTP request to an HTTPS server.\n")
                // 关闭连接
                re.Conn.Close()
                return
            }
            c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)
            return
        }
        c.tlsState = new(tls.ConnectionState)
        *c.tlsState = tlsConn.ConnectionState()
        // 用于判断是否使用TLS的NPN扩展协商出非http/1.1和http/1.0的上层协议，如果存在则使用server.TLSNextProto处理请求
        if proto := c.tlsState.NegotiatedProtocol; validNextProto(proto) {
            if fn := c.server.TLSNextProto[proto]; fn != nil {
                h := initALPNRequest{ctx, tlsConn, serverHandler{c.server}}
                fn(c.server, tlsConn, h)
            }
            return
        }
    }

    // HTTP/1.x from here on.
    // 返回Context和取消函数用来取消Context
    ctx, cancelCtx := context.WithCancel(ctx)
    // 将取消函数 赋值给 conn.cancelCtx
    c.cancelCtx = cancelCtx
    // 方法结束时调用 取消函数。
    defer cancelCtx()

    // connReader 是一个包裹了 *conn的 io.Reader。赋值给 conn.r
    c.r = &connReader{conn: c}
    // newBufioReader 将 c.r 封装成一个带有缓冲区的字节流bufio.Reader用于读取HTTP的request。
    // read buf长度默认为4096, 底层使用sync.pool提高存取效率。
    c.bufr = newBufioReader(c.r)
    // 初始化bufw用于发送response，缓冲区长度默认为 4<<10=4096。
    c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4<<10)

    // 循环处理HTTP请求
    for {
        // c.readRequest(ctx)方法内部调用http.readTransfer函数，如果有读取到Body内容,则设置为http.body类型，没有读到则设置为 NoBody类型
        // w 是一个包含 request 的response实例。
        w, err := c.readRequest(ctx)
        // 判断是否有读取过数据,如果读取过数据则设置TCP状态为active
        // c.readRequest(ctx) 方法内 有对c.r.remain赋值
        if c.r.remain != c.server.initialReadLimitSize() {
            // If we read any bytes off the wire, we're active.
            c.setState(c.rwc, StateActive)
        }
        // 如果读取请求信息时出错,根据错误码，向底层的net.Conn 实例写入错误信息
        if err != nil {
            const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"

            switch {
            case err == errTooLarge:
                // 请求头字段过大。
                const publicErr = "431 Request Header Fields Too Large"
                fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
                // 写回响应并关闭连接。
                c.closeWriteAndWait()
                return

            case isUnsupportedTEError(err):
                // 无法识别请求编码。
                code := StatusNotImplemented

                fmt.Fprintf(c.rwc, "HTTP/1.1 %d %s%sUnsupported transfer encoding", code, StatusText(code), errorHeaders)
                return

            case isCommonNetReadError(err):
                return // don't reply

            default:
                publicErr := "400 Bad Request"
                if v, ok := err.(badRequestError); ok {
                    publicErr = publicErr + ": " + string(v)
                }

                fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
                return
            }
        }

        // Expect 100 Continue support
        req := w.req
        // 如果用户的请求期望 100-continue。
        // 100-continue: http 100-continue用于客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据.
        // 如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。在现实应用中，通过在POST大数据时，才会使用100-continue协议。
        // 具体的RFC相关描述: http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.2.3
        if req.expectsContinue() {
            // "100-continue"的首部要求http1.1版本以上，且http.body长度不为0
            if req.ProtoAtLeast(1, 1) && req.ContentLength != 0 {
                // Wrap the Body reader with one that replies on the connection
                req.Body = &expectContinueReader{readCloser: req.Body, resp: w}
                w.canWriteContinue.setTrue()
            }
        } else if req.Header.get("Expect") != "" {
            // 非"100-continue"但首部包含"Expect"字段的请求为非法请求
            w.sendExpectationFailed()
            return
        }

        // curReq保存了当前的 response，当前代码中主要用于在读失败后调用response中的closeNotifyCh传递信号，此时连接断开。
        c.curReq.Store(w)

        // 判断是否还能从 body 读取到数据，true 表示能继续读 (未到 io.EOF)
        // 主要是为了支持管线化，处理当前请求时可能还在接收请求
        if requestBodyRemains(req.Body) {
            // 如果Body是http.body类型registerOnHitEOF注册的就是遇到io.EOF时执行的函数http.body.onHitEOF 也就是传入的 startBackgroundRead。
            registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead)
        } else {
            // 如果已经读取完请求头和请求体 调用下面函数在新的goroutine中阻塞等待数据的到来，通知 finishRequest
            w.conn.r.startBackgroundRead()
        }

        // HTTP 不能同时有多个活跃的请求.
        // 服务器回复了一个请求后才能读取下一个请求.
        // 所以我们可以在这个 goroutine 里执行 handler
        // serverHandler只是一个包装，这句实际上调用的是c.server.Handler.ServeHTTP()。
        // 而在前面讲到的server的初始化中，Handler就是DefaultServeMux或者用户指定的ServeMux
        // 我们称之为路由器。在路由器中，根据用户定义路由规则，来具体调用用户的业务逻辑方法.
        serverHandler{c.server}.ServeHTTP(w, w.req)
        // 调用上下文的取消函数
        w.cancelCtx()
        // 如果连接已经被劫持,直接return
        if c.hijacked() {
            return
        }
        // 将处理的请求写入输出缓冲区将处理完成数据返回给客户端
        // 1. 刷掉bufio.writer里的数据
        // 2. 关闭chunkWriter写入流
        // 3. 刷掉conn缓冲流里的数据
        // 4. 关闭tcp连接
        w.finishRequest()
        // 判断是否需要重用底层TCP连接，即是否退出本函数的for循环，退出for循环将断开连接
        if !w.shouldReuseConnection() {
            // 如果连接不允许重用
            // requestBodyLimitHit 在 requestTooLarge 函数中设置，当此值为true，停止读取后续的 request 和输入
            // closedRequestBodyEarly 表示连接之前是否已关闭
            if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
                c.closeWriteAndWait()
            }
            return
        }
        // 重用连接，设置底层状态为idle
        // StateIdle 表示此连接已处理完一个 request 并处于 keep-alive 状态，等待后续 request
        c.setState(c.rwc, StateIdle)
        // 将当前请求置为空
        c.curReq.Store((*response)(nil))

        // 如果没有通过SetKeepAlivesEnabled设置HTTP keepalive或底层连接已经通过如Server.Close关闭，则直接退出
        if !w.conn.server.doKeepAlives() {
            return
        }

        // 如果设置了idle状态超时时间，则调用SetReadDeadline设置底层连接deadline，并调用bufr.Peek等待请求
        if d := c.server.idleTimeout(); d != 0 {
            c.rwc.SetReadDeadline(time.Now().Add(d))
            if _, err := c.bufr.Peek(4); err != nil {
                return
            }
        }
        c.rwc.SetReadDeadline(time.Time{})
    }
}



// 简化代码
for{
  w, err := c.readRequest(ctx)
  ...
  serverHandler{c.server}.ServeHTTP(w, w.req)
  ...
  w.finishRequest()
}


// 这个ServeHTTP()函数就是我们路由注册时调用的ServerHTTP, serverHandler{c.server}.ServeHTTP(w, w.req)这行代码会去匹配在http.HandleFunc()中注册的路由,找到对应的处理函数，执行我们写的业务逻辑

// ServeHTTP()参数是两个高度封装的response对象和Request对象，response是私有类型，暴露在外的是ResponseWriter 后续响应客户端都是基于ResponseWriter
```

###### 18.4.2.3.2 https请求处理

- 要在 Go 中处理 HTTPS 请求与处理 HTTP 请求的方式类似，你需要创建一个 HTTPS 服务器，使用 TLS（Transport Layer Security）协议来保护通信。TLS 协议用于在客户端和服务器之间建立加密通道，以确保数据的机密性和完整性
- 可以使用 `net/http` 包提供的 `ListenAndServeTLS` 函数来处理 HTTPS 请求

```go
func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServeTLS(certFile, keyFile)
}

// addr: 监听的地址和端口（":443" 表示监听在 443 端口）。
// certFile: SSL 证书文件的路径。
// keyFile: SSL 私钥文件的路径。
// handler: 处理请求的处理器，通常传递 nil 表示使用默认的 ServeMux

// cert.pem 和 key.pem 为你实际的 SSL 证书文件和私钥文件的路径。你可以通过购买证书，或者使用免费的证书颁发机构（Let's Encrypt等）提供的证书
```

> 自签证书
>
> ```go
> openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365
> ```



- 示例

  - 创建证书

  ```go
  mkdir -p /ssl_key ; cd /ssl_key
  openssl genrsa -idea -out server.key 2048
  openssl req -days 36500 -x509  -sha256 -nodes -newkey rsa:2048 -keyout server.key -out server.crt
  ```

  - 创建服务端

  ```go
  package main
  
  import (
  	"fmt"
  	"net/http"
  )
  
  func Hello(w http.ResponseWriter, r *http.Request) {
  	fmt.Fprintln(w, "This is Hello package, used to test HTTPS")
  }
  
  func main() {
  	http.HandleFunc("/", Hello)
  	addr := http.Server{
  		Addr: ":8080",
  	}
  	if err := addr.ListenAndServeTLS("/ssl_key/server.crt", "/ssl_key/server.key"); err != nil {
  		fmt.Println("启动失败", err)
  		return
  	}
  }
  ```

  - 访问结果

  <img src="https://cloud.006288.xyz/PicGo//image-20240131224943231.png" alt="image-20240131224943231" style="zoom: 50%;" />



#### 18.4.3 go语言http请求总结



![img](https://cloud.006288.xyz/PicGo//format,webp.webp)



#### 18.4.4 http客户端

- 实现`HTTP`客户端就是客户端通过网络访问向服务端发送请求，服务端发送响应信息，并将相应信息输出到客户端的过程。

- go内置的`net/http`包提供了最简洁的`HTTP`客户端实现方式，无须借助第三方网络通信库，就可以直接使用`HTTP`中用得最多的`GET`和`POST`方式请求数据

- 基本方法

```go
// net/http包的 Client 类型提供了如下几个方法，让我们可以用最简洁的方式实现 HTTP 请求：

func (c *Client) Get(url string) (r *Response, err error)
func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response, err error)
func (c *Client) PostForm(url string, data url.Values) (r *Response, err error)
func (c *Client) Head(url string) (r *Response, err error)
func (c *Client) Do(req *Request) (resp *Response, err error)
```

- 服务端

```go
package main

import (
	"fmt"
	"io"
	"net/http"
)

// 编写一个处理器
type Hellohandler struct{}

func (h *Hellohandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Error reading request body", http.StatusInternalServerError)
		return
	}

	// 处理请求体数据
	fmt.Printf("request POST data : %s\n", string(body))

	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "This is Hello package")
}

// 编写一个处理器函数
func TestHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "Thisi is Test package")
}

func main() {
	handler := Hellohandler{}
	server := http.Server{
		Addr: ":8888",
	}
	http.Handle("/hello", &handler)
	http.HandleFunc("/test", TestHandler)

	if err := server.ListenAndServe(); err != nil {
		fmt.Println("监听失败", err)
	}

}
```



##### 18.4.4.1 发起Get请求

- 要请求一个资源，只需调用http.Get()方法（等价于http.DefaultClient.Get()）即可

```go
package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
)

func main() {
	response, err := http.Get("http://localhost:8888/hello")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer response.Body.Close()
    // 将服务端响应内容打印到标准输出流中
	io.Copy(os.Stdout, response.Body)

}
```

##### 18.4.4.2 发送POST请求

- `http.Post()` 方法是 Go 语言标准库中用于发送 HTTP POST 请求的便捷函数。它向指定的 URL 发送一个 HTTP POST 请求，并返回一个响应。

```go
func Post(url string, contentType string, body io.Reader) (resp *Response, err error)

// 参数说明：

// url：目标 URL，表示要发送 POST 请求的地址。
// contentType：请求的内容类型，通常是 "application/x-www-form-urlencoded" 或 "application/json" 等。
// body：一个 io.Reader 接口，用于提供 POST 请求的主体数据
```

- 示例

```go
package main

import (
	"fmt"
	"io"
	"net/http"
	"strings"
)

func main() {
	// 用于将一个字符串转换为满足 io.Reader 接口的对象，通常在需要使用 io.Reader 接口的函数或方法中传递字符串数据时非常方便
	data := strings.NewReader("key1=value1&key2=value2")
	resp, err := http.Post("http://localhost:8888/hello", "application/x-www-form-urlencoded", data)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer resp.Body.Close()

	// 读取响应内容
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("Response:", string(body))
}

```

##### 18.4.4.3 http.client

###### 18.4.4.3.1 什么时http.client

- 除了基本HTTP操作， Go语言标准库也暴露了比较底层的HTTP相关库，让开发者可以基于这些库灵活定制HTTP服务器和使用HTTP服务

- `http.client` 是 Go 语言中用于发送 HTTP 请求的核心库。`http.Client` 是一个结构体，用于管理和配置 HTTP 请求的参数，如超时、重定向、代理等
- 当你使用 `http.Get`、`http.Post()`方法时，实际上是在内部创建了一个默认的 `http.client`，然后使用该客户端发送 GET 、`POST`请求。所以，`http.client` 是 `http.Get` 、http.Post()背后的实现细节 

###### 18.4.4.3.2 默认的http.Client

- 当你使用 `http.Get`、`http.Post` 等方法时，它们实际上在内部使用了一个默认配置的 `http.Client`---http.DefaultClient进行调用的，比如http.Get()等价于http.DefaultClient.Get()

```go
var DefaultClient = &Client{}

type Client struct {
	Transport RoundTripper
	CheckRedirect func(req *Request, via []*Request) error
	Jar CookieJar
	Timeout time.Duration
}

// 常见的 http.Client 参数：
// Transport: 用于定义客户端的传输层。RoundTripper 是 Go 语言中 HTTP 客户端和服务端通信的抽象接口。通常，你可以使用默认的 http.DefaultTransport 或者使用自定义的传输层。

// CheckRedirect: 这是一个函数类型的字段，用于检查 HTTP 重定向。当请求发生重定向时，这个函数将被调用。它接受两个参数，req 是原始请求，via 是经过的所有请求，返回一个 error 类型。

// Jar: 用于处理 HTTP cookie 的 CookieJar 接口实现。Cookie 是用来在客户端和服务器之间传递状态信息的一种机制。

// Timeout: 定义客户端的超时时间，是一个 time.Duration 类型。这是一个时间段，表示一段时间的长度

// DisableKeepAlives: 禁用或启用长连接
```

###### 18.4.4.3.3 http.Client基本使用

- 过创建自定义的 `http.Client` 实例，可以更灵活地控制 HTTP 请求

```go
package main

import (
    "fmt"
    "net/http"
    "time"
)

func main() {
    // 自定义 http.Client
    customClient := &http.Client{
        Timeout: time.Second * 10, // 设置超时时间为10秒
        // 其他自定义配置
    }

    resp, err := customClient.Get("https://example.com")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer resp.Body.Close()

    // 处理响应
    fmt.Println("Status Code:", resp.Status)
}
```

- 处理重定向
  - 设置了一个 `CheckRedirect` 函数，用于处理重定向。当服务器返回重定向响应时，`http.Client` 会调用此函数来确定是否要遵循重定向以及重定向到哪个地址
    - `CheckRedirect` 函数接收两个参数：
      - `req *http.Request`：表示当前的 HTTP 请求对象。
      - `via []*http.Request`：是一个包含所有经过的请求对象的切片。如果存在多次重定向，你可以通过这个参数来获取之前的请求信息

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    // 自定义 http.Client 处理重定向
    customClient := &http.Client{
        CheckRedirect: func(req *http.Request, via []*http.Request) error {
            fmt.Println("Redirecting to:", req.URL)
            return nil
        },
    }
    
    // 关闭重定向
    customClient := &http.Client{
    	CheckRedirect: func(req *http.Request, via []*http.Request) error {
        	return http.ErrUseLastResponse // 关闭重定向
    	},
	}

    resp, err := customClient.Get("https://example.com")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer resp.Body.Close()

    // 处理响应
    fmt.Println("Status Code:", resp.Status)
}

```

- 代理设置
  - 可以通过 `http.Transport` 的 `Proxy` 字段来设置代理

```go
package main

import (
    "fmt"
    "net/http"
)

func main() {
    // 自定义 http.Client 设置代理
    
    // http.ProxyURL("http://proxy.example.com:8080")：这个函数创建了一个代理 URL 对象。它接受一个字符串参数，表示代理服务器的地址和端口
    proxyUrl, _ := http.ProxyURL("http://proxy.example.com:8080")
    // 自定义的 http.Client 实例
    customClient := &http.Client{
        // 于配置 HTTP 传输的行为
        Transport: &http.Transport{
            // 配置了代理。这里使用了前面创建的代理 URL
            Proxy: http.ProxyURL(proxyUrl),
        },
    }

    resp, err := customClient.Get("https://example.com")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer resp.Body.Close()

    // 处理响应
    fmt.Println("Status Code:", resp.Status)
}

```

###### 18.4.4.3.4 自定义 http.Transport

- `http.Transport` 是 Go 语言中用于配置 HTTP 传输的行为的结构体。
- 它是 `http.Client` 的一部分，负责处理底层的网络传输细节。通过自定义 `http.Transport`，你可以控制连接池、TLS 配置、代理设置等，以适应不同的网络环境和应用需求

- **连接池相关配置：**
  - `MaxIdleConns`: 整个连接池中空闲连接的最大数量。
  - `MaxIdleConnsPerHost`: 每个目标主机的空闲连接最大数量。
  - `IdleConnTimeout`: 空闲连接的超时时间

```go
transport := &http.Transport{
    MaxIdleConns:        10,
    MaxIdleConnsPerHost: 5,
    IdleConnTimeout:     time.Second * 30,
}

```

- **TLS 配置：**
  - `TLSClientConfig`: 用于配置 TLS 安全连接的参数。可以设置 `RootCAs`、`InsecureSkipVerify` 等

```go
transport := &http.Transport{
    TLSClientConfig: &tls.Config{
        RootCAs:            pool,
        InsecureSkipVerify: true,
    },
}
```

- **代理设置：**
  - `Proxy`: 用于设置代理服务器的地址

```go
proxyUrl, _ := http.ProxyURL("http://proxy.example.com:8080")
transport := &http.Transport{
    Proxy: http.ProxyURL(proxyUrl),
}
```

- **自定义 Dial 函数：**
  - `Dial`: 可以自定义创建网络连接的函数，例如设置超时时间等

```go
transport := &http.Transport{
    Dial: func(network, addr string) (net.Conn, error) {
        return net.DialTimeout(network, addr, time.Second*10)
    },
}
```

- **自定义 Keep-Alive 行为：**
  - `DisableKeepAlives`: 是否禁用连接复用（Keep-Alive）

```go
transport := &http.Transport{
    DisableKeepAlives: true,
}
```

##### 18.4.4.4 自定义请求

- 在Go语言中，可以通过`http.NewRequest`函数创建自定义的HTTP请求。这个函数返回一个 `http.Request` 对象，你可以在该对象上设置请求方法、URL、请求头、请求体等信息。这种灵活性使得你可以根据需要创建各种类型的 HTTP 请求

- 服务端

```go
package main

import (
	"fmt"
	"io"
	"net/http"
)

// 编写一个处理器
type Hellohandler struct{}

func (h *Hellohandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}
	body, err := io.ReadAll(r.Body)
	if err != nil {
		http.Error(w, "Error reading request body", http.StatusInternalServerError)
		return
	}

	// 处理请求体数据
	fmt.Printf("request POST data : %s\n", string(body))
	fmt.Printf("请求方法: %v\n, 请求头: %v\n", r.Method, r.Header)

	w.WriteHeader(http.StatusOK)
	fmt.Fprintln(w, "This is Hello package")
}

// 编写一个处理器函数
func TestHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Printf("请求方法: %v\n, 请求头: %v\n", r.Method, r.Header)
	//fmt.Fprintln(w, "Thisi is Test package")
}

func main() {
	handler := Hellohandler{}
	server := http.Server{
		Addr: ":8888",
	}
	http.Handle("/hello", &handler)
	http.HandleFunc("/test", TestHandler)

	if err := server.ListenAndServe(); err != nil {
		fmt.Println("监听失败", err)
	}

}

```

- 客户端

```go
package main

import (
	"fmt"
	"net/http"
	"strings"
	"time"
)

func main() {
	requesteBody := strings.NewReader("hello golang")

	req, err := http.NewRequest("GET", "http://localhost:8888/test", requesteBody)
	if err != nil {
		fmt.Println(err)
		return
	}
	
	defer req.Body.Close()

	req.Header.Set("X-User-Name", "kubei")

	client := &http.Client{
		Timeout: time.Second * 10,
	}

	resq, err := client.Do(req)
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println(resq.Status)
}
```

##### 18.4.4.5 处理响应

- 在Go语言中，`http.Response` 结构体表示HTTP响应。通过HTTP客户端发起请求后，你会得到一个 `http.Response` 对象，你可以从中获取响应的状态码、头部信息以及响应体等

```go
// 获取状态码
response.StatusCode

// 获取头部信息
for key, value := range response.Header {
    fmt.Printf("%s: %s\n", key, value)
}

// 读取响应体
body, err := ioutil.ReadAll(response.Body)
if err != nil {
    fmt.Println("Error reading response body:", err)
    return
}

    // 处理响应体
fmt.Println(string(body))
```

#### 18.4.5 Cookie和Session

- Web开发中一个很重要的议题就是如何做好用户的整个浏览过程的控制，因为HTTP协议是无状态的，所以用户的每一次请求都是无状态的，我们不知道在整个Web操作过程中哪些连接与该用户有关

> 无状态的意思是每次请求都是独立的，它的执行情况和结果与前面的请求和之后的请求都无直接关系，它不会受前面的请求响应情况直接影响，也不会直接影响后面的请求响应情况。

- 我们应该如何来解决这个问题呢？Web里面经典的解决方案是cookie和session
- cookie机制是一种客户端机制，把用户数据保存在客户端，而session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息，每一个网站访客都会被分配给一个唯一的标志符,即sessionID,它的存放形式无非两种:要么经过url传递,要么保存在客户端的cookies里.当然,你也可以将Session保存到数据库里,这样会更安全,但效率方面会有所下降。

##### 18.4.5.1 Cookie

- 在 Internet 中，Cookie 实际上是指小量信息，是由 Web 服务器创建的，将信息存储在用户计算机上（客户端）的数据文件。一般网络用户习惯用其复数形式 Cookies，指某些网站为了辨别用户身份、进行 Session 跟踪而存储在用户本地终端上的数据，而这些数据通常会经过加密处理

- 简而言之Cookie就是在本地计算机保存一些用户操作的历史信息（当然包括登录信息），并在用户再次访问该站点时浏览器通过HTTP协议将本地cookie内容发送给服务器，从而完成验证，或继续上一步操作

![image-20240204231219864](https://cloud.006288.xyz/PicGo//image-20240204231219864.png)

- Cookie生存机制	
  - Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。
  - Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态

![image-20240204231910746](https://cloud.006288.xyz/PicGo//image-20240204231910746.png)

- cookie是有时间限制的，根据生命期不同分成两种：会话cookie和持久cookie；

  - 如果不设置过期时间，则表示这个cookie的生命周期为从创建到浏览器关闭为止，只要关闭浏览器窗口，cookie就消失了。这种生命期为浏览会话期的cookie被称为会话cookie。会话cookie一般不保存在硬盘上而是保存在内存里。

  - 如果设置了过期时间(setMaxAge(606024))，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie依然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存的cookie，不同的浏览器有不同的处理方式



- **Go操作Cookie**

  - 在Go语言中通过net/http包中的SetCookie来设置

  ```go
   // w表示需要写入的response，cookie是一个struct
  http.SetCookie(w ResponseWriter, cookie *Cookie)
  
  type Cookie struct {
      Name       string
      Value      string
      Path       string
      Domain     string
      Expires    time.Time
      RawExpires string
      // MaxAge=0表示未设置Max-Age属性
      // MaxAge<0表示立刻删除该cookie，等价于"Max-Age: 0"
      // MaxAge>0表示存在Max-Age属性，单位是秒
      MaxAge   int
      Secure   bool
      HttpOnly bool
      Raw      string
      Unparsed []string // 未解析的“属性-值”对的原始文本
  }
  ```

- Go获取Cookie

  - Request对象拥有两个获取Cookie的方法和一个添加Cookie的方法

```go
// 获取Cookie的两种方法

// 解析并返回该请求的Cookie头设置的所有cookie
func (r *Request) Cookies() []*Cookie

// 返回请求中名为name的cookie，如果未找到该cookie会返回nil, ErrNoCookie。
func (r *Request) Cookie(name string) (*Cookie, error)

// AddCookie向请求中添加一个cookie。
func (r *Request) AddCookie(c *Cookie)
```

##### 18.4.5.2 Session

- Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session
- 用户登陆成功之后，我们在服务端为每个用户创建一个特定的session和一个唯一的标识，它们一一对应。其中：
  - Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；唯一标识通常称为Session ID会写入用户的Cookie中。
  - 这样该用户后续再次访问时，请求会自动携带Cookie数据（其中包含了Session ID），服务器通过该Session ID就能找到与之对应的Session数据，也就知道来的人是“谁”
- session的基本原理是由服务器为每个会话维护一份信息数据，客户端和服务端依靠一个全局唯一的标识来访问这份数据，以达到交互的目的。当用户访问Web应用时，服务端程序会随需要创建session

- **go语言session操作**
  - go http并没有实现session的代码,需要我们自行实现
  - **session创建过程:**
    - 生成全局唯一标识符（sessionid）
    - 开辟数据存储空间
    - 将session的全局唯一标示符发送给客户端
  - **服务端发送session_id的方式:**
    - Cookie 服务端通过设置Set-cookie头就可以将session的标识符传送到客户端
    - URL重写 所谓URL重写，就是在返回给用户的页面里的所有的URL后面追加session标识符



- 实现session管理
  - 管理seeeion需要考虑以下几点:
    - 全局session管理器
    - 保证sessionid 的全局唯一性
    - 为每个客户关联一个session
    - session 的存储(可以存储到内存、文件、数据库等)
    - session 过期处理
- [自定义session管理](https://www.w3cschool.cn/yqbmht/cxndpozt.html)

### 18.5 WebSocket

#### 18.5.1 Websocket概述

##### 18.5.1.1 WebSocket 的诞生背景

- 平时我们接触到最多的协议是 HTTP/HTTPS 协议，这两种协议的工作原理可简述为：客户端通过浏览器发送一个请求，服务器在接受到请求后进行处理并将得到的结果返回给客户端，由客户端处理结果。可见其主要为一种 客户端主动“拉取” 信息的形式
- 随着时代的发展，出现了一些需要服务端实时发送信息给客户端的场景，比如体育实况更新、金融证券的实时信息、实时数据监控等。而如何实现服务端主动 “推送” 信息的形式呢？
- 在 WebSocket 还未诞生的时候，采用的是轮询技术来实现信息的推送：每间隔一定的时间，浏览器(客户端)自动发送一个 HTTP 请求，以此主动拉取服务器的最新消息。使用轮询技术，需要不停向服务器发送 HTTP 请求，这样会占用很多的带宽和服务器资源，并且还是不能实现服务器主动向客户端推送数据
- 在上述背景下，一种全双工的通信协议 WebSocket 应运而生，WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据

##### 18.5.1.2 什么是Websocket

- WebScoket是一种基于 TCP 的网络通信协议，位于 OSI 7 层模型的应用层, 它使用单个TCP连接来进行全双工通信，定义了特定的握手过程，以确保客户端和服务端可以互相识别，并开始进行数据传输，通常用于在Web应用程序和服务端之间进行实时数据传输
- WebSocket 使用 ws 或 wss 的统一资源标志符（URI），例如：ws://localhost:8080/test， 其中 wss 表示基于 TLS 的 WebSocket。默认情况下 WebSocket 协议使用 80 端口；若运行在 TLS 之上时，则默认使用 443 端口
- WebSocket基于HTTP协议，但是它是一种完全不同的协议。**在客户端和服务端首次进行连接时，建立连接时需要进行一次HTTP握手，WebSocket会通过HTTP请求发送一个Upgrade头，以升级连接协议**, 如果服务器同意进行升级，客户端和服务端之间就可以建立WebSocket连接，开始进行实时数据传输。

![image-20240219233935519](https://cloud.006288.xyz/PicGo//image-20240219233935519.png)



- websocket是以数据帧传输, htpp是以数据流传输

#### 18.5.2 websocket实现原理

- websocket通信流程

  - 首先浏览器发起http请求,请求建立websocket连接

  ```go
  // 客户端必须发送的数据
  GET ws://localhost:9010/ajaxchattest HTTP/1.1  // 协议版本必须大于等于1.1
  Connection: Upgrade  						// 表示我们需要升级协议
  upgrade: websocket   						// 需要升级到的协议
  Sec-Websocket-Version: 13  					// websocket的版本
  Sec-Websocket-Key: us+yhJ4I7cdjFojb92qXiw==  // 随机生成的websocket密钥
  ```

  - 服务端响应客户端请求

  ```go
  // 服务端必须放回的数据
  HTTP/1.1 101 Switching Protocols  					// 协议,状态码,状态码描述
  Connection: Upgrade									// 表示我们需要升级协议
  Upgrade: websocket									// 需要升级到的协议
  Sec-Websocket-Accept: dN3vms0yB9MDOz/ibTUFBysWKHA=	// 响应一个websocketc客户端的key
  ```

  - 相互发送数据

> Sec-Websocket-Accept计算方式
>
> ```go
> // 将客户端送来的Sec-Websocket-Key的值和258EAFA5-E914-47DA-95CA-C5AB0DC85B11拼接。 (258EAFA5-E914-47DA-95CA-C5AB0DC85B11是一个magic key,是RFC6455 Page24页中定义的一个固定值，直接用即可)
> // 通过SHA1计算出摘要, 并转成base64字符串返回给客户端
> 
> // 示例
> Sec-Websocket-Key: YEZq1Ej9YEmy1M13ODPFKQ==
> // 拼接: GUID
> YEZq1Ej9YEmy1M13ODPFKQ==258EAFA5-E914-47DA-95CA-C5AB0DC85B11
> // 使用sha1安全散列算法计算
> 2379909cdd1ce5da8532b88107b3cd25ab6586fe  (注意这是十六进制)
> // 使用用base64对其进行编码
> I3mQnN0c5dqFMriBB7PNJatlhv4=
> 
> 
> // 使用go语言计算Sec-Websocket-Accept
> 
> 	swk := "YEZq1Ej9YEmy1M13ODPFKQ==" // Sec-Websocket-Key
> 
> 	h := sha1.New()
> 	h.Write([]byte(swk))
> 	h.Write([]byte("258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))
> 
> 	swa := base64.StdEncoding.EncodeToString(h.Sum(nil))
> 	fmt.Println(swa)
> ```
>
> <img src="https://cloud.006288.xyz/PicGo//image-20240220004712979.png" alt="image-20240220004712979" style="zoom: 67%;" />



- websocket数据帧格式

  - WebSocket 使用了自定义的二进制分帧格式，把每个应用消息切分成一或多个帧，发送到目的地之后再组装起来，等到接收到完整的消息后再通知接收端。基本的成帧协议定义了帧类型有操作码、有效载荷的长度，指定位置的Extension data和Application data，统称为Payload data，保留了一些特殊位和操作码供后期扩展。在打开握手完成后，终端发送一个关闭帧之前的任何时间里，数据帧可能由客户端或服务器的任何一方发送。具体的帧格式如下所示：

  ![image-20240220005757795](https://cloud.006288.xyz/PicGo//image-20240220005757795.png)

#### 18.5.2 Websocket基本使用

- WebSocket是一种基于HTTP协议的双向通信协议，它使得网页应用程序能够在客户端和服务器之间进行实时通信。在Golang中，我们可以使用[github.com/gorilla/websocket](github.com/gorilla/websocket)包来实现WebSocket编程
- Websocket 建立连接的步骤
  - 首先客户端与服务器建立 TCP 连接，进行三次握手。这发生于传输层，是网络通信的基础，如果失败则后续步骤将不再执行。
  - 当 TCP 连接成功后，进行 HTTP 的通信握手。
  - 客户端通过 HTTP 协议向服务器传送带有 WebSocket 支持的版本号等信息的握手请求。
  - 服务器收到客户端的握手请求后，同样采用 HTTP 协议返回应答消息。
  - 当客户端收到了连接成功的应答消息之后，持续通过 TCP 通道进行传输通信。

> 也就是说 WebSocket 在建立握手时，连接信息是通过 HTTP 传输的。但是建立之后，在真正传输通信数据时候是不需要 HTTP 协议的

##### 18.5.2.1 Websocket服务端

```go
package main

import (
	"fmt"
	"github.com/gorilla/websocket"
	"log"
	"net/http"
)

var myUP = websocket.Upgrader{
	ReadBufferSize:  1024,
	WriteBufferSize: 1024,
}

var conns []*websocket.Conn

func indexDemo(w http.ResponseWriter, r *http.Request) {
	conn, err := myUP.Upgrade(w, r, nil)
	if err != nil {
		log.Println(err)
		return
	}
	defer conn.Close()
	conns = append(conns, conn)
	for {
		m, p, err := conn.ReadMessage()
		if err != nil {
			break
		}
		for i := range conns {
			conns[i].WriteMessage(websocket.TextMessage, []byte("你说的是: "+string(p)+"吗"))
		}

		fmt.Println(m, string(p), err)
	}
	log.Printf("服务关闭")

}

func main() {
	http.HandleFunc("/", indexDemo)
	err := http.ListenAndServe(":8888", nil)
	if err != nil {
		return
	}
}

```



##### 18.5.2.2 Websocket客户端

```go
package main

import (
	"bufio"
	"fmt"
	"github.com/gorilla/websocket"
	"log"
	"os"
)

func mySend(conn *websocket.Conn) {
	for {
		reader := bufio.NewReader(os.Stdin)
		l, _, _ := reader.ReadLine()
		conn.WriteMessage(websocket.TextMessage, l)
	}
}

func main() {
	webDialer := websocket.Dialer{}
	conn, _, err := webDialer.Dial("ws://localhost:8888", nil)
	if err != nil {
		log.Println(err)
		return
	}
	go mySend(conn)

	defer conn.Close()
	for {
		m, p, err := conn.ReadMessage()
		if err != nil {
			break
		}
		fmt.Println(m, string(p), err)
	}

}

```

### 18.6 RPC编程

#### 18.6.1 RPC概述

- **什么是RPC**
  - RPC（Remote Procedure Call）——**远程过程调用**，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题
  - 通过RPC可以使函数调用模式网络化。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发网络分布式多程序在内的应用程序更加容易
  - RPC主要作用就是不同的服务间方法调用就像本地调用一样便捷
- **为什么需要RPC**
  - 服务化：微服务化，跨平台的服务之间远程调用；
  - 分布式系统架构：分布式服务跨机器进行远程调用；
  - 服务可重用：开发一个公共能力服务，供多个服务远程调用。
  - 系统间交互调用：两台服务器A、B，服务器A上的应用a需要调用服务器B上的应用b提供的方法，而应用a和应用b不在一个内存空间，不能直接调用，此时，需要通过网络传输来表达需要调用的语义及传输调用的数据

- [http与RPC的区别](https://blog.csdn.net/qq_45808700/article/details/131664118)

#### 18.6.2 RPC工作原理

- RPC技术在架构设计上有四部分组成，分别是：**客户端、客户端存根、服务端、服务端存根**、**网络传输服务**
  - **客户端(Client)：**服务调用发起方，也称为服务消费者。
  - **客户端存根(Client Stub)：**该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端Stub程序；其次，还要接收服务端Stub程序发送的调用结果数据包，并解析返回给客户端。
  - **服务端(Server)：**远端的计算机机器上运行的程序，其中有客户端要调用的方法。
  - **服务端存根(Server Stub)：**接收客户Stub程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端Stub程序
  - **网络传输服务(network service):** 底层输出传输,TCP\http

- RPC调用流程
  - 客户端（Client）通过调用本地客户端Stub程序的方式调用想要使用的功能方法名（以接口方式调用）；
  - 客户端存根（Client Stub）接收到调用请求后负责将方法名、入参等信息进行组装序列化成能够进行网络传输的消息体（将消息体对象序列化为二进制流）；
  - 客户端存根（Client Stub）找到远程的服务地址，并且将消息通过网络发送给服务端（通过sockets发送消息）；
  - 服务端存根（Server Stub）服务端Stub程序接收到客户端发送的数据包信息，并通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息，即解码（将二进制流反序列化为消息对象）；
  - 服务端存根（Server Stub）通过解码结果调用本地的服务进行相关处理；
  - 服务端（Server）根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端Stub程序；
  - 服务端存根（Server Stub）将程序调用结果按照约定的协议进行序列化，并通过网络发送回客户端Stub程序（将结果消息对象序列化为二进制流, 并通过sockets发送消息）；
  - 客户端存根（Server Stub）接收到服务端Stub发送的返回数据，对数据进行反序列化操作, 并将调用返回的数据传递给客户端请求发起者）；
  - 客户端（Client）请求发起者得到调用结果，整个RPC调用过程结束

![image-20240310150031576](https://cloud.006288.xyz/PicGo//image-20240310150031576.png)



- RPC是一系列操作的集合,其中主要有**服务寻址、数据处理、网络传输**

- **常见的RPC框架**

  - 完整的**RPC**框架主要包括客户端、服务端、注册中心三部分，客户端中有服务发现、调用模块、RPC协议等组件，服务端中有服务暴露、处理程序、线程池、RPC协议等组件

  ![image-20240310142743510](https://cloud.006288.xyz/PicGo//image-20240310142743510.png)

  - **常用RPC技术或框架**

    - 远程服务调用的常见通信协议:

    | 通信协议名称 | 特点                                                         | 优势                                              | 不足                               |
    | ------------ | ------------------------------------------------------------ | ------------------------------------------------- | ---------------------------------- |
    | HTTP/HTTPS   | 简单、灵活，适用于 Web 环境                                  | 跨语言支持好，无状态适用于基于 RESTful 风格的服务 | 比二进制协议慢不适合大规模数据传输 |
    | REST         | 基于 HTTP 协议，通过 URI 访问资源，支持 JSON/XML 格式        | 简单、可伸缩，易于理解适用于互联网服务            | 操作有限不适用于复杂的远程调用场景 |
    | gRPC         | 基于 HTTP/2 协议，使用 Protocol Buffers 作为序列化协议，支持多语言 | 性能高，支持双向流、流控制自动生成代码            | 学习成本较高不适用于简单的场景     |
    | SOAP         | 基于 XML 的协议可运行在多种传输协议上                        | 强类型、拥有丰富的标准适用于企业级应用            | 消耗资源多不如 REST 灵活           |
    | RMI          | Java 特有，基于 Java 序列化使用 JRMP 传输                    | Java 开发者友好易于使用                           | 不跨语言Java 版本依赖性较高        |
    | AMQP         | 面向消息的协议，支持消息队列提供高度的灵活性                 | 异步通信，削峰填谷，松耦合                        | 学习成本较高不适合简单的同步调用   |
    | Thrift       | Facebook 开发二进制协议，支持多语言                          | 高效、可扩展支持多种数据类型                      | 可读性差不如 JSON 易于调试         |
    | WebSocket    | 基于 TCP，全双工通信适用于实时应用                           | 实时性强减少 HTTP 连接开销                        | 不支持广泛的浏览器和语言           |

    - 通信框架：MINA 和 Netty
    - 远程服务调用的常见数据格式:

  | 数据格式名称 | 定义                                                         | 特点                                                         | 应用                                         |
  | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------------- |
  | JSON         | 一种轻量级的数据交换格式，易于人阅读和编写，也易于机器解析和生成，基于键值对的方式组织数据 | 支持复杂的数据结构，包括对象、数组、字符串、数字、布尔值和 null | 在 Web 开发和跨语言的应用中广泛使用          |
  | XML          | 一种标记语言，用于描述文档结构和包含有关文档内容的信息，具有自定义标签的能力 | 可扩展，具有良好的结构化特性，适用于描述复杂的文档和数据     | 用于配置文件、Web 服务通信、数据交换等场景   |
  | Protobuf     | 一种由 Google 开发的二进制数据序列化协议，用于结构化数据的序列化 | 二进制格式，紧凑高效，性能较好，支持向前和向后兼容           | 在 Google 的内部通信和多种开源项目中广泛使用 |
  | MessagePack  | 一种二进制的轻量级数据交换格式，可用于跨语言的数据序列化     | 比 JSON 更紧凑，序列化和反序列化速度较快                     | 适用于需要高性能和小尺寸数据传输的场景       |
  | Thrift       | 一种跨语言的远程服务调用框架，使用二进制协议进行数据传输，Apache 生态 | 提供接口定义语言，支持多语言，包括 C++、Java、Python 等      | 用于构建可扩展且高性能的分布式系统           |

  

  - 目前流行的开源**RPC**框架: 有阿里巴巴的Dubbo、Facebook的Thift、Google的gRPC、Twitter的Finagle等。 先介绍三种：

    - **gRPC**：是 Google 公布的开源软件，基于HTTP 2.0 协议，并支持常见的众多编程语言。RPC 框架是基于 HTTP 协议实现的，底层使用到了 Netty 框架的支持。

    - **Thrift**：是 Facebook 的开源 RPC 框架，主要是一个跨语言的服务开发框架。 用户只要在其之上进行二次开发就行，应用对于底层的 RPC 通讯等都是透明的。不过这个对于用户来说需要学习特定领域语言这个特性，还是有一定成本的。

    - **Dubbo**：是阿里集团开源的一个极为出名的 RPC 框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是极其鲜明的特色

#### 18.6.3 go语言RPC基本使用

- go中如何实现RPC
  - golang中实现RPC非常简单，官方提供了封装好的库，还有一些第三方的库
  - golang官方的net/rpc库使用encoding/gob进行编解码，支持tcp和http数据传输方式，由于其他语言不支持gob编解码方式，所以golang的RPC只支持golang开发的服务器与客户端之间的交互
  - 官方还提供了net/rpc/jsonrpc库实现RPC方法，jsonrpc采用JSON进行数据编解码，因而支持跨语言调用

- **go语言RPC函数的要求**
  - 函数首字母必须大写
  - 必须有两个导出类型的参数, 第一个参数是接收的参数,第二个参数是返回给客户端的参数(第二个参数必须是指针类型)
  - 函数还要有一个返回值error

```go
// RPC 函数格式

func (t *T) MethodName(argType T1, replyType *T2) error

// T、T1和T2类型必须能被encoding/gob包编解码。
// 任何的RPC都需要通过网络来传递数据，Go RPC可以利用HTTP和TCP来传递数据，利用HTTP的好处是可以直接复用net/http里面的一些函数
```

##### 18.6.3.1 基于http的RPC

- 场景需求:
  - 实现一个简单的任务调度系统
  - 客户端像服务端提交任务,并获取任务执行结果

- 服务端

```go
package main

import (
	"fmt"
	"log"
	"math/rand"
	"net/http"
	"net/rpc"
)

type Task struct {
	ID       int
	TaskName string
}

type TaskSystem struct{}

// 第一个参数是函数需要接收的参数, 第二个参数是函数需要返回的参数(必须是指针类型), 方法必须放回一个error
func (ts *TaskSystem) Execute(req *Task, res *string) error {
	taskResult := []string{"PASS", "FAIL", "BLOCK"}
	*res = fmt.Sprintf("任务ID: %d, 任务名: %s, 任务执行结果: %v\n", req.ID, req.TaskName, taskResult[rand.Intn(len(taskResult))])
	return nil
}

func main() {
    // 注册rpc服务
	rpc.Register(new(TaskSystem))
    // 采用http作为rpc载体
	rpc.HandleHTTP()
    // 启动服务,监听端口,等待客户端发起请求
	if err := http.ListenAndServe(":8888", nil); err != nil {
		log.Println(err)
	}

}
```

- 客户端

```go
package main

import (
	"fmt"
	"log"
	"net/rpc"
)

type Task struct {
	ID       int
	TaskName string
}

func main() {
	client, err := rpc.DialHTTP("tcp", "localhost:8888")
	if err != nil {
		log.Println(err)
		return
	}
    defer client.Close()
    // 响应体
	var taskResult string
    // 请求体
	taskInfo := Task{20240310001, "batch_processing"}
    
	if err := client.Call("TaskSystem.Execute", taskInfo, &taskResult); err != nil {
		log.Println(err)
		return
	}
	fmt.Println(taskResult)
}
```

##### 18.6.3.2 基于TC的RPC

- 服务端

```go
package main

import (
	"fmt"
	"log"
	"math/rand"
	"net"
	"net/rpc"
)

type Task struct {
	ID       int
	TaskName string
}

type TaskSystem struct{}

func (ts *TaskSystem) Execute(req *Task, res *string) error {
	taskResult := []string{"PASS", "FAIL", "BLOCK"}
	*res = fmt.Sprintf("任务ID: %d, 任务名: %s, 任务执行结果: %v\n", req.ID, req.TaskName, taskResult[rand.Intn(len(taskResult))])
	return nil
}

func main() {
	// 注册rpc服务
	rpc.Register(new(TaskSystem))
	// 采用tcp作为消息载体
	listener, err := net.Listen("tcp", ":8888")
	if err != nil {
		log.Println(err)
		return
	}
	defer listener.Close()

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Println(err)
			continue
		}
		rpc.ServeConn(conn)
	}

}
```

- 客户端

```go
package main

import (
	"fmt"
	"log"
	"net/rpc"
)

type Task struct {
	ID       int
	TaskName string
}

func main() {
	client, err := rpc.Dial("tcp", "localhost:8888")
	if err != nil {
		log.Println(err)
		return
	}
	defer client.Close()
	var taskResult string
	taskInfo := Task{20240310001, "batch_processing"}
	if err := client.Call("TaskSystem.Execute", taskInfo, &taskResult); err != nil {
		log.Println(err)
		return
	}
	fmt.Println(taskResult)
}

```

##### 18.6.3.3 RCP调用中Call和GO

- 在 Go 的 `net/rpc` 包中，`client.Call` 和 `client.Go` 都用于发起 RPC 调用，但它们有一些关键的区别
  - **同步 vs. 异步调用**：
    - `client.Call`: 是同步的，它会阻塞直到远程调用完成并返回结果。
    - `client.Go`: 是异步的，它会立即返回一个 `rpc.Call` 结构，不会等待远程调用完成
  - **返回值**：
    - `client.Call`: 直接返回调用的结果或错误。程序会在这一行代码上阻塞，直到远程调用完成。
    - `client.Go`: 返回一个 `rpc.Call` 结构，你可以通过该结构的 `Done` 通道来等待异步调用的完成，然后使用 `Reply` 和 `Error` 字段获取结果或错误
  - **并发性**：
    - `client.Call`: 阻塞调用，直到远程调用完成。不适合并发调用多个 RPC。
    - `client.Go`: 适合并发调用多个 RPC，因为它是异步的，可以在一个程序中同时启动多个远程调用

```go
package main

import (
	"fmt"
	"log"
	"net/rpc"
)

type Task struct {
	ID       int
	TaskName string
}

func main() {
	client, err := rpc.Dial("tcp", "localhost:8888")
	if err != nil {
		log.Println(err)
		return
	}
	defer client.Close()
	var taskResult string
	taskInfo := Task{20240310001, "batch_processing"}
	
	// 同步调用
	if err := client.Call("TaskSystem.Execute", taskInfo, &taskResult); err != nil {
		log.Println(err)
		return
	}

	// 异步调用
	call := client.Go("TaskSystem.Execute", taskInfo, &taskResult, nil)
	for {
		select {
		case <-call.Done:
			fmt.Println(taskResult)
	// break 语句只会跳出当前的 select 语句，而不会跳出整个 for 循环。因此，即使在 case <-call.Done: 中使用了 break，select 语句会结束，但是程序会继续执行 for 循环中的下一次迭代，然后执行 default 语句,因此需要使用return
			return
		default:
			fmt.Println("远程调用未完成,我正在处理其他程序")
		}
	}
}

```

##### 18.6.3.4 JSON RPC

- JSON RPC是数据编码采用了JSON，而不是gob编码，其他和上面介绍的RPC概念一模一样
- net/rpc/jsonrpc库通过json格式编解码，支持跨语言调用
- JSON-RPC 的基本工作原理如下：
  - 客户端将请求数据以 JSON 格式发送给服务器。
  - 服务器接收到请求后，解析 JSON 数据，执行相应的远程过程调用。
  - 服务器执行完远程过程后，将结果以 JSON 格式返回给客户端

- 服务端

```go
package main

import (
	"fmt"
	"log"
	"math/rand"
	"net"
	"net/rpc"
	"net/rpc/jsonrpc"
)

type Task struct {
	ID       int
	TaskName string
}

type TaskSystem struct{}

func (ts *TaskSystem) Execute(req *Task, res *string) error {
	taskResult := []string{"PASS", "FAIL", "BLOCK"}
	*res = fmt.Sprintf("任务ID: %d, 任务名: %s, 任务执行结果: %v\n", req.ID, req.TaskName, taskResult[rand.Intn(len(taskResult))])
	return nil
}

func main() {
	rpc.Register(new(TaskSystem))
	listener, err := net.Listen("tcp", ":8888")
	if err != nil {
		log.Println(err)
		return
	}
	defer listener.Close()

	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Println(err)
		}
		jsonrpc.ServeConn(conn)
	}

}
```

- 客户端

```go
package main

import (
	"fmt"
	"log"
	"net/rpc/jsonrpc"
)

type Task struct {
	ID       int
	TaskName string
}

func main() {
	client, err := jsonrpc.Dial("tcp", "localhost:8888")
	if err != nil {
		log.Println(err)
		return
	}
	defer client.Close()
	var taskResult string
	taskInfo := Task{20240310001, "batch_processing"}
	call := client.Go("TaskSystem.Execute", taskInfo, &taskResult, nil)
	for {
		select {
		case <-call.Done:
			fmt.Println(taskResult)
			return
		default:
			fmt.Println("远程调用未执行完成,正在处理其他程序中")
		}
	}

}
```

## 19 web框架

### 19.1 框架概述

- 什么是框架
  - 其实框架，就是别人写好了包装起来的一套工具，把你原先必须要写的，必须要做的一些复杂的东西都写好了放在那里，你只要调用他的方法，就可以实现一些本来要费好大劲的功能
  - 形象一点说吧，假如你盖房子，你是自己一砖一瓦的盖简单呢，还是拿一个现成的架子往上面添东西简单呢？结果不言而喻吧，有一个半成品的架子，你只需要添上一些你自己额外需要加的东西就好了。这就是框架的好处
  - web开发的MVC模式，M是模型，V是视图（表现层），C是控制层。框架就是M层啦，他把一套不涉及任何业务相关的东西都写好了包装起来，你去用就可以了，C是控制层，他是没法写的，因为不同的系统有不同的业务逻辑，框架不可能帮你把业务逻辑也写进去啦。就好比你盖房子的架子，他只能做到一个架子，不是因为他不能完全弄好，而是因为他没法去加，他也不知道你到底是需要什么颜色的瓦片，但是相比来看，框架把很多复杂的东西都弄好了，你只要在上面添加你独有的东西就可以了
- 为什么要学习框架
  - 框架可以帮助省略掉一些基本的相同底层代码的反复书写，只需调用框架的方法就可以实现你想要的功能
  - 学习框架的目的就是提高项目的编写效率，使你可以有更多的时间去编写属于自己独特的东西，而不需要将大量的时间花费在底层代码的书写上

### 19.2 gin框架

- [Gin框架](https://github.com/gin-gonic/gin)是一个轻量级的Web框架，基于Go语言开发，旨在提供高性能和简洁的API。它具有快速的路由和中间件支持，使得构建Web应用变得更加简单和高效。无论是构建小型的API服务还是大型的Web应用，Gin框架都能够满足你的需求

#### 19.2.1 gin框架的快速入门

- 安装gin框架

```go
// 下载Gin框架源码包
go get -u github.com/gin-gonic/gin
```

- 快速入门案例

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	// 创建一个默认的路由引擎
	r := gin.Default()
	// GET：请求方式；/hello：请求的路径
	// 当客户端以GET方法请求/hello路径时，会执行后面的匿名函数
	r.GET("/hello", func(c *gin.Context) {
		// c.JSON：返回JSON格式的数据
		c.JSON(200, gin.H{ // H是一个开箱即用的map
			"message": "Hello world!",
		})
	})
	// 启动HTTP服务，默认在0.0.0.0:8080启动服务
	r.Run()
}
```

- gin的响应和请求
  - **响应方式**: 通过不同的方式将处理结果返回给客户端
    -  **String**: 使用String方法返回字符串类型的响应内容
    - **JSON**: 使用JSON方法返回JSON类型的响应内容
    - **HTML**: 使用HTML方法返回HTML类型的响应内容
    - **XML**: 使用XML方法返回XML类型的响应内容
    - **文件**: 将文件服务于指定的URL路径上，可以用于提供静态资源（如图片、CSS文件、JavaScript文件等
  - **请求参数**: 可以通过不同的方法获取客户端不同类型的请求参数
    - **查询参数 (Query Parameters):** 这些参数通常是通过 URL 的查询字符串传递的，可以使用 `Query` 方法来获取
    - **动态参数 (Path Parameters)**: 这些参数通常是作为 URL 路径的一部分传递的，可以使用 `Param` 方法来获取
    - **表单参数 (Form Parameters):** 这些参数通常是通过表单提交的，可以使用 `PostForm` 方法来获取
    - **原始参数 (Raw Data)**: 这些参数是请求的原始数据，可以使用 `GetRawData` 方法来获取

#### 19.2.2 gin框架RESTful API的实现

##### 19.2.2.1 什么是RESTful API

-  Restful API是一种网络应用程序的设计风格和开发方式，基于HTTP，可以使用XML格式定义或JSON格式定义，它使用URL定位资源，用HTTP动词（GET,POST,DELETE,DETC）描述操作

- [参考文档](https://blog.csdn.net/weixin_69619960/article/details/127943750?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-127943750-blog-130676526.235^v43^pc_blog_bottom_relevance_base1&spm=1001.2101.3001.4242.2&utm_relevant_index=4)
- **URL和URI和URN**
  - 在 Web 开发中，URL（Uniform Resource Locator）和 URI（Uniform Resource Identifier）是两个重要的概念，它们经常被混淆，但实际上有些微的差异。
    1. **URL（统一资源定位符）**:
       - URL 是 URI 的子集。
       - URL 是一种特定类型的 URI，它包含了用于定位资源的信息，通常包括协议（例如 HTTP、HTTPS）、主机名、端口号和资源路径等。
       - 例如：`https://www.example.com/index.html` 是一个 URL。
    2. **URI（统一资源标识符）**:
       - URI 是用来唯一标识资源的字符串。
       - URI 是一个更加通用的概念，它不仅仅指定了如何找到资源，还可以唯一标识资源本身。
       - URL 是 URI 的一种特定形式。
       - 例如：`mailto:example@example.com` 是一个 URI，它用于唯一标识一个邮箱地址。
    3. **URN（统一资源名称）**：URN是另一种URI形式，用于标识资源的名称，而不指定资源的位置或获取方式。URN的典型例子是ISBN编号，它标识了一本书，但不提供获取该书的具体位置。URN的格式为`urn:namespace:identifier`，其中namespace是一个标识符，用于指定URN的命名空间
  - 综上所述，URL 是 URI 的一种特定形式，它包含了用于定位资源的信息，而 URI 则是一种更加通用的概念，可以用来唯一标识任何资源

##### 19.2.2.2 使用gin实现RESTful API的GET操作

- GET 请求通常用于获取资源，而不会对资源进行修改。它类似于数据库中的 SELECT 操作，只是用于检索数据而不会对数据进行更改。无论进行多少次操作，结果都是一样的。
- GET 请求的参数通常附加在 URL 的查询字符串中，这使得请求可以包含特定的查询参数以便服务器可以正确地响应。然而，需要注意的是，不同的浏览器对 URL 的长度有不同的限制，因此在设计 API 时，应当注意避免过长的 URL，以免超出某些浏览器的限制

- **GET参数传参和接收**

  - 在Web开发中，GET参数是通过URL中的查询字符串传递给服务器的数据。这些参数出现在URL的问号（?）后面，多个参数之间使用 `&` 分隔, 并以键值对的形式进行传递。例如，`https://example.com/api/resource?param1=value1&param2=value2` 中的 `param1` 和 `param2` 就是GET参数，分别对应着值 `value1` 和 `value2`

  - 在Gin框架中，服务端可以通过多种方式接收GET方法传递的参数
    - **Query String 参数**：通过查询字符串传递参数是GET方法最常用的方式。在URL中使用 `?` 后跟着参数名和参数值的键值对，多个参数之间使用 `&` 分隔。在Gin框架中，可以使用 `c.Query("paramName")` 方法获取单个参数的值，或者使用 `c.Request.URL.Query()` 方法获取所有参数的键值对
    - **动态路由参数**：在路由路径中定义动态参数，这些参数会从请求路径中提取。在Gin框架中，可以使用 `:paramName` 来定义动态参数，并通过 `c.Param("paramName")` 方法获取参数值
    - **默认参数**：Gin框架允许在路由路径中定义默认值，即当参数未提供时的默认值。可以使用 `:paramName?` 来定义带有默认值的动态参数

- 示例

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

type Userinfo struct {
	Name     string `json:"name"`
	Password string `json:"password"`
	Age      int    `json:"age"`
	Sex      string `json:"sex"`
}

var ReturnJson = make(map[string]interface{})

func demoDB(name string) (Userinfo, bool) {
	// 模拟数据库查询操作

	userinfo := map[string]Userinfo{}
	userinfo["kubei"] = Userinfo{Name: "kubei", Password: "chekongci@123", Age: 24, Sex: "男"}
	userinfo["Tom"] = Userinfo{Name: "Tom", Password: "1234567", Age: 18, Sex: "男"}
	userinfo["Jack"] = Userinfo{Name: "Jack", Password: "qwertyui", Age: 20, Sex: "男"}
	userinfo["kail"] = Userinfo{Name: "kail", Password: "zxcvbnm123", Age: 23, Sex: "女"}

	var returnInfo Userinfo
	var exists bool
	for key, value := range userinfo {
		if key == name {
			returnInfo = value
			exists = true
			break
		} else {
			exists = false
		}
	}
	return returnInfo, exists
}

func GetDemo(c *gin.Context) {
	// 使用Query方法获取url中的参数
	//name := c.Query("user")
	// 使用动态路由获取参数
	//name := c.Param("user")
	//使用默认值
	name := c.DefaultQuery("user", "admin")

	userinfo, exists := demoDB(name)
	returndata := ReturnJson
	if exists {
		returndata["code"] = http.StatusOK
		returndata["message"] = "后端查询成功"
		returndata["data"] = userinfo
	} else {
		returndata["code"] = http.StatusNotFound
		str := fmt.Sprintf("%s用户不存在", name)
		returndata["message"] = str
		returndata["data"] = nil
	}
	c.JSON(http.StatusOK, returndata)
}

func main() {
	engine := gin.Default()
	// 普通路由通过url+?参数进行路由查找
	engine.GET("/api/get", GetDemo)
	// 是一个动态路由路径，其中的 :user 是一个参数占位符，表示该部分的值会在请求时动态替换
	engine.GET("/api/get/:user", GetDemo)
	engine.Run(":8888")

}

```

- 客户端测试

![image-20240314230053914](https://cloud.006288.xyz/PicGo//image-20240314230053914.png)

##### 19.2.2.3 使用gin实现RESTful API的POST操作

- **POST请求用来新增一个资源** : POST请求向服务器发送数据，但是该请求会改变数据的内容(新添)，就像数据库的`insert`操作一样，会创建新的内容。且POST请求的请求参数都是请求体中，其大小是没有限制的

- **POST提交表单数据的方式**
  - **form-data**： 就是form表单中的multipart/form-data，会将表单数据处理为一条信息，用特定标签符将一条条信息分割开，而这个文件类型通常用来上传二进制文件。在 Gin 中，可以使用 `c.FormFile` 方法来处理 form-data 类型的数据
  - **x-www-form-urlencoded**：就是application/x-www-form-urlencoded，是form表单默认的encType，form表单会将表单内的数据转换为键值对，这种格式不能上传文件。在 Gin 中，可以使用 `c.PostForm` 方法来获取 x-www-form-urlencoded 类型的数据
  - **raw**：可以上传任意格式的文本，可以上传Text，JSON，XML等，但目前大部分还是上传JSON格式数据。当后端需要接收JSON格式数据处理的时候，可以采用这种格式来测试。在 Gin 中，可以使用 `c.ShouldBindJSON` 或 `c.ShouldBindXML` 方法来处理 raw 类型的数据

- 示例
  - 处理使用x-www-form-urlencoded的表单数据

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

func PostDemo(c *gin.Context) {
	// 处理使用x-www-form-urlencoded的表单数据
	name := c.PostForm("user")
	password := c.PostForm("pwd")
	age := c.PostForm("age")
	sex := c.DefaultPostForm("sex", "男")

	c.JSON(http.StatusOK, gin.H{
		"name":     name,
		"password": password,
		"age":      age,
		"sex":      sex,
	})

}

func main() {
	engine := gin.Default()

	engine.POST("/api/post", PostDemo)

	engine.Run(":8888")

}

```

- 验证

![image-20240315001212990](https://cloud.006288.xyz/PicGo//image-20240315001212990.png)

##### 19.2.2.4 使用gin实现RESTful API的PUT操作

- PUT 操作是一种 HTTP 请求方法，通常用于更新现有资源或创建新资源。PUT 请求的主要特点是它是幂等的，即多次相同的 PUT 请求会产生相同的结果，不会对资源产生副作用。PUT 请求的语义通常是用新的资源数据完全替换现有资源的数据。
- 在 RESTful API 中，PUT 请求通常用于更新现有资源的数据。客户端向服务器发送一个包含更新后的资源数据的 PUT 请求，服务器根据请求中的数据更新对应的资源。如果资源不存在，则服务器可以选择创建一个新的资源，但通常情况下，如果请求的资源不存在，服务器应该返回 404 Not Found 响应

- 示例

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

type Userinfo struct {
	Name     string `json:"name"`
	Password string `json:"password"`
	Age      int    `json:"age"`
	Sex      string `json:"sex"`
}

var ReturnJson = make(map[string]interface{})

func demoDB(name string) (Userinfo, bool) {
	// 模拟数据库查询操作

	userinfo := map[string]Userinfo{}
	userinfo["kubei"] = Userinfo{Name: "kubei", Password: "chekongci@123", Age: 24, Sex: "男"}
	userinfo["Tom"] = Userinfo{Name: "Tom", Password: "1234567", Age: 18, Sex: "男"}
	userinfo["Jack"] = Userinfo{Name: "Jack", Password: "qwertyui", Age: 20, Sex: "男"}
	userinfo["kail"] = Userinfo{Name: "kail", Password: "zxcvbnm123", Age: 23, Sex: "女"}

	var returnInfo Userinfo
	var exists bool
	for key, value := range userinfo {
		if key == name {
			returnInfo = value
			exists = true
			break
		} else {
			exists = false
		}
	}
	return returnInfo, exists
}

func PutDemo(c *gin.Context) {
	name := c.Query("name")
	password := c.Query("password")

	userinfo, exists := demoDB(name)
	returndata := ReturnJson

	if exists {
		if password != "" {
			userinfo.Password = password
		}
		returndata["code"] = http.StatusOK
		returndata["message"] = "后端查询成功"
		returndata["data"] = userinfo

	} else {
		returndata["code"] = http.StatusNotFound
		str := fmt.Sprintf("%s用户不存在,无法修改", name)
		returndata["message"] = str
		returndata["data"] = nil
	}
	c.JSON(http.StatusOK, returndata)
}

func main() {
	engine := gin.Default()
	// 普通路由通过url+?参数进行路由查找
	engine.PUT("/api/put", PutDemo)
	engine.Run(":8888")

}
```

![image-20240317221405956](https://cloud.006288.xyz/PicGo//image-20240317221405956.png)

##### 19.2.2.5 使用gin实现RESTful API的DELET操作

- DELETE 请求是 HTTP 请求方法之一，用于请求服务器删除指定的资源。它的主要作用是告诉服务器删除指定 URI（统一资源标识符）所代表的资源
- 示例

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

type User struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Age  int    `json:"age"`
}

var users = []User{
	{ID: "1", Name: "Alice", Age: 30},
	{ID: "2", Name: "Bob", Age: 35},
}

func deleteUser(c *gin.Context) {
	id := c.Param("id")

	var found bool
	for i, user := range users {
		if user.ID == id {
			// 从 users 切片中删除用户
			users = append(users[:i], users[i+1:]...)
			found = true
			break
		}
	}

	if !found {
		c.JSON(http.StatusNotFound, gin.H{"error": "User not found"})
		return
	}
	fmt.Println("删除完成后,系统中存在的用户: ", users)
	c.JSON(http.StatusOK, gin.H{"message": "User deleted successfully"})
}

func main() {
	router := gin.Default()

	fmt.Println("删除之前系统中存在的用户: ", users)

	router.DELETE("/api/users/:id", deleteUser)

	router.Run(":8888")
}

```

![image-20240317222225400](https://cloud.006288.xyz/PicGo//image-20240317222225400.png)

#### 19.2.3 模型绑定

- 要将请求体绑定到结构体中，使用模型绑定。 Gin目前支持JSON、XML、YAML和标准表单值的绑定（foo=bar＆boo=baz）

- 使用时，需要在要绑定的所有字段上，设置相应的tag。 例如，使用 JSON 绑定时，设置字段标签为 `json:"fieldname"`

- Gin提供了两类绑定方法：

  - Type\- Must bind
    - **Methods** - `Bind`, `BindJSON`, `BindXML`, `BindQuery`, `BindYAML`
    - **Behavior** - 这些方法属于 `MustBindWith` 的具体调用。 如果发生绑定错误，则请求终止，并触发 `c.AbortWithError(400, err).SetType(ErrorTypeBind)`。响应状态码被设置为 400 并且 `Content-Type` 被设置为 `text/plain; charset=utf-8`。 如果您在此之后尝试设置响应状态码，Gin会输出日志 `[GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422`。 如果您希望更好地控制绑定，考虑使用 `ShouldBind` 等效方法。
  - Type\- Should bind
    - **Methods** - `ShouldBind`, `ShouldBindJSON`, `ShouldBindXML`, `ShouldBindQuery`, `ShouldBindYAML`
    - **Behavior** - 这些方法属于 `ShouldBindWith` 的具体调用。 如果发生绑定错误，Gin 会返回错误并由开发者处理错误和请求
  - 使用 Bind 方法时，Gin 会尝试根据 Content-Type 推断如何绑定。 如果你明确知道要绑定什么，可以使用 `MustBindWith` 或 `ShouldBindWith`

##### 19.2.3.1 使用ShouldBindJSON绑定

  ```go
  package main
  
  import (
  	"github.com/gin-gonic/gin"
  	"net/http"
  )
  
  type Userinfo struct {
      // 如果需要使用yaml、xml等格式需要在结构体上打上tag
  	Name     string `json:"name"`
  	Password string `json:"password"`
  	Age      int `json:"age"`
  	Sex      string `json:"sex"`
  }
  
  var ReturnJson = make(map[string]interface{})
  
  func PostDemo(c *gin.Context) {
  	userinfo := Userinfo{}
      // 如果需要使用yaml、xml等格式使用ShouldBind"xxx"即可
  	if err := c.ShouldBindJSON(&userinfo); err != nil {
  		ReturnJson["code"] = http.StatusInternalServerError
  		ReturnJson["message"] = "绑定失败"
  		ReturnJson["data"] = nil
  		c.JSON(http.StatusInternalServerError, ReturnJson)
  	} else {
  		ReturnJson["code"] = http.StatusOK
  		ReturnJson["message"] = "绑定成功"
  		ReturnJson["data"] = userinfo
  		c.JSON(http.StatusOK, ReturnJson)
  	}
  }
  
  func main() {
  	engine := gin.Default()
  
  	engine.POST("/api/post", PostDemo)
  
  	engine.Run(":8888")
  
  }
  
  ```

  <img src="https://cloud.006288.xyz/PicGo//image-20240315004847322.png" alt="image-20240315004847322" style="zoom: 80%;" />

##### 19.2.3.2 使用ShouldBindUri绑定

  ```go
  package main
  
  import (
  	"github.com/gin-gonic/gin"
  	"net/http"
  )
  
  type Userinfo struct {
      // 使用uri给结构体打上标签
  	Name     string `json:"name" form:"name" uri:"name"`
  	Password string `json:"password" form:"password" uri:"password"`
  	Age      int    `json:"age" form:"age" uri:"age"`
  	Sex      string `json:"sex" form:"sex" uri:"sex"`
  }
  
  var ReturnJson = make(map[string]interface{})
  
  func PostDemo(c *gin.Context) {
  	userinfo := Userinfo{}
  	if err := c.ShouldBindUri(&userinfo); err != nil {
  		ReturnJson["code"] = http.StatusInternalServerError
  		ReturnJson["message"] = "绑定失败"
  		ReturnJson["data"] = nil
  		c.JSON(http.StatusInternalServerError, ReturnJson)
  	} else {
  		ReturnJson["code"] = http.StatusOK
  		ReturnJson["message"] = "绑定成功"
  		ReturnJson["data"] = userinfo
  		c.JSON(http.StatusOK, ReturnJson)
  	}
  }
  
  func main() {
  	engine := gin.Default()
  
  	engine.POST("/api/post/:name/:password/:age/:sex", PostDemo)
  
  	engine.Run(":8888")
  
  }
  
  ```

  <img src="https://cloud.006288.xyz/PicGo//image-20240316222804655.png" alt="image-20240316222804655" style="zoom:80%;" />

##### 19.2.3.3 使用ShouldBindQuery绑定

  ```go
  package main
  
  import (
  	"github.com/gin-gonic/gin"
  	"net/http"
  )
  
  type Userinfo struct {
      // 使用form给结构体打上tag
  	Name     string `json:"name" form:"name"`
  	Password string `json:"password" form:"password"`
  	Age      int    `json:"age" form:"age"`
  	Sex      string `json:"sex" form:"sex"`
  }
  
  var ReturnJson = make(map[string]interface{})
  
  func PostDemo(c *gin.Context) {
  	userinfo := Userinfo{}
      // 使用ShouldBindQuery绑定至结构体
  	if err := c.ShouldBindQuery(&userinfo); err != nil {
  		ReturnJson["code"] = http.StatusInternalServerError
  		ReturnJson["message"] = "绑定失败"
  		ReturnJson["data"] = nil
  		c.JSON(http.StatusInternalServerError, ReturnJson)
  	} else {
  		ReturnJson["code"] = http.StatusOK
  		ReturnJson["message"] = "绑定成功"
  		ReturnJson["data"] = userinfo
  		c.JSON(http.StatusOK, ReturnJson)
  	}
  }
  
  func main() {
  	engine := gin.Default()
  
  	engine.POST("/api/post", PostDemo)
  
  	engine.Run(":8888")
  
  }
  ```

  <img src="https://cloud.006288.xyz/PicGo//image-20240316222221673.png" alt="image-20240316222221673" style="zoom:80%;" />

##### 19.2.3.4 使用ShouldBind绑定

  - Gin 会尝试根据 Content-Type 推断自动绑定, tag用form

  ```go
  package main
  
  import (
  	"github.com/gin-gonic/gin"
  	"net/http"
  )
  
  type Userinfo struct {
  	Name     string `json:"name" form:"name" html:"name"`
  	Password string `json:"password" form:"password" html:"password"`
  	Age      int    `json:"age" form:"age" html:"age"`
  	Sex      string `json:"sex" form:"sex" html:"sex"`
  }
  
  var ReturnJson = make(map[string]interface{})
  
  func PostDemo(c *gin.Context) {
  	userinfo := Userinfo{}
      // 使用ShouldBind自动绑定
  	if err := c.ShouldBind(&userinfo); err != nil {
  		ReturnJson["code"] = http.StatusInternalServerError
  		ReturnJson["message"] = "绑定失败"
  		ReturnJson["data"] = nil
  		c.JSON(http.StatusInternalServerError, ReturnJson)
  	} else {
  		ReturnJson["code"] = http.StatusOK
  		ReturnJson["message"] = "绑定成功"
  		ReturnJson["data"] = userinfo
  		c.JSON(http.StatusOK, ReturnJson)
  	}
  }
  
  func main() {
  	engine := gin.Default()
  
  	engine.POST("/api/post/", PostDemo)
  
  	engine.Run(":8888")
  
  }
  ```

  ![image-20240316223407330](https://cloud.006288.xyz/PicGo//image-20240316223407330.png)

#### 19.2.4表单验证器

- 表单验证器是Gin框架中的一个功能，用于验证HTTP请求中的表单数据是否符合预期的格式和要求。使用表单验证器可以确保应用程序接收到的数据是有效和安全的
- 验证器基本使用

```go
// 导入验证器所需要的包
import (
    "github.com/gin-gonic/gin"
    "github.com/go-playground/validator/v10"
)

// 在结构体标签上使用binding标签指定了字段需要进行的验证
type User struct {
    // 用户名必须要存在,并且大于四位小于20位
    Username string `json:"username" binding:"required,min=4,max=20"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8"`
}
```

- 常用验证器

```go
// 可以指定必须绑定的字段。 如果一个字段的 tag 加上了 `binding:"required"`，但绑定时是空值, Gin 会报错
required：确保字段的值不为空。

min：指定字段的最小长度或值。
max：指定字段的最大长度或值。
email：验证字段是否符合电子邮件地址的格式。
url：验证字段是否符合URL地址的格式。
numeric：验证字段是否为数字。
alpha：验证字段是否只包含字母字符。
alphanum：验证字段是否只包含字母字符和数字。
regex：使用正则表达式验证字段的值。
len：验证字段的长度是否等于指定的值。
eq：验证字段的值是否等于另一个字段的值
ne 验证字段的值是否不等于另一个字段的值
gt 验证字段的值是否大于另一个字段的值
gte 验证字段的值是否大于等于另一个字段的值
lt 验证字段的值是否小于另一个字段的值
lte 验证字段的值是否小于等于另一个字段的值
"-" 忽略字段，如：binding:"-"

// 枚举  只能是red 或green
oneof=red green 

// 字符串  
contains=fengfeng  // 包含fengfeng的字符串
excludes // 不包含
startswith  // 字符串前缀
endswith  // 字符串后缀

// 数组
dive  // dive后面的验证就是针对数组中的每一个元素

// 网络验证
ip
ipv4
ipv6
uri
url
// uri 在于I(Identifier)是统一资源标示符，可以唯一标识一个资源。
// url 在于Locater，是统一资源定位符，提供找到该资源的确切路径

// 日期验证  1月2号下午3点4分5秒在2006年
datetime=2006-01-02
```

##### 19.2.4.1 使用内置验证器

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

type Userinfo struct {
    // 验证用户名是否存在并且用户名长度是否大于4小于20
	Name     string `json:"name" form:"name" html:"name" binding:"required,max=20,min=4"`
    // 验证密钥是否存在
	Password string `json:"password" form:"password" html:"password" binding:"required"`
    // 验证用户年龄是否存在并且是否大于18岁
	Age      int    `json:"age" form:"age" html:"age" binding:"required,gt=18"`
	Sex      string `json:"sex" form:"sex" html:"sex"`
}

var ReturnJson = make(map[string]interface{})

func PostDemo(c *gin.Context) {
	userinfo := Userinfo{}
	if err := c.ShouldBind(&userinfo); err != nil {
		ReturnJson["code"] = http.StatusInternalServerError
		ReturnJson["message"] = "绑定失败"
		ReturnJson["data"] = err.Error()
		c.JSON(http.StatusInternalServerError, ReturnJson)
	} else {
		ReturnJson["code"] = http.StatusOK
		ReturnJson["message"] = "绑定成功"
		ReturnJson["data"] = userinfo
		c.JSON(http.StatusOK, ReturnJson)
	}
}

func main() {
	engine := gin.Default()

	engine.POST("/api/post/", PostDemo)

	engine.Run(":8888")

}

```

![image-20240316234318294](https://cloud.006288.xyz/PicGo//image-20240316234318294.png)

##### 19.2.4.2 自定义验证器

- 要自定义验证器，可以使用`validator`库提供的自定义验证器功能

```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	"github.com/go-playground/validator/v10"
	"net/http"
)

type Userinfo struct {
    // 在结构体标签binding中著名自定义验证器标签
	Name     string `json:"name" form:"name" html:"name" binding:"required,myValidator"`
	Password string `json:"password" form:"password" html:"password" binding:"required"`
	Age      int    `json:"age" form:"age" html:"age" binding:"required,gt=18"`
	Sex      string `json:"sex" form:"sex" html:"sex"`
}

var ReturnJson = make(map[string]interface{})

func PostDemo(c *gin.Context) {
	userinfo := Userinfo{}
	if err := c.ShouldBind(&userinfo); err != nil {
		ReturnJson["code"] = http.StatusInternalServerError
		ReturnJson["message"] = "绑定失败"
		ReturnJson["data"] = err.Error()
		c.JSON(http.StatusInternalServerError, ReturnJson)
	} else {
		ReturnJson["code"] = http.StatusOK
		ReturnJson["message"] = "绑定成功"
		ReturnJson["data"] = userinfo
		c.JSON(http.StatusOK, ReturnJson)
	}
}

// 实验验证函数业务逻辑
func MyValidator(fl validator.FieldLevel) bool {
	name := fl.Field().String()
	return len(name) >= 4 && len(name) <= 20
}


func main() {
	engine := gin.Default()
	// 在gin初始化之前注册验证函数
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		v.RegisterValidation("myValidator", MyValidator)

		engine.POST("/api/post/", PostDemo)

		engine.Run(":8888")
	}

}

```

![image-20240317004948614](https://cloud.006288.xyz/PicGo//image-20240317004948614.png)

##### 19.2.4.3 自定义验证的错误信息

- 当验证不通过时，会给出错误的信息，但是原始的错误信息不太友好，不利于用户查看
- 我们可以自定义错误信息,方便用户查看, 只需要给结构体加一个msg 的tag,当出现错误时，就可以来获取出错字段上的msg
- 在Gin框架中，使用`msg`标签来自定义错误消息并不会直接生效。`msg`标签是用来描述字段的，而不是用来自定义验证器错误消息的。
- 要自定义验证器错误消息，需要使用Gin框架提供的`err.ErrorMap()`函数。这个函数返回一个包含每个字段验证失败错误消息的映射。然后您可以根据需要对这些错误消息进行处理，以生成自定义的错误响应

```go
// GetValidMsg 函数根据验证错误信息返回相应的自定义错误消息
func GetValidMsg(err error, obj interface{}) string {
	// 使用反射来获取 obj 的类型信息
	getObj := reflect.TypeOf(obj)

	// 将 err 接口断言为 validator.ValidationErrors 类型
    // validator.ValidationErrors 类型是 go-playground/validator/v10 库中用于表示验证失败的结构体
    // 如果断言成功，说明 err 包含了验证失败的信息
	if errs, ok := err.(validator.ValidationErrors); ok {
		// 遍历了验证失败的信息列表 errs，每个 e 都是一个 validator.FieldError 类型的结构体，
        // 它包含了验证失败的具体信息，如字段名、错误标签等
		for _, e := range errs {
			// 尝试根据错误信息中的字段名（e.Field()）从结构体的类型信息中获取具体的字段信息。
            // 如果字段存在，则 exists 为 true，并将字段信息存储在 f 中
			if f, exists := getObj.FieldByName(e.Field()); exists {
				// 如果字段存在，并且它的标签中定义了 msg 字段，那么我们就从标签中获取自定义错误消息。
                // 这样我们就可以在代码中直接定义字段的自定义错误消息
				msg := f.Tag.Get("msg")
				return msg
			}
		}
	}

	// 如果无法找到自定义错误消息，则返回原始错误信息
	return err.Error()
}
```

- 示例

```go
package main

import (
	"github.com/gin-gonic/gin"
	"github.com/gin-gonic/gin/binding"
	"github.com/go-playground/validator/v10"
	"net/http"
	"reflect"
)

type Userinfo struct {
	Name     string `json:"name" form:"name" html:"name" binding:"required,myValidator" msg:"用户名不能为空,同时用户名长度需要在4~20位"`
	Password string `json:"password" form:"password" html:"password" binding:"required" msg:"密码不能为空"`
	Age      int    `json:"age" form:"age" html:"age" binding:"required,gte=18" msg:"用户未成年,不允许注册"`
	Sex      string `json:"sex" form:"sex" html:"sex"`
}

var ReturnJson = make(map[string]interface{})

func MyValidator(fl validator.FieldLevel) bool {
	name := fl.Field().String()
	return len(name) >= 4 && len(name) <= 20
}

func getError(err error, assertType interface{}) string {
	astype := reflect.TypeOf(assertType)

	if errs, ok := err.(validator.ValidationErrors); ok {
		for _, e := range errs {
			if f, exits := astype.FieldByName(e.Field()); exits {
				errMsg := f.Tag.Get("msg")
				return errMsg
			}
		}
	}
	return err.Error()
}

func PostDemo(c *gin.Context) {
	userinfo := Userinfo{}
	if err := c.ShouldBind(&userinfo); err != nil {
		errMsg := getError(err, userinfo)
		ReturnJson["code"] = http.StatusInternalServerError
		ReturnJson["message"] = "绑定失败"
		ReturnJson["data"] = errMsg // 将错误消息作为数据部分返回
		c.JSON(http.StatusInternalServerError, ReturnJson)
		return
	}

	ReturnJson["code"] = http.StatusOK
	ReturnJson["message"] = "绑定成功"
	ReturnJson["data"] = userinfo
	c.JSON(http.StatusOK, ReturnJson)
}

func main() {
	engine := gin.Default()

	// 注册验证器
	if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
		v.RegisterValidation("myValidator", MyValidator)
	}

	engine.POST("/api/post/", PostDemo)

	engine.Run(":8888")
}

```

![image-20240317214130469](https://cloud.006288.xyz/PicGo//image-20240317214130469.png)

#### 19.2.5 文件上传和下载

##### 19.2.5.1 文件上传

- 文件上传是指客户端将文件发送到服务器的操作。在 Gin 中，处理文件上传通常包括以下步骤：
  1. 客户端将文件通过 HTTP POST 请求发送到服务器。
  2. 服务器端使用 Gin 提供的方法来处理上传的文件。
  3. 服务器端将文件保存到指定的目录或者进行进一步的处理。
  4. 返回响应告知客户端文件上传成功或者失败的情况

###### 19.2.5.1.1 单文件上传

- 单文件上传是指客户端一次只上传一个文件到服务器的操作。在 Gin 中处理单文件上传的步骤通常如下：
  1. 客户端通过 HTTP POST 请求将文件上传到服务器。
  2. 服务器端使用 Gin 提供的方法获取上传的文件，并将其保存到指定的目录或进行进一步处理

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

var ReturnJson = make(map[string]interface{})

func fileUpload(c *gin.Context) {
    // FormFile函数用于获取上传的文件。它返回一个文件对象，其中包含了文件的元数据（名称、大小等）
	file, err := c.FormFile("file")
	fmt.Println(err)
	if err != nil {
		ReturnJson["code"] = http.StatusInternalServerError
		ReturnJson["message"] = "文件上传失败"
		ReturnJson["data"] = nil
		c.JSON(http.StatusInternalServerError, ReturnJson)
		return
	}

	ReturnJson["code"] = http.StatusOK
	ReturnJson["message"] = "文件上传成功"
	ReturnJson["data"] = file
	c.JSON(http.StatusOK, ReturnJson)
}

func main() {
	router := gin.Default()

	router.POST("/api/file", fileUpload)

	router.Run(":8888")
}

```

![image-20240317231146157](https://cloud.006288.xyz/PicGo//image-20240317231146157.png)

###### 19.2.5.1.2 多文件上传

- 在 Gin 中处理多文件上传时，我们需要使用 `MultipartForm` 方法来获取整个表单，并从中提取文件列表。然后，我们可以遍历文件列表，逐个处理每个文件

```go
package main

import (
	"github.com/gin-gonic/gin"
	"net/http"
)

var ReturnJson = make(map[string]interface{})

func fileUpload(c *gin.Context) {
	form, err := c.MultipartForm()
	if err != nil {
		ReturnJson["code"] = http.StatusInternalServerError
		ReturnJson["message"] = "文件上传失败"
		ReturnJson["data"] = nil
		c.JSON(http.StatusInternalServerError, ReturnJson)
		return
	}

	ReturnJson["code"] = http.StatusOK
	ReturnJson["message"] = "文件上传成功"
	ReturnJson["data"] = files
	c.JSON(http.StatusOK, ReturnJson)
}

func main() {
	router := gin.Default()

	router.POST("/api/file", fileUpload)

	router.Run(":8888")
}

```



###### 19.2.5.1.3 服务端保存文件的方式

- **使用 `c.SaveUploadedFile` 方法：** 这是 Gin 框架提供的方法，用于将上传的文件保存到服务器的指定路径
- **使用标准库的文件操作方法：** 你也可以使用标准库中的文件操作方法（如 `os.Create`）来创建文件，并将上传的文件内容写入到文件中。这种方式更灵活，可以更加精细地控制文件的保存方式

- 示例

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"io"
	"net/http"
	"os"
)

var ReturnJson = make(map[string]interface{})

func fileUpload(c *gin.Context) {
    // form是*multipart.Form 类型的变量，它包含了上传的文件和其他表单字段的信息
	form, err := c.MultipartForm()
	if err != nil {
		// 错误日志
		fmt.Println("MultipartForm error:", err)
		ReturnJson["code"] = http.StatusInternalServerError
		ReturnJson["message"] = "获取上传表单失败"
		ReturnJson["data"] = nil
		c.JSON(http.StatusInternalServerError, ReturnJson)
		return
	}

	// 使用SaveUploadedFile保存文件
    
	// 这个ginSave字段要和你发送请求的方式或您的表单设置的字段一样
    // files 是一个 []*multipart.FileHeader 类型的切片，它代表了上传表单中名为 "ginSave" 的文件字段
	// 这个切片中存储了所有上传的文件的信息，每个元素都是一个 multipart.FileHeader 类型的结构体，包含了上传的文件的元数据，比如文件名、文件大小等信息
    
	files := form.File["ginSave"]
	for _, file := range files {
		err := c.SaveUploadedFile(file, "./gin/"+file.Filename)
		if err != nil {
			// 错误日志
			fmt.Println("SaveUploadedFile error:", err)
			ReturnJson["code"] = http.StatusInternalServerError
			ReturnJson["message"] = "文件保存失败"
			ReturnJson["data"] = nil
			c.JSON(http.StatusInternalServerError, ReturnJson)
			return
		}
	}

	// 使用os.Create实现文件保存

	// 这个osCreate字段要和你发送请求的方式或您的表单设置的字段一样
	files = form.File["osCreate"]

	for _, file := range files {
        // 调用 multipart.FileHeader 类型的结构体的Open方法
		fileBuf, err := file.Open()
		defer fileBuf.Close()
		if err != nil {
			fmt.Println("文件打开失败")
			return
		}
        
        _, err = os.Stat("./osCreate/")
        if os.IsNotExist(err) {
            if err := os.Mkdir("osCreate", os.ModePerm); err != nil {
                c.JSON(500, gin.H{
                    "msg": "目录创建失败",
                })
                return
            }
        }

		f, err := os.Create("./osCreate/" + file.Filename)
		if err != nil {
			fmt.Println("文件创建失败")
			return
		}
		io.Copy(f, fileBuf)

	}

	ReturnJson["code"] = http.StatusOK
	ReturnJson["message"] = "文件上传成功"
	ReturnJson["data"] = form
	c.JSON(http.StatusOK, ReturnJson)
}

func main() {

	router := gin.Default()

	// 为 multipart forms 设置较低的内存限制 (默认是 32 MiB)
	// 单位是字节， << 是左移预算符号，等价于 8 * 2^20
	// gin对文件上传大小的默认值是32MB
	router.MaxMultipartMemory = 8 << 20 // 允许最大8MB的文件

	router.POST("/api/file", fileUpload)

	router.Run(":8888")
}
```

###### 19.2.5.1.4 读取上传的文件

- 场景: 客户端上传文件后,后端将上传的文件内容放回给前端展示

```go
package main

import (
	"encoding/base64"
	"github.com/gin-gonic/gin"
	"io"
	"os"
)

func postUP(c *gin.Context) {
	// fh是*multipart.Form 类型的变量，它包含了上传的文件和其他表单字段的信息
	fh, err := c.MultipartForm()
	if err != nil {
		c.JSON(500, gin.H{
			"msg": "文件上传失败",
		})
		return
	}
	// files 是一个 []*multipart.FileHeader 类型的切片，它代表了上传表单中名为 "file" 的文件字段
	// 这个切片中存储了所有上传的文件的信息，每个元素都是一个 multipart.FileHeader 类型的结构体，包含了上传的文件的元数据，比如文件名、文件大小等信息
	files := fh.File["file"]

	_, err = os.Stat("./osDir/")
	if os.IsNotExist(err) {
		if err := os.Mkdir("osDir", os.ModePerm); err != nil {
			c.JSON(500, gin.H{
				"msg": "目录创建失败",
			})
			return
		}
	}

	for _, file := range files {
		// 调用 multipart.FileHeader 类型的结构体的Open方法
		fileBuf, _ := file.Open()

		defer fileBuf.Close()
		f, _ := os.Create("./osDir/" + file.Filename)
		io.Copy(f, fileBuf)

		// 将文件读取位置重置到文件开头
		_, err = fileBuf.Seek(0, 0)
		if err != nil {
			// 处理错误
			continue
		}

		fileContent, _ := io.ReadAll(fileBuf)

		filename := file.Filename
		filesize := file.Size
		filecontent := base64.StdEncoding.EncodeToString(fileContent)

		c.JSON(200, gin.H{
			"msg":         "文件上传成功",
			"filename":    filename,
			"filesize":    filesize,
			"filecontent": filecontent,
		})
	}

}

func main() {
	routend := gin.Default()

	routend.MaxMultipartMemory = 8 << 20

	routend.POST("/upload", postUP)

	routend.Run(":8888")
}

```

![image-20240321000731110](https://cloud.006288.xyz/PicGo//image-20240321000731110.png)

##### 19.2.5.2 文件下载

- 文件下载是指服务器端向客户端提供文件的操作。在 Gin 中，处理文件下载通常包括以下步骤：
  1. 客户端发送请求到服务器，请求下载特定的文件。
  2. 服务器端根据请求，将文件读取并提供给客户端。
  2. 客户端接收文件并保存到本地或者进行其他操作

- 一些小文件或者图片,如果客户端请求,服务端会直接显示内容,但是并不会直接下载这个文件,如果需要下载我们需要使浏览器唤起下载行为

```go
c.Writer.Header().Add.Header("Content-Type", "application/octet-stream")//表示是文件流,唤起浏览器下载，一般设置了这个,就要设置文件名
c.Writer.Header().Add.Header("Content-Disposition", "attachment; filename="+"test.png") // 用来指定下载下来的文件名
c.Writer.Header().Add.Header("Content-Transfer-Encoding", "binary")   // 表示传输过程中的编码形式，乱码问题可能就是因为它
c.File("uploads/12.png")
```

- 示例
  - 服务器端根据请求，将文件读取并提供给客户端

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func getDownload(c *gin.Context) {
	file := c.Query("file")
	//fmt.Println(file)
	c.File(file)
}

func main() {
	routend := gin.Default()

	routend.GET("/download", getDownload)

	routend.Run(":8888")
}

```

![image-20240321005514593](https://cloud.006288.xyz/PicGo//image-20240321005514593.png)

- 客户端发送请求到服务器，请求下载特定的文件

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func getDownload(c *gin.Context) {
	file := c.Query("file")
	c.Writer.Header().Add.Header("Content-Type", "application/octet-stream")
	c.Writer.Header().Add.Header("Content-Disposition", "attachment; filename="+"kubei.txt")
	c.Writer.Header().Add.Header("Content-Transfer-Encoding", "binary")
	c.File(file)
}

func main() {
	routend := gin.Default()

	routend.GET("/download", getDownload)

	routend.Run(":8888")
}
```

- 客户端接收文件并保存到本地或者进行其他操作
  - 如果是前后端模式下，后端就只需要响应一个文件数据

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func getDownload(c *gin.Context) {
	file := c.Query("file")
	c.Writer.Header().Add.Header("filename", file)
	c.Writer.Header().Add.Header("msg", "文件下载成功")
	c.File(file)
}

func main() {
	routend := gin.Default()

	routend.GET("/download", getDownload)

	routend.Run(":8888")
}

```

> 前后端模式下的文件下载，进程会出现中文乱码问题，我们需要进行修改，并且指定一些格式
>
> ```go
> c.Writer.Header().Add.Header("Content-Disposition", "attachment; filename*=utf-8''"+filename)
> ```

#### 19.2.6 路由管理

- 路由（Routing）是由一个 URL（或者叫路径）和一个特定的 HTTP 方法（GET、POST等）组成的，涉及到应用如何响应客户端对某个网站节点的访问

- 路由演示

```go
// 普通路由
r.GET("/index", func(c *gin.Context) {...})
// 访问形式: http://ip+端口:/index

// 动态路由
r.GET("/login:id", func(c *gin.Context) {...})
// 访问形式: http://ip+端口:/index/1
```

##### 19.2.6.1 路由分组

- 路由分组是在 Gin 框架中用于组织和管理路由的一种方式。它允许开发者将具有共同特性或者功能的路由进行分组，并对这些分组应用中间件、设置公共前缀等。
- 在 Gin 中，可以使用 `Group` 方法创建路由分组, 并习惯性一对`{}`包裹同组的路由，这只是为了看着清晰



- 示例

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	routend := gin.Default()

	userRouted := routend.Group("user")
	{
		userRouted.GET("get", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"msg": "这是userRouted路由的GET方法",
			})
		})
		userRouted.POST("post", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"msg": "这是userRouted路由的POST方法",
			})
		})
	}

	systemRouted := routend.Group("system")
	{
		systemRouted.GET("get", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"msg": "这是systemRouted路由的GET方法",
			})
		})
		systemRouted.POST("post", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"msg": "这是systemRouted路由的POST方法",
			})
		})
	}
	routend.Run(":8888")
}

```

![image-20240322233840774](https://cloud.006288.xyz/PicGo//image-20240322233840774.png)

##### 19.2.6.2 路由嵌套

- 路由嵌套允许你将一组相关的路由放置在一个共同的父级路由下，从而提高了代码的可读性和可维护性

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	routend := gin.Default()

	systemRouted := routend.Group("system")
	{
		systemRouted.GET("get", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"msg": "这是systemRouted路由的GET方法",
			})
		})
		systemRouted.POST("post", func(c *gin.Context) {
			c.JSON(200, gin.H{
				"msg": "这是systemRouted路由的POST方法",
			})
		})

		// 嵌套路由
		userRouted := systemRouted.Group("user")
		{
			userRouted.GET("get", func(c *gin.Context) {
				c.JSON(200, gin.H{
					"msg": "这是userRouted路由的GET方法",
				})
			})
			userRouted.POST("post", func(c *gin.Context) {
				c.JSON(200, gin.H{
					"msg": "这是userRouted路由的POST方法",
				})
			})
		}
	}
	routend.Run(":8888")
}
```



![image-20240322234226439](https://cloud.006288.xyz/PicGo//image-20240322234226439.png)

##### 19.2.6.3 路由文件抽离

- 在前面的示例中，我们直接将路由的定义全部写在 `main.go` 文件中，如果后面 路由越来越多，那将会越来越不好管理。所以，下一步我们应该考虑将抽离 `main.go`的文件
- 不管是路由分组、还是普通的路由，我们都可以通过单独编写函数，抽离到其他模块去，避免路由代码全部写在 `main.go` 代码中



- 抽离后

![image-20240323000212685](https://cloud.006288.xyz/PicGo//image-20240323000212685.png)

![image-20240322235714021](https://cloud.006288.xyz/PicGo//image-20240322235714021.png)



##### 19.2.6.4 Any方法

- 在 Gin 框架中，`Any` 方法用于注册一个可以处理所有 HTTP 方法的路由。这意味着无论是 GET、POST、PUT、DELETE 还是其他任何 HTTP 方法，都可以由这个路由来处理。`Any` 方法通常用于创建一种通用的路由，用于处理特定路径的所有请求方法

```go
package main

import (
    "net/http"

    "github.com/gin-gonic/gin"
)

func main() {
    router := gin.Default()

    // 使用 Any 方法注册一个通用路由
    router.Any("/user", func(c *gin.Context) {
        switch c.Request.Method {
        case http.MethodGet:
            // 处理 GET 请求
            c.String(http.StatusOK, "GET request on /user")
        case http.MethodPost:
            // 处理 POST 请求
            c.String(http.StatusOK, "POST request on /user")
        case http.MethodPut:
            // 处理 PUT 请求
            c.String(http.StatusOK, "PUT request on /user")
        case http.MethodDelete:
            // 处理 DELETE 请求
            c.String(http.StatusOK, "DELETE request on /user")
        default:
            // 处理其他请求方法
            c.String(http.StatusMethodNotAllowed, "Method Not Allowed")
        }
    })

    // 启动 Gin 服务器
    router.Run(":8080")
}
```



#### 19.2.7 重定向和路由转发

- 重定向和请求转发是两种常见的HTTP请求处理方式，它们都可以实现将请求从一个路径或地址转移到另一个路径或地址
- 重定向与请求转发的区别:
  - **重定向**是服务器端向客户端返回一个特殊的响应，告诉客户端重新发送一个新的请求到另一个路径或地址。**请求转发**是服务器端在内部将请求转移到另一个路径或地址，而不通知客户端。
  - **重定向**会改变浏览器的地址栏，显示新的路径或地址。请求转发不会改变浏览器的地址栏，显示原来的路径或地址。
  - **重定向**会增加一次网络请求，因为客户端需要重新发送一个新的请求。请求转发不会增加一次网络请求，因为服务器端在内部处理了请求。
  - **重定向**可以跨域，即可以将请求转移到不同的域名或协议。请求转发只能在同一个域名或协议下进行。
  - **重定向**会丢失原来请求的参数和数据。请求转发可以保留原来请求的参数和数据

##### 19.2.7.1 重定向

- 重定向是指当客户端发送一个请求时，服务器将该请求转发到另一个 URL 上，而客户端则会自动跳转到该新的 URL。重定向通常用于将用户引导到其他页面或者修正 URL。
- 在 HTTP 中，服务器通过发送状态码 `301 Moved Permanently` 或者 `302 Found` 来表示重定向
- 在 Gin 中，可以使用 `Redirect` 方法进行重定向, 支持重定向到外部其它域名,也支持充当向到当前服务的某个接口

```go
package main

import (
	"github.com/gin-gonic/gin"
	"goStuday/routes/userRoutes"
	"net/http"
)

func main() {
	routend := gin.Default()
	userRoutes.UserRoutes(routend)

	routend.GET("/index", func(c *gin.Context) {
		// 重定向到外部
		c.Redirect(http.StatusMovedPermanently, "https://www.baidu.com")
		// 重定向到内部
		//c.Redirect(http.StatusMovedPermanently, "/内部接口路径")

		c.Redirect(301, "/user/get")
	})
	
	routend.Run(":8888")
}
```

##### 19.2.7.2 路由转发

- 路由转发是指将一个请求转发到另一个路由进行处理。这与重定向不同，重定向会让客户端重新发起一个新的请求，而路由转发则是服务器在内部处理请求，并将结果返回给客户端。路由转发通常用于在不同的路由之间共享相同的处理逻辑
- 在 Gin 框架中，实现路由（请求）转发有多种方法，主要包括以下几种：
  1. **使用 `Forward` 方法**： Gin 框架本身并没有提供直接的路由转发方法，但你可以编写一个处理函数，根据请求的内容，重新构造一个新的请求并使用 `router.HandleContext(c)` 来实现转发。这种方式需要在处理函数中手动处理新请求和响应，并且需要注意保留原请求的相关信息。
  2. **使用 `Proxy` 中间件**： 你可以编写一个中间件函数，通过 `gin.Context` 中提供的方法来修改请求的路径、头部信息等，并使用 `http.ReverseProxy` 或者自己实现代理逻辑，将请求转发到目标地址。这种方式比较灵活，可以根据需要自定义转发逻辑。
  3. **使用 HTTP 客户端**： 在处理函数中，可以使用标准库中的 `http.Client` 来创建新的 HTTP 请求，并将目标地址的响应直接返回给客户端。这种方式比较直接简单，但需要注意处理请求和响应的错误情况。
  4. **使用反向代理服务器**： 另一种方式是通过配置反向代理服务器（如 Nginx、Apache 等），将请求转发到不同的后端服务器或者服务实例上。这种方式适用于在生产环境中部署多个服务并通过统一的域名进行访问



- 案例

```go
package main

import (
	"github.com/gin-gonic/gin"
	"goStuday/routes/userRoutes"
)

func main() {
	routend := gin.Default()
	userRoutes.UserRoutes(routend)

    // 将当前请求抓发到/user/get路由上
    
	routend.GET("/index", func(c *gin.Context) {
		c.Request.URL.Path = "/user/get"
		routend.HandleContext(c)
	})

	routend.Run(":8888")
}
```

#### 19.2.8 中间件

##### 19.2.8.1 中间件概述

- Gin 框架允许开发者在处理请求的过程中，加入用户自己的钩子（Hook）函数。这个钩子函数就叫中间件，中间件适合处理一些公共的业务逻辑，比如登录认证、权限校验、数据分页、 记录日志、耗时统计等
- 通俗的讲：中间件就是匹配路由前和匹配路由完成后执行的一系列操作
- Gin 中的中间件必须是一个 gin.HandlerFunc 类型，配置路由的时候可以传递多个 func 回调函数。中间件要放在最后一个回调函数的前面 ，触发的方法都可以称为中间件



- 中间件执行过程
  - 中间件可以注册多个，它们的执行顺序和注册时机相关，先注册的先执行
  - 这种先执行了当前中间件的前半部分逻辑，然后处理完之后的中间件后，最后继续执行当前中间件的后半部分的特性，可以让我们可以像洋葱一样，从外到内先处理 request 对象，再从内到外处理 response 对象，于是被称为 洋葱模型

![image-20240324232943553](https://cloud.006288.xyz/PicGo//image-20240324232943553.png)

- Gin 框架提供的默认中间件：
  1. **Logger 中间件**：记录请求的信息，如请求方法、请求路径、请求耗时等，并输出到控制台。Logger中间件将日志写入gin.DefaultWriter，即使配置了GIN_MODE=release
  2. **Recovery 中间件**：用于恢复 HTTP 请求处理函数（Handler）中出现的 panic，并返回一个 500 Internal Server Error 响应。

```go
func Default() *Engine {
	debugPrintWARNINGDefault()
	engine := New()
	engine.Use(Logger(), Recovery())
	return engine
}
```



- 自定义中间件的步骤
  - 定义中间件:  Gin中的中间件必须是一个`gin.HandlerFunc`类型
  - 注册中间件:  在gin框架中，我们可以为每个路由添加任意数量的中间件

```go
// 示例
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"time"
)

// 定义中间件
func TimeMiddleware(c *gin.Context) {
	startTime := time.Now()
	c.Next()
	since := time.Since(startTime)
	// 获取当前请求所对应的函数
	f := c.HandlerName()
	fmt.Printf("函数 %s 耗时 %d\n", f, since)
}

func main() {
	// 创建一个 Gin 引擎
	router := gin.Default()

	router.GET("/index", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"msg": "执行成功",
		})
	}).Use(TimeMiddleware) // 注册中间件

	// 启动服务，监听 8080 端口
	router.Run(":8080")
}
```



- 在 Gin 框架中，`c.Next()` 和 `c.Abort()` 是两个常用的方法，用于控制中间件链的执行流程
  - `c.Next()`
    - `c.Next()` 用于将控制权交给中间件链中的下一个中间件或路由处理函数。
    - 如果在中间件函数中调用了 `c.Next()`，则表示当前中间件已经处理完毕，将控制权交给下一个中间件。
    - 如果没有调用 `c.Next()`，则中间件链的执行会中止，不会继续向下执行
  - `c.Abort()`
    - `c.Abort()` 用于终止当前中间件链的执行，并立即结束请求的处理。
    - 如果在中间件函数中调用了 `c.Abort()`，则中间件链的执行会立即终止，不会继续向下执行。
    - 在调用 `c.Abort()` 之后，后续的中间件函数和路由处理函数都不会被调用

##### 19.2.8.2 全局路由中间件

- 全局路由中间件是在创建 Gin 引擎时使用 `Use` 方法注册的中间件，它会应用于所有的路由请求。这意味着无论是哪个路由被请求，都会先执行这些全局中间件

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"time"
)

// 定义中间件
func TimeMiddleware(c *gin.Context) {
	startTime := time.Now()
	c.Next()
	since := time.Since(startTime)
	// 获取当前请求所对应的函数
	f := c.HandlerName()
	fmt.Printf("函数 %s 耗时 %d\n", f, since)
}

func m1(c *gin.Context) {
	fmt.Println("我是中间件m1的第一道关卡")
	c.Next()
	fmt.Println("我是中间件m1的第二道关卡")
}

func m2(c *gin.Context) {
	fmt.Println("我是中间件m2的第一道关卡")
	c.Next()
	fmt.Println("我是中间件m2的第二道关卡")
}

func ServiceCode(c *gin.Context) {
	fmt.Println("这是业务代码")
	c.JSON(200, gin.H{
		"msg": "执行成功",
	})
}

func main() {
	// 创建一个 Gin 引擎
	router := gin.Default()

	// 为全局路由注册中间件
	router.Use(TimeMiddleware, m1, m2)

	router.GET("/index", ServiceCode)

	router.POST("/index", ServiceCode)

	// 启动服务，监听 8080 端口
	router.Run(":8080")
}
```

![image-20240324233221938](https://cloud.006288.xyz/PicGo//image-20240324233221938.png)



##### 19.2.8.3 为某个路由单独注册中间件

- 也可以为某个特定的路由单独注册中间件，这样该中间件只会在该路由被请求时执行

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"time"
)

// 定义中间件
func TimeMiddleware(c *gin.Context) {
	startTime := time.Now()
	c.Next()
	since := time.Since(startTime)
	// 获取当前请求所对应的函数
	f := c.HandlerName()
	fmt.Printf("函数 %s 耗时 %d\n", f, since)
}

func m1(c *gin.Context) {
	fmt.Println("我是中间件m1的第一道关卡")
	c.Next()
	fmt.Println("我是中间件m1的第二道关卡")
}

func m2(c *gin.Context) {
	fmt.Println("我是中间件m2的第一道关卡")
	c.Next()
	fmt.Println("我是中间件m2的第二道关卡")
}

func ServiceCode(c *gin.Context) {
	fmt.Println("这是业务代码")
	c.JSON(200, gin.H{
		"msg": "执行成功",
	})
}

func main() {
	// 创建一个 Gin 引擎
	router := gin.Default()

	// 为全局路由注册中间件
	router.Use(TimeMiddleware)

	// 为某个路由注册中间件
	router.GET("/index", m1, ServiceCode)

	router.POST("/index", m2, ServiceCode)

	// 启动服务，监听 8080 端口
	router.Run(":8080")
}
```

![image-20240324233332363](https://cloud.006288.xyz/PicGo//image-20240324233332363.png)

##### 19.2.8.4 为路由组注册中间件

- 可以为路由组注册中间件，这样该中间件会应用于该路由组下的所有路由

```go
// 路由组

package userRoutes

import "github.com/gin-gonic/gin"

// 注意这个参数需要将中间件作为参数传递进去
func UserRoutes(r *gin.Engine, middlewares ...gin.HandlerFunc) {
	// 创建一个新的路由组
	userGroup := r.Group("user")

	// 将中间件注册到路由组中
	userGroup.Use(middlewares...)

	// 定义路由
	userGroup.GET("get", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"msg": "这是userRouted路由的get方法",
		})
	})

	userGroup.POST("post", func(c *gin.Context) {
		c.JSON(200, gin.H{
			"msg": "这是userRouted路由的post方法",
		})
	})
}

```

- 主函数

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"goStuday/routes/userRoutes"
	"time"
)

// 定义中间件
func TimeMiddleware(c *gin.Context) {
	startTime := time.Now()
	c.Next()
	since := time.Since(startTime)
	// 获取当前请求所对应的函数
	f := c.HandlerName()
	fmt.Printf("函数 %s 耗时 %d\n", f, since)
}

func m1(c *gin.Context) {
	fmt.Println("我是中间件m1的第一道关卡")
	c.Next()
	fmt.Println("我是中间件m1的第二道关卡")
}

func m2(c *gin.Context) {
	fmt.Println("我是中间件m2的第一道关卡")
	c.Next()
	fmt.Println("我是中间件m2的第二道关卡")
}

func ServiceCode(c *gin.Context) {
	fmt.Println("这是业务代码")
	c.JSON(200, gin.H{
		"msg": "执行成功",
	})
}

func main() {
	// 创建一个 Gin 引擎
	router := gin.Default()

	// 为全局路由注册中间件
	router.Use(TimeMiddleware)

	// 初始化路由组
	userRoutes.UserRoutes(router, m2)

	// 启动服务，监听 8080 端口
	router.Run(":8080")
}
```

#### 19.2.9 gin渲染和静态文件

##### 19.2.9.1 静态文件服务

- 静态文件服务是Gin框架提供的一个功能，它可以帮助你在Web应用程序中提供静态文件（如HTML、CSS、JavaScript、图像等）的访问服务，而无需额外配置繁琐的服务器设置

- **gin实现静态文件服务的方式**

  - **gin.Static()**
    - static从给定的文件系统根目录提供文件。内部使用了 http.FileServer，因此使用 http.NotFound 而不是路由器的 NotFound 处理程序
    - 用于提供一个目录下的所有文件，通过指定URL路径前缀和目录路径来映射所有文件
    - 第一个参数是所访问资源的URL，第二个参数是资源存放在服务器上的路径， 访问文件资源时指定的url会被映射到服务器上真正存放静态资源的路径上，下面是我项目代码中的使用实例

  ```go
  package main
  
  import (
  	"github.com/gin-gonic/gin"
  )
  
  func main() {
  	// 创建一个 Gin 引擎
  	router := gin.Default()
  
  	router.Static("/static", "./")
  
  	// 启动服务，监听 8080 端口
  	router.Run(":8888")
  }
  ```

  ![image-20240325220806342](https://cloud.006288.xyz/PicGo//image-20240325220806342.png)

  - **gin.StaticFS()**

    - StaticFS 的工作方式与 `Static()` 类似，但可以使用自定义的 `http.FileSystem` 代替。 
    - 第一个参数是请求文件资源的URL，第二个参数是文件系统，可以是`http.Dir()`和`gin.Dir()`
    - Gin 默认使用：gin.Dir(),   Dir 返回一个可供 http.FileServer() 使用的 http.FileSystem。它在 router.Static() 内部使用。如果 listDirectory == true，那么它的工作方式与 http.Dir() 相同，否则它返回一个阻止 http.FileServer() 列出目录文件的文件系统

    ```go
    package main
    
    import (
    	"github.com/gin-gonic/gin"
    )
    
    func main() {
    	// 创建一个 Gin 引擎
    	router := gin.Default()
    
    	router.StaticFS("/static", gin.Dir("/", true))
    
    	// 启动服务，监听 8080 端口
    	router.Run(":8888")
    }
    ```

    

  ![image-20240325221206353](https://cloud.006288.xyz/PicGo//image-20240325221206353.png)

  - **gin.StaticFile**
    - 用于提供单个文件的服务，通过指定URL路径和静态文件的绝对路径来提供单个文件

  ```go
  package main
  
  import (
  	"github.com/gin-gonic/gin"
  )
  
  func main() {
  	// 创建一个 Gin 引擎
  	router := gin.Default()
  
  	router.StaticFile("/static", "./static/index/index.html")
  
  	// 启动服务，监听 8080 端口
  	router.Run(":8888")
  }
  ```

  ![image-20240325221544455](https://cloud.006288.xyz/PicGo//image-20240325221544455.png)

##### 19.2.9.2 模板渲染

- Gin框架提供了灵活且强大的渲染功能，使得开发者可以轻松地生成HTML、JSON、XML等格式的响应
- [go语言模板相关知识点](https://www.cnblogs.com/sunsky303/p/11942030.html)
- **HTML模板渲染**
  - Gin框架使用Go内置的`html/template`包来渲染HTML模板。主要步骤包括:
    - **加载模板文件：** 使用`gin.Default()`或`gin.New()`创建一个Gin引擎，然后使用`LoadHTMLGlob()`或`LoadHTMLFiles()`方法加载HTML模板文件
    - **渲染模板：** 使用`HTML()`方法渲染模板，并将数据传递给模板进行动态渲染

```go
package main

import (
	"github.com/gin-gonic/gin"
)

func main() {
	// 创建一个 Gin 引擎
	router := gin.Default()

	// 加载模板
	router.LoadHTMLGlob("./template/*")

	// 渲染模板
	router.GET("/", func(c *gin.Context) {

		c.HTML(200, "index.tmpl", gin.H{
			"name": c.Query("name"),
		})
	})

	// 启动服务，监听 8080 端口
	router.Run(":8888")
}


// 模板文件

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>go_gin</title>
</head>
<body>
<h1>hello,{{.name}}</h1>
</body>
</html>
```

![image-20240325223347557](https://cloud.006288.xyz/PicGo//image-20240325223347557.png)

> 还有JSON和XML等格式,大致HTML渲染方式差不多,这里不在演示

- **自定义渲染函数**
  - 在Gin框架中，你可以通过注册自定义渲染函数来扩展模板引擎的功能。这在需要在模板中执行一些自定义的操作时非常有用，比如格式化日期、生成链接等

```GO
// 定义一个格式化日期的渲染函数

package main

import (
	"html/template"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func main() {
	r := gin.Default()

	// 注册自定义渲染函数
	r.SetFuncMap(template.FuncMap{
		"formatDate": formatDate,
	})

	// 加载HTML模板
	r.LoadHTMLGlob("templates/*")

	// 处理请求
	r.GET("/", func(c *gin.Context) {
		c.HTML(http.StatusOK, "index.tmpl", gin.H{
			"title": "Home Page",
			"date":  time.Now(),
		})
	})

	r.Run(":8888")
}

// 自定义渲染函数
func formatDate(t time.Time) string {
	return t.Format("2006-01-02 15:04:05")
}
```

- 模板

```go
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{{ .title }}</title>
</head>
<body>
    <h1>{{ .title }}</h1>
    <p>当前日期：{{ formatDate .date }}</p> <!-- 调用自定义渲染函数 -->
</body>
</html>

```

![image-20240325225300923](https://cloud.006288.xyz/PicGo//image-20240325225300923.png)

#### 19.2.10 会话控制

- 在计算机网络中，我们知道HTTP是一个无状态的协议，一次请求结束后，下次再发送服务器就不知道这个请求是谁发来的了（同一个IP不代表同一个用户），在Web应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用模式，并且各有千秋
- **Cookie-Session认证模式**
  - 在Web应用发展的初期，大部分采用基于Cookie-Session的会话管理方式
    - 客户端使用用户名、密码进行认证
    - 服务端验证用户名、密码正确后生成并存储Session，将SessionID通过Cookie返回给客户端
    - 客户端访问需要认证的接口时在Cookie中携带SessionID
    - 服务端通过SessionID查找Session并进行鉴权，返回给客户端需要的数据
  - 优缺点
    - 优点：
      - session-cookie 认证机制在基本上所有的网页浏览器上都能够支持
      - 实现方式简单
    - 缺点：
      - 服务端需要存储Session，并且由于Session需要经常快速查找，通常存储在内存或内存数据库中 ，如果在线用户的人数较多时，会占用大量的服务器资源。
      - 当需要扩展时，创建Session的服务器可能不是验证Session的服务器，所以还需要将所有Session单独存储并共享。
        由于客户端使用Cookie存储SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范CSRF攻击

![image-20240326225601394](https://cloud.006288.xyz/PicGo//image-20240326225601394.png)

- **Token认证模式**

  - 鉴于基于Session的会话管理方式存在上述的多个缺点，基于Token的无状态（服务端不存储信息）会话方式诞生了。
    所谓的Token，其实就是服务端生成的一串加密字符串、以作客户端进行请求的一个“令牌”。当用户第一次使用账号密码成功进行登录后，服务器便生成一个Token及Token失效时间并将此返回给客户端，若成功登陆，以后客户端只需在有效时间内带上这个Token前来请求数据即可，无需再次带上用户名和密码
  - 基于Token的会话管理方式有效解决了基于Session的会话管理方式带来的问题

  - 逻辑如下：
    - 客户端使用用户名、密码进行认证
    - 服务端验证用户名、密码正确后生成Token返回给客户端
    - 客户端保存Token，访问需要认证的接口是在URL参数或HTTP Header中加入Token
    - 服务端通过解码Token进行鉴权，返回给客户端需要的数据

![image-20240326225844167](https://cloud.006288.xyz/PicGo//image-20240326225844167.png)

> JWT后边到项目上在展开细讲

##### 19.2.10.1  会话控制--Cookie操作

- 在Gin框架中实现会话控制通常涉及使用Cookie以及结合第三方中间件，比如`github.com/gin-contrib/sessions`，这个中间件提供了方便的会话管理功能

- **设置Cookie和获取Cookie**

```go
package main

import (
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

func loginCode(c *gin.Context) {
	user := c.Query("user")
	// 设置cookie使用setCookie
	c.SetCookie("username", user, 100, "/", "localhost", false, true)
	str := fmt.Sprintf("%v用户登录成功", user)
	c.String(http.StatusOK, str)
}

func loginCheck(c *gin.Context) {
	user := c.Query("user")
	// 只要username的cookie不存在或者cookie用户不等于请求用户就拒绝请求
	cookie, err := c.Cookie("username")
	if err != nil || cookie != user {
		c.Abort()
		c.String(403, "你无权访问,请先登录")
	}
}

func homeCode(c *gin.Context) {
	user := c.Query("user")
	c.HTML(200, "index.tmpl", gin.H{
		"user": user,
	})
}

func deleteCode(c *gin.Context) {
	user := c.Query("user")
	// 删除cookie时,只需要将cookie的maxAge时间设置为-1即可
	c.SetCookie("username", user, -1, "/", "localhost", false, true)
	c.String(200, "已登出")
}

func main() {
	route := gin.Default()

	route.LoadHTMLGlob("./templates/*")

	route.POST("/login", loginCode)

	route.GET("/home", loginCheck, homeCode)

	route.DELETE("/logout", loginCheck, deleteCode)

	route.Run(":8888")
}
```

![image-20240327000735042](https://cloud.006288.xyz/PicGo//image-20240327000735042.png)

![image-20240327002359222](https://cloud.006288.xyz/PicGo//image-20240327002359222.png)

##### 19.2.10.2  会话控制--Session操作

- Cookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session

- Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在服务端为每个用户保存一个Session数据，该Session数据中能够保存具体的用户数据信息
- session 是另一种记录客户状态的机制， **不同的是 Cookie 保存在客户端浏览器中，而 session保存** **在服务器上**
- session和cookie是不分家的。我们每次说到session，其实默认就是要使用cookie了
- Session 的工作流程
  - 当客户端浏览器第一次访问服务器并发送请求时，服务器端会创建一个 session 对象，生成一个类似于 key,value 的键值对， 然后将 value 保存到服务器，将 key(cookie)返回到浏览器(客户)端 ；
  - 浏览器下次访问时会携带 key(cookie)，找到对应的 session(value)

> 第一次登录，服务器给客户端颁发一个唯一的sessionId, 并通过http的响应头返回。客户端（浏览器）发现返回的数据中有cookie数据就把这个cookie数据存放到内存。下次再发送http请求时，把内存中的cookie数据再塞到http请求头中，一并发给服务器，服务器在解析请求时，发现请求头中有cookie，就开始识别cookie中的sessionId，拿到sessionId，我们就知道这个请求时由哪个客户端发送来的了。

- Gin 官方没有给我们提供 Session 相关的文档，这个时候我们可以使用第三方的 Session 中间件来实现
  - [gin-contrib/sessions](https://github.com/gin-contrib/sessions)
  - gin-contrib/sessions 中间件支持的存储引擎:
    - [cookie-based](https://github.com/gin-contrib/sessions#cookie-based)
    - [Redis](https://github.com/gin-contrib/sessions#redis)
    - [memcached](https://github.com/gin-contrib/sessions#memcached)
    - [MongoDB](https://github.com/gin-contrib/sessions#mongodb)
    - [GORM](https://github.com/gin-contrib/sessions#gorm)
    - [memstore](https://github.com/gin-contrib/sessions#memstore)
    - [PostgreSQL](https://github.com/gin-contrib/sessions#postgresql)
- session 在创建时有一个配置项，可以配置session过期时间、cookie、domain、secure、path等参数
- 调用 session 方法： Set()、 Delete()、 Clear()、方法后，必须调用一次 Save() 方法。否则session数据不会更新

```go
// 下载Session包
go get github.com/gin-contrib/sessions

// 导入session包
import "github.com/gin-contrib/sessions"
```

- 示例

  - 主函数

  ```go
  package main
  
  import (
  	"encoding/gob"
  	"github.com/gin-contrib/sessions"
  	"github.com/gin-contrib/sessions/cookie"
  	"github.com/gin-gonic/gin"
  	UserAction2 "goStuday/controllers/UserAction"
  	"goStuday/routes/UserAction"
  )
  
  func main() {
  	// 注册 User 类型，以便 gob 可以对其进行编码和解码
  	gob.Register(UserAction2.User{})
  
  	engine := gin.Default()
  
  	// 基于cookie创建session存储引擎
  	store := cookie.NewStore([]byte("golang_session"))
  	engine.Use(sessions.Sessions("mysession", store))
  
  	UserAction.UserAction(engine)
  
  	engine.Run(":8888")
  }
  ```

  - 路由管理

  ```go
  package UserAction
  
  import (
  	"github.com/gin-gonic/gin"
  	UserAction2 "goStuday/controllers/UserAction"
  )
  
  func UserAction(r *gin.Engine) {
  	userAction := r.Group("user")
  	{
  		userAction.POST("/login", func(c *gin.Context) {
  			UserAction2.Login(c)
  		})
  
  		userAction.GET("/home", func(c *gin.Context) {
  			UserAction2.GetHome(c)
  		})
  
  		userAction.DELETE("/logout", func(c *gin.Context) {
  			UserAction2.Logout(c)
  		})
  	}
  }
  ```

  - 控制器管理

  ```go
  // 定义公共的用户信息
  package UserAction
  
  type User struct {
  	ID   int    `json:"id" form:"id"`
  	Name string `json:"name" form:"name"`
  	Pwd  string `json:"pwd" form:"pwd"`
  }
  
  // 模拟数据库
  var UserDB = map[int]User{
  	1001: {1001, "kubei", "zxcvbnm123"},
  	1002: {1002, "Tom", "qwertyuiop123"},
  	1003: {1003, "niujinjian", "chekongci@123"},
  }
  ```

  ```go
  // 用户登录控制器
  
  package UserAction
  
  import (
  	"github.com/gin-contrib/sessions"
  	"github.com/gin-gonic/gin"
  	"net/http"
  )
  
  func Login(c *gin.Context) {
  	var user User
  	if err := c.ShouldBind(&user); err != nil {
  		c.String(400, "提交的参数有误,请检查重新提交!")
  		return
  	}
  
  	// 后端代码调用数据进行用户查询
  	userinfo, ok := UserDB[user.ID]
  	if !ok || userinfo.Pwd != user.Pwd {
  		c.String(http.StatusUnauthorized, "用户不存在或密码不正确")
  		return
  	}
  	// 设置session
  	session := sessions.Default(c)
  	//session 库在存储结构化数据时只会存储用户提供的值的特定部分, 会话存储库通常只存储值的序列化版本，而不会保留其完整的结构
  	// 如果我们要将整个用户对象信息都保存,就需要使用gob注册结构体，gob是golang自带得序列化编解码工具，在对自定义struct编解码时要调用gob.Register进行注册
  	session.Set("username", user)
  	session.Save()
  	c.String(http.StatusOK, user.Name+" :login successful")
  }
  ```

  ```go
  // 用户访问家目录
  package UserAction
  
  import (
  	"github.com/gin-contrib/sessions"
  	"github.com/gin-gonic/gin"
  	"net/http"
  )
  
  func GetHome(c *gin.Context) {
  	session := sessions.Default(c)
  	username, ok := session.Get("username").(User)
  	if !ok {
  		c.String(500, "发生未知错误,请重试")
  		return
  	}
  	c.JSON(http.StatusOK, gin.H{
  		"msg": "用户信息如下",
  		"姓名":  username.Name,
  		"ID":  username.ID,
  		"密码":  username.Pwd,
  	})
  }
  ```

  ```go
  // 用户登出控制器
  
  package UserAction
  
  import (
  	"github.com/gin-contrib/sessions"
  	"github.com/gin-gonic/gin"
  	"net/http"
  )
  
  func Logout(c *gin.Context) {
  	session := sessions.Default(c)
  	session.Clear()
  	session.Save()
  	c.String(http.StatusOK, "Logged out successfully")
  }
  ```

  ![image-20240327230301139](https://cloud.006288.xyz/PicGo//image-20240327230301139.png)

> 目前用cookie-session来做登录鉴权比较过时,主流的是使用JWT来做登录鉴权

##### 19.2.10.3 会话控制--JWT

- [JWT参考文档](https://blog.csdn.net/weixin_45070175/article/details/118559272?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171155098716800182181841%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171155098716800182181841&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-118559272-null-null.142^v100^pc_search_result_base1&utm_term=JWT&spm=1018.2226.3001.4187)
- session 认证的缺点很明显，由于 session 是保存在服务器里，所以如果分布式部署应用的话，会出现session不能共享的问题，很难扩展。于是乎为了解决 session 共享的问题，又引入了 redis, 将session存储在redis中, 后端收到后查询redis中是否存在, 但这种方式会增加服务器端状态管理的开销等,因此引入了 Token 认证方式来解决这些问题
- Token认证跟 session 的方式流程差不多，不同的地方在于保存的是一个 token 值到 redis，token 一般是一串随机的字符(比如UUID)，value 一般是用户ID，并且设置一个过期时间。每次请求服务的时候带上 token 在请求头，后端接收到token 则根据 token 查一下 redis 是否存在，如果存在则表示用户已认证，如果 token 不存在则跳到登录界面让用户重新登录，登录成功后返回一个 token 值给客户端, 但Token认证每次请求都需要查一下redis，会造成 redis 的压力，还有增加了请求的耗时，每个已登录的用户都要保存一个 token 在 redis，也会消耗 redis 的存储空间, 为了解决这个问题引入了JWT认证

> - 基于token的认证方式相比传统的session认证方式更节约服务器资源，并且对移动端和分布式更加友好。其优点如下：
>   - 支持跨域访问：cookie是无法跨域的，而token由于没有用到cookie(前提是将token放到请求头中)，所以跨域后不会存在信息丢失问题
>   - 无状态：token机制在服务端不需要存储session信息，因为token自身包含了所有登录用户的信息，所以可以减轻服务端压力
>   - 更适用CDN：可以通过内容分发网络请求服务端的所有资料
>   - 更适用于移动端：当客户端是非浏览器平台时，cookie是不被支持的，此时采用token认证方式会简单很多
>   - 无需考虑CSRF：由于不再依赖cookie，所以采用token认证方式不会发生CSRF，所以也就无需考虑CSRF的防御

###### 19.2.10.3.1 什么是JWT

- [JWT](https://jwt.io/) (全称：Json Web Token)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为 JSON 对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的
- JWT 是 Token 的一种特定实现，它采用了 JSON 格式来组织数据，并使用数字签名或加密来保证数据的完整性和安全性。JWT 将用户信息和额外的元数据（如过期时间、发行人等）编码到一个字符串中，使得可以在不同系统之间轻松传递和验证
- **JWT流程描述：**
  1. 用户使用账号、密码登录应用，登录的请求发送到 Authentication Server。
  2. Authentication Server 进行用户验证，然后创建 JWT 字符串返回给客户端。
  3. 客户端请求接口时，在请求头带上 JWT。
  4. Application Server 验证 JWT 合法性，如果合法则继续调用应用接口返回结果



- JWT的结构

  - JWT 一般是这样一个字符串，分为三个部分，以 “.” 隔开    `xxxxx.yyyyy.zzzzz`
  - WT的3部分分别为：
    - 标头(Header)
    - 有效载荷(Payload)
    - 签名(Signature)

  - 在传输的时候，会将JWT的3部分分别进行Base64编码后用`.`进行连接形成最终传输的字符串

```go
JWTString=Base64(Header).Base64(Payload).HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)
```

- **标头(Header)**

  标头*通常*由两部分组成：令牌的类型（JWT）和所使用的签名算法（例如 HMAC SHA256 或 RSA）

  然后，对该 JSON 进行**Base64Url**编码以形成 JWT 的第一部分

```go
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- **有效载荷(Payload)**

  令牌的第二部分是有效负载(Payload)，是JWT的主体内容部分，也是一个JSON对象, 除了包含需要传递的数据，还有七个默认的字段供选择

```go
iss：发行人
exp：到期时间
sub：主题
aud：用户
nbf：在此之前不可用
iat：发布时间
jti：JWT ID用于标识该JWT
```

> 默认情况下JWT是未加密的，因为只是采用base64算法，拿到JWT字符串后可以转换回原本的JSON数据，任何人都可以解读其内容，因此不要构建隐私信息字段，比如用户的密码一定不能保存到JWT中，以防止信息泄露。JWT只是适合在网络中传输一些非敏感的信息

- **签名(Signature)**
  - 签名哈希部分是对上面两部分数据签名，需要使用base64编码后的header和payload数据，通过指定的算法生成哈希，以确保数据不会被篡改。首先，需要指定一个密钥（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用header中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名
  - 在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用`.`分隔，就构成整个JWT对象

```go
HMACSHA256(base64UrlEncode(header)+"."+base64UrlEncode(payload),secret)
```

![image-20240328223212409](https://cloud.006288.xyz/PicGo//image-20240328223212409.png)

- **JWT每部分的作用**
  - 在服务端接收到客户端发送过来的JWT token之后：
    - header和payload可以直接利用base64解码出原文，从header中获取哈希签名的算法，从payload中获取有效数据
    - signature由于使用了不可逆的加密算法，无法解码出原文，它的作用是**校验**token有没有被篡改。服务端获取header中的加密算法之后，利用该算法加上secretKey对header、payload进行加密，比对加密后的数据和客户端发送过来的是否一致。注意secretKey只能保存在服务端，而且对于不同的加密算法其含义有所不同，一般对于MD5类型的摘要加密算法，secretKey实际上代表的是盐值

###### 19.2.10.3.2 go语言使用JWT

- go语言使用jwt需要导入一个三方库[jwt-go](https://github.com/golang-jwt/jwt)

```go
go get -u github.com/golang-jwt/jwt/v5

import "github.com/golang-jwt/jwt/v5"
```

- jwt基本使用

```go
package main

import (
	"fmt"
	"github.com/golang-jwt/jwt/v5"
	"time"
)

type MyClaims struct {
	Name string `json:"name" form:"name"`
	jwt.RegisteredClaims
}

func CreatToken(mySigningKey []byte) (string, error) {
	claims := MyClaims{
		"kubei",
		jwt.RegisteredClaims{
			// 过期时间
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(5 * time.Minute)),
			// 开始时间
			IssuedAt: jwt.NewNumericDate(time.Now()),
			// 在此之前不能用
			NotBefore: jwt.NewNumericDate(time.Now()),
			// 发布者
			Issuer: "test",
			// 主题
			Subject: "somebody",
			// jwt ID
			ID: "1",
		},
	}

	headerPayload := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	token, err := headerPayload.SignedString(mySigningKey)
	return token, err
}

func ParsingToken(token string, mySigningKey []byte) (*MyClaims, error) {
	claims := &MyClaims{}
	tokenStr, err := jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) {
		return mySigningKey, nil
	})
	return tokenStr.Claims.(*MyClaims), err

}

func main() {
	// 一定要使用切片否则会报错
	mySigningKey := []byte("golang_jwt")

	// 创建token
	token, err := CreatToken(mySigningKey)
	fmt.Println("生成的token是: ", token)
	fmt.Println(err)

	// 解析token
	claims, err := ParsingToken(token, mySigningKey)
	fmt.Println("解析后的数据: ", claims)
	fmt.Printf("发行人:%v\n到期时间:%v\n主题:%v\n在此之前不可用:%v\n生效时间:%v\nJWT ID:%v\n", claims.Issuer,
		claims.ExpiresAt, claims.Subject, claims.NotBefore, claims.IssuedAt, claims.ID)
	fmt.Println(err)
}
```

![image-20240328232227578](https://cloud.006288.xyz/PicGo//image-20240328232227578.png)

> JWT 在gin框架中的使用,我们此处暂时不做展开,放到后面项目上

### 19.3 beego框架

- [beego官网](https://beego.me/)
- beego框架不作为我们的主流框架,该篇只做入门讲解,需要详细了解请查看下方文档
  - [beego官方文档](https://github.com/beego/beedoc/blob/master/zh-CN/)
  - [beego学习文档1](https://www.cnblogs.com/Gaimo/p/17089837.html)
  - [beego学习文档2](https://blog.csdn.net/cold___play/article/details/131125246?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171198627016800215033947%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171198627016800215033947&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-7-131125246-null-null.142^v100^pc_search_result_base1&utm_term=beego&spm=1018.2226.3001.4187)

#### 19.3.1 beego框架概述

##### 19.3.1.1 beego简介

- [beego](https://github.com/beego/beego)是一个快速开发Go应用的http框架。beego可以用来快速开发API、Web、后端服务等各种应用，是一个RESTFul的框架，主要设计灵感来源于tornado、sinatra、flask这三个框架，但是结合了Go本身的一些特性(interface、struct继承等)而设计的一个框架。
- Beego是基于八大独立的模块构建的，是一个高度解耦的框架。最初在设计Beego时就考虑到了功能模块化，用户即使不适用Beego的HTTP逻辑，也可以独立使用这些模块（例如可以使用cache模块来处理缓存逻辑，使用日志模块来记录操作信息，使用config模块来解析各种格式的文件); 这些模块分别是cache、config、context、httplibs、logs、orm、session和toolbox

![image-20240402000734767](https://cloud.006288.xyz/PicGo//image-20240402000734767.png)

##### 19.3.1.2 beego执行逻辑

- Beego的执行逻辑基于八大独立模块构建，遵循典型的MVC架构，通过启动监听、路由和参数过滤、控制器处理、模型操作、返回响应等步骤完成请求处理。同时提供上下文封装、独立模块支持和项目结构规范等功能，使得代码组织清晰、易于维护和扩展。通过配置解析、启动钩子和模板编译等机制，实现了灵活的配置和高效的运行效率
- 它的执行逻辑如下图所示

![image-20240402000342076](https://cloud.006288.xyz/PicGo//image-20240402000342076.png)

##### 19.3.1.3 bee工具基本使用

- **什么是bee**

  - bee 工具是一个为了协助快速开发 beego 项目而创建的项目，通过 bee 您可以很容易的进行 beego 项目的创建、热编译、开发、测试、和部署

- **bee工具安装**

  ```go
  //  go 1.16 以前的版本
  go get -u github.com/beego/bee/v2
  
  // go 1.16及以后的版本
  go install github.com/beego/bee/v2@latest
  ```

  > 安装完之后，`bee` 可执行文件默认存放在 `$GOPATH/bin` 里面，所以您需要把 `$GOPATH/bin` 添加到您的环境变量中，才可以进行下一步

- **bee工具命令详解**

  - `new` 命令

    - `new` 命令是新建一个 Web 项目，我们在命令行下执行 `bee new <项目名>` 就可以创建一个新的项目。但是注意该命令必须在 `$GOPATH/src` 下执行。最后会在 `$GOPATH/src` 相应目录下生成如下目录结构的项目：

    ```go
    // 使用bee初始化一个beego工程
    bee new "工程名"
    
    // 初始化后的工程目录详情
    
    "工程名"
    ├── conf			#配置文件目录
    │   └── app.conf    #配置文件
    ├── controllers		#控制器目录
    │   └── default.go	#默认控制器文件
    ├── main.go			#入口
    ├── models			#模型目录
    ├── routers			#路由目录
    │   └── router.go	#路由文件
    ├── static			#静态文件目录
    │   ├── css			# css文件目录
    │   ├── img			#图片文件目录
    │   └── js			#js文件目录
    ├── tests			#测试文件目录
    │   └── default_test.go	#默认测试文件
    └── views			#视图目录
        └── index.tpl	#默认视图文件
    ```

  - `pi` 命令
    - 上面的 `new` 命令是用来新建 Web 项目，不过很多用户使用 beego 来开发 API 应用

  ```go
  // 使用bee初始化
  bee new "工程名"
  
  // 初始化后的工程目录详情
  
  "工程名"
  ├── conf
  │   └── app.conf
  ├── controllers
  │   └── object.go
  │   └── user.go
  ├── docs
  │   └── doc.go
  ├── main.go
  ├── models
  │   └── object.go
  │   └── user.go
  ├── routers
  │   └── router.go
  └── tests
      └── default_test.go
  ```

  > - 从上面的目录我们可以看到和 Web 项目相比，少了 static 和 views 目录，多了一个 test 模块，用来做单元测试的。
  >
  > - 同时，该命令还支持一些自定义参数自动连接数据库创建相关 model 和 controller:
  >   `bee api [appname] [-tables=""] [-driver=mysql] [-conn="root:<password>@tcp(127.0.0.1:3306)/test"]`
  >   如果 conn 参数为空则创建一个示例项目，否则将基于链接信息链接数据库创建项目

  - `run` 命令

    - 我们在开发 Go 项目的时候最大的问题是经常需要自己手动去编译再运行, 但是bee run 提供了自动重载功能，可以在代码发生变化时重新编译并启动应用程序，无需手动停止和重新运行

    - 用于运行 BeeGo 应用程序, 它会在默认端口上运行该应用程序。在启动后，你可以通过浏览器或其他 HTTP 客户端访问该应用程序，以查看其功能

    > "bee run" 和 "go run main.go" 是两种不同的方式来运行 Go 语言项目:
    >
    > - 无论是使用 "bee run" 还是 "go run main.go"，都可以启动你的 Go 语言项目，并在本地环境中运行它。
    > -  两种方式都相对简单直接，特别是在开发阶段，用于快速验证代码的正确性和功能
    > - **bee run**：
    >   - **自动重载（Hot Reload）**：Bee 是一个基于 Beego 框架的实时开发工具，它提供了自动重载功能，可以在代码发生变化时重新编译并启动应用程序，无需手动停止和重新运行。
    >   - **额外功能**：Bee 提供了一些额外的功能，例如代码生成、数据库迁移等，使得开发更加便捷。
    >   - **监控文件变化**：Bee 会监视代码文件的变化，一旦发现有文件发生改动，就会触发重新编译和运行应用程序。
    > - **go run main.go**：
    >   - **手动编译运行**：使用 "go run" 命令需要手动编译和运行应用程序。每次修改代码后，你需要手动停止程序，然后再次运行 "go run main.go"。
    >   - **不支持自动重载**："go run" 命令本身不提供自动重载功能，每次修改代码后都需要手动重新编译和运行应用程序。
    >   - **更接近标准方式**："go run" 是 Go 语言标准工具链中的一部分，它提供了一个简单的方式来运行 Go 程序，更适用于简单的项目或者快速验证代码的功能

  - `pack` 命令

    - `pack` 目录用来发布应用的时候打包，会把项目打包成 zip 包，这样我们部署的时候直接把打包之后的项目上传，解压就可以部署了

  - `generate` 命令
    - 这个命令是用来自动化的生成代码的，例如控制器（controller）、模型（model）、视图（view）等。这个命令能够快速地创建新的代码文件，帮助开发者加速开发过程。

  ```go
  // 生成控制器
  bee generate controller <ControllerName>
  // 这会生成一个新的控制器文件，文件名为 <ControllerName>_controller.go，位于 controllers 目录下
  
  
  // 生成模型：
  bee generate model <ModelName>
  // 这会生成一个新的模型文件，文件名为 <ModelName>.go，位于 models 目录下。
  
  // 生成 CRUD（增删改查）控制器和模板：
  bee generate scaffold <ModelName>
  // 这会生成一个包含 CRUD 操作的控制器和相关的视图模板文件。
  
  // 生成 API 控制器：
  bee generate api <ControllerName>
  // 这会生成一个基于 RESTful API 的控制器，通常用于处理 API 请求
  ```

  > 请注意，生成的文件是基于 BeeGo 的默认模板生成的，你可能需要根据自己的需求对生成的代码进行调整和扩展

  - `migrate` 命令
    - 通常用于执行数据库迁移操作，它是 BeeGo 框架中的一个子命令，用于管理数据库的结构变化，主要是用来每次应用升级，降级的SQL管理
    - 数据库迁移是指对数据库模式进行变更的过程，例如创建新的表、修改表结构、添加索引等。通常情况下，当你的应用程序需要更新数据库结构时，你可以使用迁移来管理这些变更，而不是手动执行 SQL 脚本或者直接操作数据库

  - `dockerize` 命令
    - 通常用于将 BeeGo 项目 Docker 化，即创建一个 Docker 镜像，使得你的 BeeGo 应用程序可以在 Docker 容器中运行。这个命令的作用是根据 BeeGo 项目的配置和文件结构，生成一个 Dockerfile，然后使用 Docker 命令构建镜像

#### 19.3.2 beego框架快速入门

##### 19.3.2.1 新建项目

- 使用bee创建一个beego项目

```go
bee new beegoStuday
```

![image-20240402004204744](https://cloud.006288.xyz/PicGo//image-20240402004204744.png)

- 运行项目
  - beego 项目创建之后，我们还需要初始化`go.mod`文件。进入目录之后，使用`go mod tidy`加载模块依赖

```go
// 启动项目
bee run

// 输出
PS E:\GoCode\beegoStuday> bee run
______
| ___ \
| |_/ /  ___   ___
| ___ \ / _ \ / _ \
| |_/ /|  __/|  __/
\____/  \___| \___| v2.1.0
```

- 访问项目

![image-20240402004625666](https://cloud.006288.xyz/PicGo//image-20240402004625666.png)

##### 19.3.2.2 路由设置

- 前面我们已经通过bee创建并运行了beego项目,那么项目是如何运行起来的呢? 让我们逐一分析

-  Go 的执行过程是如下图所示的方式:

  - main函数是go语言的入口函数,执行main函数时他会将程序所需的包导入进来;
  - 我们导入的包可能也依赖其他包,所以他会按照包依赖从里往外导入和执行

  ![image-20240405142130313](https://cloud.006288.xyz/PicGo//image-20240405142130313.png)

- 接下来我们来看一下beego的main函数文件,可以看到main函数文件依赖两个包`beegoStuday/routers`和`github.com/beego/beego/v2/server/web`包, 其中` beegoStuday/routers`中前面有一个`-`说明我们不需要使用这个包里面的任何方法,只执行这个包里面的int函数, 那么让我们看看这个里面做了什么事情

```go
package main

import (
	_ "beegoStuday/routers"
	beego "github.com/beego/beego/v2/server/web"
)

func main() {
	beego.Run()
}
```

- 路由包里面我们看到执行了路由注册 `beego.Router`, 这个函数的功能是映射 URL 到 controller，第一个参数是 URL (用户请求的地址)，这里我们注册的是 `/`，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑，我们可以执行类似的方式注册路由

```go
package routers

import (
	"beegoStuday/controllers"
	beego "github.com/beego/beego/v2/server/web"
)

func init() {
    beego.Router("/", &controllers.MainController{})
}
```

- 再回来看看 main 函数里面的 `beego.Run`， `beego.Run` 执行之后，我们看到的效果好像只是监听服务端口这个过程，但是它内部做了很多事情：

  - **解析配置文件**

    beego 会自动解析在 conf 目录下面的配置文件 `app.conf`，通过修改配置文件相关的属性，我们可以定义：开启的端口，是否开启 session，应用名称等信息。

  - **执行用户的 hookfunc**

    beego 会执行用户注册的 hookfunc，默认的已经存在了注册 mime，用户可以通过函数 `AddAPPStartHook` 注册自己的启动函数。

  - **是否开启 session**

    会根据上面配置文件的分析之后判断是否开启 session，如果开启的话就初始化全局的 session。

  - **是否编译模板**

    beego 会在启动的时候根据配置把 views 目录下的所有模板进行预编译，然后存在 map 里面，这样可以有效的提高模板运行的效率，无需进行多次编译。

  - **是否开启文档功能**

    根据 EnableDocs 配置判断是否开启内置的文档路由功能

  - **是否启动管理模块**

    beego 目前做了一个很酷的模块，应用内[监控模块](https://git-books.github.io/books/beego/advantage/monitor.md)，会在 8088 端口做一个内部监听，我们可以通过这个端口查询到 QPS、CPU、内存、GC、goroutine、thread 等统计信息。

  - **监听服务端口**

    这是最后一步也就是我们看到的访问 8080 看到的网页端口，内部其实调用了 `ListenAndServe`，充分利用了 goroutine 的优势,   一旦 run 起来之后，我们的服务就监听在两个端口了，一个服务端口 8080 作为对外服务，另一个 8088 端口实行对内监控

- 通过这个代码的分析我们了解了 beego 运行起来的过程，以及内部的一些机制。接下来让我们去剥离 Controller 如何来处理逻辑的

##### 19.3.2.3 控制器管理

- 前面我们了解了如何把用户的请求分发到控制器，这小节我们就介绍大家如何来写控制器

```GO
package controllers

import (
	beego "github.com/beego/beego/v2/server/web"
)

type MainController struct {
	beego.Controller
}

func (c *MainController) Get() {
	c.Data["Website"] = "beego.vip"
	c.Data["Email"] = "astaxie@gmail.com"
	c.TplName = "index.tpl"
}
```

- 上面的代码显示首先我们声明了一个控制器 `MainController`，这个控制器里面组合了 `beego.Controller`，这就是 Go 的组合方式，也就是 `MainController` 自动拥有了所有 `beego.Controller` 的方法。
- 而 `beego.Controller` 拥有很多方法，其中包括 `Init`、`Prepare`、`Post`、`Get`、`Delete`、`Head` 等方法。我们可以通过重写的方式来实现这些方法，而我们上面的代码就是重写了 `Get` 方法
- 我们先前介绍过 beego 是一个 RESTful 的框架，所以我们的请求默认是执行对应 `req.Method` 的方法。例如浏览器的是 `GET` 请求，那么默认就会执行 `MainController` 下的 `Get` 方法。这样我们上面的 Get 方法就会被执行到，这样就进入了我们的逻辑处理。（用户可以改变这个行为，通过注册自定义的函数名）
- 里面的代码是需要执行的逻辑，这里只是简单的输出数据，我们可以通过各种方式获取数据，然后赋值到 `c.Data` 中，这是一个用来存储输出数据的 map，可以赋值任意类型的值，这里我们只是简单举例输出两个字符串。
- 最后一个就是需要去渲染的模板，`c.TplName` 就是需要渲染的模板，这里指定了 `index.tpl`，如果用户不设置该参数，那么默认会去到模板目录的 `Controller/<方法名>.tpl` 查找，例如上面的方法会去 `maincontroller/get.tpl` ***(文件、文件夹必须小写)***。
- 用户设置了模板之后系统会自动的调用 `Render` 函数（这个函数是在 `beego.Controller` 中实现的），所以无需用户自己来调用渲染
- 当然也可以不使用模版，直接用 `c.Ctx.WriteString` 输出字符串

```go
c.Ctx.WriteString("hello beego")
```

##### 19.3.2.4 model管理

- 我们知道 Web 应用中我们用的最多的就是数据库操作，而 model 层一般用来做这些操作，我们的 `bee new` 例子不存在 Model 的演示，但是 `bee api` 应用中存在 model 的应用。
- 说的简单一点，如果您的应用足够简单，那么 Controller 可以处理一切的逻辑，如果您的逻辑里面存在着可以复用的东西，那么就抽取出来变成一个模块。
- 所以如果您的应用足够简单，那么就不需要 Model 了；如果你的模块开始多了，需要复用，需要逻辑分离了，那么 Model 是必不可少的。
- 因此 Model 就是逐步抽象的过程，一般我们会在 Model 里面处理一些数据读取，如下是一个日志分析应用中的代码片段：

```go
package models

import (
	"path/filepath"
	"strings"
)

var (
	NotPV []string = []string{"css", "js", "class", "gif", "jpg", "jpeg", "png", "bmp", "ico", "rss", "xml", "swf"}
)

const big = 0xFFFFFF

func LogPV(urls string) bool {
	ext := filepath.Ext(urls)
	if ext == "" {
		return true
	}
	for _, v := range NotPV {
		if v == strings.ToLower(ext) {
			return false
		}
	}
	return true
}
```

##### 19.3.2.5 视图渲染

- 在前面编写 Controller 的时候，我们在 Get 里面写过这样的语句 `c.TplName = "c.tpl"`，设置显示的模板文件，默认支持 `tpl` 和 `html` 的后缀名，如果想设置其他后缀你可以调用 `beego.AddTemplateExt` 接口设置，那么模板如何来显示相应的数据呢？beego 采用了 Go 语言默认的模板引擎，所以和 Go 的模板语法一样
- [go语言模板相关知识点](https://www.cnblogs.com/sunsky303/p/11942030.html)
- [go语言模板学习文档](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/07.4.md)

##### 19.3.2.6 静态服务

- 前面我们介绍了如何输出静态页面，但是我们的网页往往包含了很多的静态文件，包括图片、JS、CSS 等，刚才创建的应用里面就创建了如下目录：

```go
├── static
	│   ├── css
	│   ├── img
	│   └── js
```

- beego 默认注册了 static 目录为静态处理的目录，注册样式：URL 前缀和映射的目录（在`/main.go`文件中`beego.Run()`之前加入）

```go
StaticDir["/static"] = "static"
```

- 用户可以设置多个静态文件处理目录，例如你有多个文件下载目录 download1、download2，你可以这样映射（在 `/main.go` 文件中 `beego.Run()` 之前加入）：

```go
web.SetStaticPath("/down1", "download1")
web.SetStaticPath("/down2", "download2")
```

- 这样用户访问 URL `http://localhost:8080/down1/123.txt` 则会请求 download1 目录下的 123.txt 文件

#### 19.3.3 beego框架进阶

##### 19.3.3.1 beego框架MVC架构概述

- beego 是一个典型的 MVC 框架，它的整个执行逻辑如下图所示：

![img](https://cloud.006288.xyz/PicGo//detail.png)

- 通过文字来描述如下：
  1. 在监听的端口接收数据，默认监听在 8080 端口。
  2. 用户请求到达 8080 端口之后进入 beego 的处理逻辑。
  3. 初始化 Context 对象，根据请求判断是否为 WebSocket 请求，如果是的话设置 Input，同时判断请求的方法是否在标准请求方法中（GET、POST、PUT、DELETE、PATCH、OPTIONS、HEAD），防止用户的恶意伪造请求攻击造成不必要的影响。
  4. 执行 BeforeRouter 过滤器，当然在 beego 里面有开关设置。如果用户设置了过滤器，那么该开关打开，这样可以提高在没有开启过滤器的情况下提高执行效率。如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。
  5. 开始执行静态文件的处理，查看用户的请求 URL 是否和注册在静态文件处理 StaticDir 中的 prefix 是否匹配。如果匹配的话，采用 `http` 包中默认的 ServeFile 来处理静态文件。
  6. 如果不是静态文件开始初始化 session 模块(如果开启 session 的话)，这个里面大家需要注意，如果你的 BeforeRouter 过滤器用到了 session 就会报错，你应该把它加入到 AfterStatic 过滤器中。
  7. 开始执行 AfterStatic 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。
  8. 执行过过滤器之后，开始从固定的路由规则中查找和请求 URL 相匹配的对象。这个匹配是全匹配规则，即如果用户请求的 URL 是 `/hello/world`，那么固定规则中 `/hello` 是不会匹配的，只有完全匹配才算匹配。如果匹配的话就进入逻辑执行，如果不匹配进入下一环节的正则匹配。
  9. 正则匹配是进行正则的全匹配，这个正则是按照用户添加 beego 路由顺序来进行匹配的，也就是说，如果你在添加路由的时候你的顺序影响你的匹配。和固定匹配一样，如果匹配的话就进行逻辑执行，如果不匹配进入 Auto 匹配。
  10. 如果用户注册了 AutoRouter，那么会通过 `controller/method` 这样的方式去查找对应的 Controller 和他内置的方法，如果找到就开始执行逻辑，如果找不到就跳转到监控判断。
  11. 如果找到 Controller 的话，那么就开始执行逻辑，首先执行 BeforeExec 过滤器，如果在执行过滤器过程中，responseWriter 已经有数据输出了，那么就提前结束该请求，直接跳转到监控判断。
  12. Controller 开始执行 Init 函数，初始化基本的一些信息，这个函数一般都是 beego.Controller 的初始化，不建议用户继承的时候修改该函数。
  13. 是否开启了 XSRF，开启的话就调用 Controller 的 XsrfToken，然后如果是 POST 请求就调用 CheckXsrfCookie 方法。
  14. 继续执行 Controller 的 Prepare 函数，这个函数一般是预留给用户的，用来做 Controller 里面的一些参数初始化之类的工作。如果在初始化中 responseWriter 有输出，那么就直接进入 Finish 函数逻辑。
  15. 如果没有输出的话，那么根据用户注册的方法执行相应的逻辑，如果用户没有注册，那么就调用 http.Method 对应的方法（Get/Post 等）。执行相应的逻辑，例如数据读取，数据赋值，模板显示之类的，或者直接输出 JSON 或者 XML。
  16. 如果 responseWriter 没有输出，那么就调用 Render 函数进行模板输出。
  17. 执行 Controller 的 Finish 函数，这个函数是预留给用户用来重写的，用于释放一些资源。释放在 Init 中初始化的信息数据。
  18. 执行 AfterExec 过滤器，如果有输出的话就跳转到监控判断逻辑。
  19. 执行 Controller 的 Destructor，用于释放 Init 中初始化的一些数据。
  20. 如果这一路执行下来都没有找到路由，那么会调用 404 显示找不到该页面。
  21. 最后所有的逻辑都汇聚到了监控判断，如果用户开启了监控模块（默认是开启一个 8088 端口用于进程内监控），这样就会把访问的请求链接扔给监控程序去记录当前访问的 QPS，对应的链接访问的执行时间，请求链接等

##### 19.3.3.2 配置管理

- beego 目前支持 INI、XML、JSON、YAML 格式的配置文件解析，但是默认采用了 INI 格式解析，用户可以通过简单的配置就可以获得很大的灵活性

###### 19.3.3.2.1 默认配置解析

  - beego 默认会解析当前应用下的 `conf/app.conf` 文件, 通过这个文件你可以初始化很多 beego 的默认参数(不区分大小写), 它们都维护在结构体 `beego/server/web#Config`,  这些参数会替换 beego 默认的一些参数 [beego中默认参数](https://github.com/beego/beego/blob/master/server/web/config.go#L523)

- beego中默认参数主要分为五大类:

  - **基础配置**
    - Config(Config是BConfig的主要结构)
      - 保存了所有 beego 里面的系统默认参数，你可以通过 `beego.BConfig.`参数` 来访问和修改底下的所有配置信息
      - 配置文件路径，默认是应用程序对应的目录下的 `conf/app.conf`，用户可以在程序代码中加载自己的配置文件
        `beego.LoadAppConfig("ini", "conf/app2.conf")`
      - 也可以加载多个文件，只要你调用多次就可以了，如果后面的文件和前面的 key 冲突，那么以最新加载的为最新值

  ```go
  // AppName  
  应用名称，默认是 beego。通过 bee new 创建的是创建的项目名。
  beego.BConfig.AppName = "beego"
  
  // RunMode  
  应用的运行模式，可选值为 prod, dev 或者 test. 默认是 dev, 为开发模式，在开发模式下出错会提示友好的出错页面，如前面错误描述中所述。
  beego.BConfig.RunMode = "dev"
  
  // RouterCaseSensitive  
  是否路由忽略大小写匹配，默认是 true，区分大小写
  beego.BConfig.RouterCaseSensitive = true
  
  // ServerName  beego 
  服务器默认在请求的时候输出 server 为 beego。
  beego.BConfig.ServerName = "beego"
  
  // RecoverPanic  
  是否异常恢复，默认值为 true，即当应用出现异常的情况，通过 recover 恢复回来，而不会导致应用异常退出。
  beego.BConfig.RecoverPanic = true
  
  // CopyRequestBody  
  是否允许在 HTTP 请求时，返回原始请求体数据字节，默认为 false （GET or HEAD or 上传文件请求除外）。
  beego.BConfig.CopyRequestBody = false
  
  // EnableGzip  
  是否开启 gzip 支持，默认为 false 不支持 gzip，一旦开启了 gzip，那么在模板输出的内容会进行 gzip 或者 zlib 压缩，根据用户的 Accept-Encoding 来判断。
  beego.BConfig.EnableGzip = false
  
  // Gzip允许用户自定义压缩级别、压缩长度阈值和针对请求类型压缩:
  	压缩级别, gzipCompressLevel = 9,取值为 1~9,如果不设置为 1(最快压缩)
  	压缩长度阈值, gzipMinLength = 256,当原始内容长度大于此阈值时才开启压缩,默认为 20B(ngnix默认长度)
  	请求类型, includedMethods = get;post,针对哪些请求类型进行压缩,默认只针对 GET 请求压缩
  
  // MaxMemory  
  文件上传默认内存缓存大小，默认值是 1 << 26(64M)。
  beego.BConfig.MaxMemory = 1 << 26
  
  // EnableErrorsShow  
  是否显示系统错误信息，默认为 true。
  beego.BConfig.EnableErrorsShow = true
  
  // EnableErrorsRender 
  是否将错误信息进行渲染，默认值为 true，即出错会提示友好的出错页面，对于 API 类型的应用可能需要将该选项设置为 false 以阻止在 dev 模式下不必要的模板渲染信息返回
  ```

  - **Web配置**

  ```go
  // AutoRender
  是否模板自动渲染，默认值为 true，对于 API 类型的应用，应用需要把该选项设置为 false，不需要渲染模板。
  beego.BConfig.WebConfig.AutoRender = true
  
  // EnableDocs
  是否开启文档内置功能，默认是 false
  beego.BConfig.WebConfig.EnableDocs = true
  
  // FlashName
  Flash 数据设置时 Cookie 的名称，默认是 BEEGO_FLASH
  beego.BConfig.WebConfig.FlashName = "BEEGO_FLASH"
  
  // FlashSeperator
  Flash 数据的分隔符，默认是 BEEGOFLASH
  beego.BConfig.WebConfig.FlashSeparator = "BEEGOFLASH"
  
  // DirectoryIndex
  是否开启静态目录的列表显示，默认不显示目录，返回 403 错误。
  beego.BConfig.WebConfig.DirectoryIndex = false
  
  // StaticDir
  静态文件目录设置，默认是static
  可配置单个或多个目录:
  	单个目录, StaticDir = download. 相当于 beego.SetStaticPath("/download","download")
  	多个目录, StaticDir = download:down download2:down2. 相当于beego.SetStaticPath("/download","down") 和 beego.SetStaticPath("/download2","down2")
  beego.BConfig.WebConfig.StaticDir
  
  // StaticExtensionsToGzip
  允许哪些后缀名的静态文件进行 gzip 压缩，默认支持 .css 和 .js
  beego.BConfig.WebConfig.StaticExtensionsToGzip = []string{".css", ".js"}
  等价 config 文件中StaticExtensionsToGzip = .css, .js 
  
  // TemplateLeft
  模板左标签，默认值是{{。
  beego.BConfig.WebConfig.TemplateLeft="{{"
  
  // TemplateRight
  模板右标签，默认值是}}。
  beego.BConfig.WebConfig.TemplateRight="}}"
  
  // ViewsPath
  模板路径，默认值是 views。
  beego.BConfig.WebConfig.ViewsPath="views"
  
  // EnableXSRF
  是否开启 XSRF，默认为 false，不开启。
  beego.BConfig.WebConfig.EnableXSRF = false
  
  // XSRFKEY
  XSRF 的 key 信息，默认值是 beegoxsrf。 EnableXSRF＝true 才有效
  beego.BConfig.WebConfig.XSRFKEY = "beegoxsrf"
  
  // XSRFExpire
  XSRF 过期时间，默认值是 0，不过期。
  beego.BConfig.WebConfig.XSRFExpire = 0
  
  // CommentRouterPath
  CommentRouterPath 注解路由所在位置。默认值是controllers。 Beego 会在启动的时候扫描下面的文件生成了路由。
  beego.BConfig.WebConfig.CommentRouterPath = "controllers"
  ```

  - **监听配置**

  ```go
  // Graceful
  是否开启热升级，默认是 false，关闭热升级。
  beego.BConfig.Listen.Graceful=false
  
  // ServerTimeOut
  设置 HTTP 的超时时间，默认是 0，不超时。
  beego.BConfig.Listen.ServerTimeOut=0
  
  // ListenTCP4
  监听本地网络地址类型，默认是TCP6，可以通过设置为true设置为TCP4。
  beego.BConfig.Listen.ListenTCP4 = true
  
  // EnableHTTP
  是否启用 HTTP 监听，默认是 true。
  beego.BConfig.Listen.EnableHTTP = true
  
  // HTTPAddr
  应用监听地址，默认为空，监听所有的网卡 IP。
  beego.BConfig.Listen.HTTPAddr = ""
  
  // HTTPPort
  应用监听端口，默认为 8080。
  beego.BConfig.Listen.HTTPPort = 8080
  
  // EnableHTTPS
  是否启用 HTTPS，默认是 false 关闭。当需要启用时，先设置 EnableHTTPS = true，并设置 HTTPSCertFile 和 HTTPSKeyFile
  beego.BConfig.Listen.EnableHTTPS = false
  
  // HTTPSAddr
  应用监听地址，默认为空，监听所有的网卡 IP。
  beego.BConfig.Listen.HTTPSAddr = ""
  
  // HTTPSPort
  应用监听端口，默认为 10443
  beego.BConfig.Listen.HTTPSPort = 10443
  
  // HTTPSCertFile
  开启 HTTPS 后，ssl 证书路径，默认为空。
  beego.BConfig.Listen.HTTPSCertFile = "conf/ssl.crt"
  
  // HTTPSKeyFile
  开启 HTTPS 之后，SSL 证书 keyfile 的路径。
  beego.BConfig.Listen.HTTPSKeyFile = "conf/ssl.key"
  
  // EnableAdmin
  是否开启进程内监控模块，默认 false 关闭。
  beego.BConfig.Listen.EnableAdmin = false
  
  // AdminAddr
  监控程序监听的地址，默认值是 localhost 。
  beego.BConfig.Listen.AdminAddr = "localhost"
  
  // AdminPort
  监控程序监听的地址，默认值是 8088 。
  beego.BConfig.Listen.AdminPort = 8088
  
  // EnableFcgi
  是否启用 fastcgi ， 默认是 false。
  beego.BConfig.Listen.EnableFcgi = false
  
  // EnableStdIo
  通过fastcgi 标准I/O，启用 fastcgi 后才生效，默认 false。
  beego.BConfig.Listen.EnableStdIo = false
  ```

  - **session配置**

  ```go
  // SessionOn
  session 是否开启，默认是 false。
  beego.BConfig.WebConfig.Session.SessionOn = false
  
  // SessionProvider
  session 的引擎，默认是 memory，详细参见 session 模块。
  beego.BConfig.WebConfig.Session.SessionProvider = ""
  
  // SessionName
  存在客户端的 cookie 名称，默认值是 beegosessionID。
  beego.BConfig.WebConfig.Session.SessionName = "beegosessionID"
  
  // SessionGCMaxLifetime
  session 过期时间，默认值是 3600 秒。
  beego.BConfig.WebConfig.Session.SessionGCMaxLifetime = 3600
  
  // SessionProviderConfig
  配置信息，根据不同的引擎设置不同的配置信息，详细的配置请看下面的引擎设置，详细参见 session 模块
  
  // SessionCookieLifeTime
  session 默认存在客户端的 cookie 的时间，默认值是 3600 秒。
  beego.BConfig.WebConfig.Session.SessionCookieLifeTime = 3600
  
  // SessionAutoSetCookie
  是否开启SetCookie, 默认值 true 开启。
  beego.BConfig.WebConfig.Session.SessionAutoSetCookie = true
  
  // SessionDomain
  session cookie 存储域名, 默认空。
  beego.BConfig.WebConfig.Session.SessionDomain = ""
  ```

  

  - **log配置**

  ```go
  // AccessLogs
  是否输出日志到 Log，默认在 prod 模式下不会输出日志，默认为 false 不输出日志。此参数不支持配置文件配置。
  beego.BConfig.Log.AccessLogs = false
  
  // EnableStaticLogs
  控制是否启用静态文件的日志记录。静态文件包括应用程序中的静态资源文件，如图片、CSS 文件、JavaScript 文件等。如果设置为 false，则表示不记录静态文件的访问日志；如果设置为 true，则表示记录静态文件的访问日志。默认值为 true，即启用静态文件的日志记录
  beego.BConfig.Log.EnableStaticLogs = false
  
  
  // AccessLogsFormat
  用于指定访问日志的输出格式。在 Beego 框架中，支持多种不同的日志输出格式，包括 Apache、Nginx 等常见的日志格式。默认APACHE_FORMAT 表示使用 Apache 日志格式来记录访问日志。如果不指定该配置项，默认使用 Beego 框架提供的默认日志格式
  beego.BConfig.Log.AccessLogsFormat = "APACHE_FORMAT"
  
  // FileLineNum
  是否在日志里面显示文件名和输出日志行号，默认 true。此参数不支持配置文件配置。
  beego.BConfig.Log.FileLineNum = true
  
  // Outputs
  日志输出配置，参考 logs 模块，console file 等配置，此参数不支持配置文件配置。
  beego.BConfig.Log.Outputs = map[string]string{"console": ""} 或
  beego.BConfig.Log.Outputs["console"] = ""
  ```

- BConfig 就是 beego 里面的默认的配置，也是结构体 `beego/server/web#Config` 的实例。

  ```go
  appname = beepweb  // 应用名称
  httpaddr = "127.0.0.1"  // 应用监听ip
  httpport = 8888     // 应用监听端口
  runmode ="dev"     // 运行模式
  autorender = false  // 使用自动渲染模板
  recoverpanic = false // 是否异常恢复
  viewspath = "myview"  // 模板路径
  ```

  - 我们也可以直接通过`beego.BConfig.AppName="beepkg"`这样来修改，和上面的配置效果一样，只是一个在代码里面写死了，而配置文件就会显得更加灵活

  ```go
  package main
  
  import (
  	_ "beegoStuday/routers"
  	beego "github.com/beego/beego/v2/server/web"
  )
  
  func main() {
  	// 通过BConfig方法覆盖beego默认参数
  	beego.BConfig.AppName = "beego"
  	beego.BConfig.Listen.HTTPPort = 8888
  	beego.Run()
  }
  ```

  - 学会设置参数后我们应该如何获取配置信息呢? 在 Beego 框架中可以使用`beego.AppConfig` 方法获取应用程序的配置信息。它提供了一种简单的方式来访问应用程序配置中的各种设置，例如数据库连接信息、应用程序名称、监听端口等等
    - 通过 `beego.AppConfig` 方法，你可以在代码中轻松地获取配置信息并据此进行逻辑操作。以下是一些常用的 `beego.AppConfig` 方法和示例用法:

  ```go
  package beegoconfig
  
  import (
      "github.com/astaxie/beego"
  )
  
  // Set 设置配置项的值。
  // 主要用于设置一些不在 Beego 框架预定义的配置项，或者动态设置某些配置项的值。例如，数据库连接信息、第三方服务的 API Key 等
  // 通常在应用程序的初始化阶段使用，以便在整个应用程序中使用相同的配置项
  func Set(key, val string) error {
      return beego.AppConfig.Set(key, val)
  }
  
  // String 获取字符串类型的配置项的值。
  func String(key string) string {
      return beego.AppConfig.String(key)
  }
  
  // Strings 获取字符串数组类型的配置项的值。
  func Strings(key string) []string {
      return beego.AppConfig.Strings(key)
  }
  
  // Int 获取整数类型的配置项的值。
  func Int(key string) (int, error) {
      return beego.AppConfig.Int(key)
  }
  
  // Int64 获取 int64 类型的配置项的值。
  func Int64(key string) (int64, error) {
      return beego.AppConfig.Int64(key)
  }
  
  // Bool 获取布尔类型的配置项的值。
  func Bool(key string) (bool, error) {
      return beego.AppConfig.Bool(key)
  }
  
  // Float 获取浮点数类型的配置项的值。
  func Float(key string) (float64, error) {
      return beego.AppConfig.Float(key)
  }
  
  // DefaultString 获取字符串类型的配置项的值，如果配置项不存在，则返回默认值。
  func DefaultString(key string, defaultVal string) string {
      return beego.AppConfig.DefaultString(key, defaultVal)
  }
  
  // DefaultStrings 获取字符串数组类型的配置项的值，如果配置项不存在，则返回默认值。
  func DefaultStrings(key string, defaultVal []string) []string {
      return beego.AppConfig.DefaultStrings(key, defaultVal)
  }
  
  // DefaultInt 获取整数类型的配置项的值，如果配置项不存在，则返回默认值。
  func DefaultInt(key string, defaultVal int) int {
      return beego.AppConfig.DefaultInt(key, defaultVal)
  }
  
  // DefaultInt64 获取 int64 类型的配置项的值，如果配置项不存在，则返回默认值。
  func DefaultInt64(key string, defaultVal int64) int64 {
      return beego.AppConfig.DefaultInt64(key, defaultVal)
  }
  
  // DefaultBool 获取布尔类型的配置项的值，如果配置项不存在，则返回默认值。
  func DefaultBool(key string, defaultVal bool) bool {
      return beego.AppConfig.DefaultBool(key, defaultVal)
  }
  
  // DefaultFloat 获取浮点数类型的配置项的值，如果配置项不存在，则返回默认值。
  func DefaultFloat(key string, defaultVal float64) float64 {
      return beego.AppConfig.DefaultFloat(key, defaultVal)
  }
  
  // DIY 获取自定义类型的配置项的值，返回值为 interface{} 类型，需要自行进行类型断言。
  func DIY(key string) (interface{}, error) {
      return beego.AppConfig.DIY(key)
  }
  
  // GetSection 获取指定节（section）的所有配置项。
  func GetSection(section string) (map[string]string, error) {
      return beego.AppConfig.GetSection(section)
  }
  
  // SaveConfigFile 将当前配置保存到指定的文件中。
  func SaveConfigFile(filename string) error {
      return beego.AppConfig.SaveConfigFile(filename)
  }
  ```

###### 19.3.3.2.2 不同级别的配置

- 在配置文件里面支持 section，可以有不同的 Runmode 的配置，默认优先读取 runmode 下的配置信息，例如下面的配置文件：

```go
appname = beepkg
httpaddr = "127.0.0.1"
runmode ="dev"
autorender = false
recoverpanic = false
viewspath = "myview"

[dev]
httpport = 8080
[prod]
httpport = 8088
[test]
httpport = 8888
```

- 上面的配置文件就是在不同的 runmode 下解析不同的配置，例如在 dev 模式下，httpport 是 8080，在 prod 模式下是 8088，在 test 模式下是 8888。其他配置文件同理。解析的时候优先解析 runmode 下的配置，然后解析默认的配置。
- 读取不同模式下配置参数的方法是“模式::配置参数名”，比如：beego.AppConfig.String("dev::mysqluser")。
- 对于自定义的参数，需使用 GetConfig(typ, key string, defaultVal interface{}) 来获取指定 runmode 下的配置（需 1.4.0 以上版本），typ 为参数类型，key 为参数名, defaultVal 为默认值

###### 19.3.3.2.3 多个配置文件

- INI 格式配置支持 `include` 方式，引用多个配置文件，这种通过“include”命令包含其他配置文件的方式，跟把所有配置都写在一个配置文件的效果是一样的。区别就是：在使用多个配置文件时，各个模块的配置更加清晰。
- 无论是使用“include’”命令包含配置文件，还是直接将所有配置都写在一个配置文件，读取配置的方式是一样的

```go
appname = beepkg
httpaddr = "127.0.0.1"
httpport = 9999

include "app2.conf"


// app2.conf
runmode ="dev"
autorender = false
recoverpanic = false
viewspath = "myview"

[dev]
httpport = 8080
[prod]
httpport = 8088
[test]
httpport = 8888
```

###### 19.3.3.2.4 使用环境变量配置

- 配置文件解析支持从环境变量中获取配置项，配置项格式：`${环境变量}`。例如下面的配置中优先使用环境变量中配置的 runmode 和 httpport，如果有配置环境变量 ProRunMode 则优先使用该环境变量值。如果不存在或者为空，则使用 "dev" 作为 runmode

```go
runmode  = "${ProRunMode||dev}"
httpport = "${ProPort||8888}"
```

##### 19.3.3.3 路由管理

- Beego提供两种设置处理器函数的路由配置的方式
  - 直接绑定路由处理器函数
  - 绑定一个控制器对象

###### 19.3.3.3.1 直接绑定路由处理器函数

- 这种方式是直接将路由和处理器函数进行绑定，每个路由都映射到一个具体的处理器函数。这种方式比较简单直接，适用于简单的应用场景

```go
beego.请求方法(路由, 处理函数)
```

- 案例

```go
package main

import (
	_ "beegoStuday/routers"
	beego "github.com/beego/beego/v2/server/web"
	"github.com/beego/beego/v2/server/web/context"
)

func beegoPost(c *context.Context) {
	c.ResponseWriter.Write([]byte("hello beego"))
}

func main() {
	beego.Get("/home", func(ctx *context.Context) {
		ctx.Output.Body([]byte("hello beego"))
	})

	beego.Post("/user", beegoPost)
	
	beego.Run(":8888")
}
```

![image-20240406120927863](https://cloud.006288.xyz/PicGo//image-20240406120927863.png)

###### 19.3.3.3.2 绑定一个控制器对象

- 种方式是将路由和控制器对象中的方法进行绑定，每个路由对应于控制器对象中的一个方法。这种方式更加灵活，适用于复杂的应用场景，尤其是需要组织大量路由和处理器函数时

- Beego默认支持RESTful风格。RESTful路由使用beego.Router()函数设置

```go
beego.Router("路由", "控制器对象")
```

- 案例

```go
// 注册路由
beego.Router("/home", &controllers.UserController{})

// 控制器函数
package controllers

import beego "github.com/beego/beego/v2/server/web"

type UserController struct {
	beego.Controller
}

type User struct {
	Name string `json:"name" form:"name"`
	Age  int    `json:"age" form:"age"`
}

func (u *UserController) Get() {
	u.Ctx.WriteString("hello beego")
}

func (u *UserController) Post() {
	u.Data["Name"] = "kubei"
	u.Data["Age"] = 20
	u.TplName = "user.html"
}
```

![image-20240406122702303](https://cloud.006288.xyz/PicGo//image-20240406122702303.png)

###### 19.3.3.3.3 URL路由方式

- **固定路由**
  - 固定路由是最简单和常见的路由配置方式，直接将请求路径与处理器函数进行绑定，无需使用正则表达式

```go
beego.Router("/hello", &controllers.HelloController{})
```

- **正则路由**
  - 正则路由使用正则表达式来匹配请求路径，允许更灵活的路由配置

```go
web.Router("/api/?:id", &controllers.RController{})
默认匹配 //例如对于URL"/api/123"可以匹配成功，此时变量":id"值为"123"，URL"/api/"可正常匹配


web.Router("/api/:id", &controllers.RController{})
默认匹配 //例如对于URL"/api/123"可以匹配成功，此时变量":id"值为"123"，但URL"/api/"匹配失败


web.Router("/api/:id([0-9]+)", &controllers.RController{})
自定义正则匹配 //例如对于URL"/api/123"可以匹配成功，此时变量":id"值为"123"


web.Router("/user/:username([\\w]+)", &controllers.RController{})
正则字符串匹配 //例如对于URL"/user/astaxie"可以匹配成功，此时变量":username"值为"astaxie"


web.Router("/download/*.*", &controllers.RController{})
*匹配方式 //例如对于URL"/download/file/api.xml"可以匹配成功，此时变量":path"值为"file/api"， ":ext"值为"xml"


web.Router("/download/ceshi/*", &controllers.RController{})
*全匹配方式 //例如对于URL"/download/ceshi/file/api.json"可以匹配成功，此时变量":splat"值为"file/api.json"


web.Router("/:id:int", &controllers.RController{})
int 类型设置方式，匹配 :id为int 类型，框架帮你实现了正则 ([0-9]+)


web.Router("/:hi:string", &controllers.RController{})
string 类型设置方式，匹配 :hi 为 string 类型。框架帮你实现了正则 ([\w]+)


web.Router("/cms_:id([0-9]+).html", &controllers.CmsController{})
带有前缀的自定义正则 //匹配 :id 为正则类型。匹配 cms_123.html 这样的 url :id = 123
```

- **自动路由**

  - 动路由是 Beego 框架提供的一种便捷的路由配置方式，可以根据控制器命名规范自动生成路由规则。例如，一个名为 `UserController` 的控制器将自动生成 `/user` 路由

  ```go
  beego.AutoRouter(&controllers.UserController{})
  ```

  - 那么 beego 就会通过反射获取该结构体中所有的实现方法，你就可以通过如下的方式访问到对应的方法中：

  ```go
  /user/login   调用 UserController 中的 Login 方法
  /user/logout  调用 UserController 中的 Logout 方法
  ```

  - 除了前缀两个 `/:controller/:method` 的匹配之外，剩下的 url beego 会帮你自动化解析为参数，保存在 `this.Ctx.Input.Params` 当中, 可以通过 `this.Ctx.Input.Param(":ext")` 获取后缀名
  - 方法名在内部是保存了用户设置的，例如 Login，url 匹配的时候都会转化为小写，所以，`/user/LOGIN` 这样的 `url` 也一样可以路由到用户定义的 `Login` 方法中

- **路由命名空间**
  - 路由命名空间允许将一组相关的路由分组到一个命名空间中，方便管理和维护, 一般用来做API接口开发版本处理
  - 通过`NewNamespace()`函数可以创建多个命名空间，`NSNamespace()`函数可以无限嵌套命名空间
  - 命名空间的作用其实就是定义URL路由的前缀。如果一个命名空间定义URL路由为“/user”,则这个命名空间下面定义的所有路由的前缀都是以“/user”开头的

```go
	ns1 := beego.NewNamespace("/v1",
		beego.NSNamespace("/user",
			beego.NSRouter("/info", &controllers.UserController{})))
	// 注册路由
	beego.AddNamespace(ns1)
```

![image-20240406220109046](https://cloud.006288.xyz/PicGo//image-20240406220109046.png)

- **注解路由**

  - Beego 框架支持使用注解来配置路由，即在控制器的方法上使用特定的注解来指定路由规则

  - 从2.0开始，我们使用配置`CommentRouterPath`来配置注解路由的扫描路径。在`dev`环境下，我们将自动扫描该配置指向的目录及其子目录，生成路由文件

    > 从v2.0.2起删除了注解路由器自动生成功能，需要使用bee generate routers来生成。[具体可以看v2.0.2发行说明](https://github.com/beego/beego/releases/tag/v2.0.2)

  - 生成之后，用户需要显示 Include 相应地 controller。注意， controller 的 method 方法上面须有 router 注释（// @router）

```go
package controllers

import beego "github.com/beego/beego/v2/server/web"

type UserController struct {
	beego.Controller
}

type User struct {
	Name string `json:"name" form:"name"`
	Age  int    `json:"age" form:"age"`
}

// @router /user [get]
func (u *UserController) Get() {
	u.Ctx.WriteString("hello beego")
}

// @router /user:id [post]
func (u *UserController) Post() {
	u.Data["Name"] = "kubei"
	u.Data["Age"] = 20
	u.TplName = "user.html"
}


// 在 router.go 中通过如下方式注册路由
beego.Include(&controllers.UserController{})

// 生成的路由文件
package routers

import (
	beego "github.com/beego/beego/v2/server/web"
	"github.com/beego/beego/v2/server/web/context/param"
)

func init() {

    beego.GlobalControllerRouter["beegoStuday/controllers:UserController"] = append(beego.GlobalControllerRouter["beegoStuday/controllers:UserController"],
        beego.ControllerComments{
            Method: "Get",
            Router: `/user`,
            AllowHTTPMethods: []string{"get"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

    beego.GlobalControllerRouter["beegoStuday/controllers:UserController"] = append(beego.GlobalControllerRouter["beegoStuday/controllers:UserController"],
        beego.ControllerComments{
            Method: "Post",
            Router: `/user/:id`,
            AllowHTTPMethods: []string{"post"},
            MethodParams: param.Make(),
            Filters: nil,
            Params: nil})

}
```

![image-20240406221132890](https://cloud.006288.xyz/PicGo//image-20240406221132890.png)

![image-20240406222050643](https://cloud.006288.xyz/PicGo//image-20240406222050643.png)

- **方法表达式路由**
  - 在 Beego 框架中，你可以使用方法表达式路由（Method Expression Routing）来定义路由规则。方法表达式路由允许你直接使用控制器对象中的方法来定义路由规则，而不必使用注解
  - 方法表达式路由与上面的RESTful基本相似，区别是无需在传入http method和controller方法（如：`"get:StaticBlock"`）。
  - 只需要通过golang的method expression进行传入方法表达式。如果方法是receiver是非指针，则直接使用 `包名.Controller.Method` 方法 传入，如果receiver是指针，则使用 `(*包名.Controller).Method` 进行传参。假如在同包下，包名可进行省略

```go
type BaseController struct {
	web.Controller
}

func (b BaseController) Ping() {
	b.Data["json"] = "pong"
	b.ServeJSON()
}

func (b *BaseController) PingPointer() {
	b.Data["json"] = "pong_pointer"
	b.ServeJSON()
}

func main() {
	beego.CtrlGet("/ping", BaseController.Ping)
	beego.CtrlGet("/ping_pointer", (*BaseController).PingPointer)
	beego.Run()
}
```

- 或

```go
package controllers

import (
    "github.com/astaxie/beego"
)

type UserController struct {
    beego.Controller
}

func (u *UserController) GetUserInfo() {
    u.Data["json"] = map[string]interface{}{
        "name": "kubei",
        "age": 20,
    }
    u.ServeJSON()
}

func init() {
    beego.Router("/user/:id", &UserController{}, "get:GetUserInfo")
}

```

##### 19.3.3.4 控制器管理

- 控制器函数是指处理用户请求的函数。Beego框架支持beego.FilterFunc()函数和控制器函数两种处理用户请求的函数

###### 19.3.3.4.1 beego.FilterFunc()函数

- beego.FilterFunc()是最简单的请求处理函数, 即只要定义一个函数，并且接收一个Context参数，则这个函数就可以作为处理用户请求的函数

```go
package main

import (
	_ "beegoStuday/routers"
	beego "github.com/beego/beego/v2/server/web"
	"github.com/beego/beego/v2/server/web/context"
)

func beegoPost(c *context.Context) {
	c.ResponseWriter.Write([]byte("hello beego"))
}

func main() {
	beego.Get("/home", func(ctx *context.Context) {
		ctx.Output.Body([]byte("hello beego"))
	})

	beego.Post("/user", beegoPost)
	
	beego.Run(":8888")
}
```

###### 19.3.3.4.2 控制器函数

- 控制器函数是Beego的RESTful API的实现方式。在Beego的设计中，控制器就是一个嵌套了beego.Controller的结构体对象

- 这种方式是直接在控制器中定义处理请求的方法。控制器是一个结构体，它包含了处理请求的多个方法。每个方法对应着一个请求处理逻辑, 只需要匿名组合 `beego.Controller` 就可以了

```go
type UserController struct {
	beego.Controller
}
```



- **控制器方法**

  - `beego.Controller` 实现了接口 `beego.ControllerInterface`，`web.ControllerInterface` 定义了如下函数:

    - `Init`(ctx *context.Context, controllerName, actionName string, app interface{})

      这个函数主要初始化了 Context、相应的 Controller 名称，模板名，初始化模板参数的容器 Data，app 即为当前执行的 Controller 的 reflecttype，这个 app 可以用来执行子类的方法。

    - `Prepare()`

      这个函数主要是为了用户扩展用的，这个函数会在下面定义的这些 Method 方法之前执行，用户可以重写这个函数实现类似用户验证之类。

    - `Get()`

      如果用户请求的 HTTP Method 是 GET，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Get 请求。

    - `Post()`

      如果用户请求的 HTTP Method 是 POST，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Post 请求。

    - `Delete()`

      如果用户请求的 HTTP Method 是 DELETE，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Delete 请求。

    - `Put()`

      如果用户请求的 HTTP Method 是 PUT，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Put 请求.

    - `Head()`

      如果用户请求的 HTTP Method 是 HEAD，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Head 请求。

    - `Patch()`

      如果用户请求的 HTTP Method 是 PATCH，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Patch 请求.

    - `Options()`

      如果用户请求的HTTP Method是OPTIONS，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Options 请求。

    - Finish()

      这个函数是在执行完相应的 HTTP Method 方法之后执行的，默认是空，用户可以在子 struct 中重写这个函数，执行例如数据库关闭，清理数据之类的工作。

    - Trace() error

      如果用户请求的 HTTP Method 是 Trace，那么就执行该函数，默认是 405，用户继承的子 struct 中可以实现了该方法以处理 Head 请求。

    - `Render() error`

      这个函数主要用来实现渲染模板，如果 beego.AutoRender 为 true 的情况下才会执行。

    - `Mapping(method string, fn func())`

      注册一个方法。一般而言， method 是合法的 HTTP 方法名。当然，用户注册自己特定的业务逻辑方法，而后手动调用。

    - `HandlerFunc(fnname string) bool`

      在前面 Mapping 方法里面注册的方法，可以通过该方法来使用。只会返回调用是否成功的信息——一般而言，只有方法不存在才会返回 false

    - `RenderBytes() ([]byte, error)`

      将模板渲染成字节数组。需要注意的是，该方法并未检测`EnableRender`设置。并且，和`Render`方法相比，它并未将结果输出到`Response`。

    - `RenderString() (string, error)`

      类似于`RenderBytes`方法。只是将结果转化为了`string`。

    - `Redirect(url string, code int)`

      重定向。`url`是目的地址。

    - `SetData(data interface{})`

      将`data`存储在控制的数据中。一般而言，你不会考虑用到这个方法。

    - Abort(code string)

      中断当前方法的执行，直接返回该状态码，类似于`CustomAbort`。参考[errors](https://git-books.github.io/books/beego/errors.md)

    - CustomAbort(status int, body string)

      中断方法执行，直接返回该状态码和信息。参考[errors](https://git-books.github.io/books/beego/errors.md)

    - StopRun()

      直接触发`panic`。

    - `ServeXXX(encoding ...bool) error`

      返回特性类型的响应。目前我们支持 JSON，JSONP，XML，YAML。参考[输出格式](https://git-books.github.io/books/beego/jsonxml.md)

    - `ServeFormatted(encoding ...bool) error`

      返回响应。其格式由客户端的`Accept`选项指定。参考[输出格式](https://git-books.github.io/books/beego/jsonxml.md)

    - `Input() (url.Values, error)`

      返回传入的参数。

    - `ParseForm(obj interface{}) error`

      将表单反序列化到 obj 对象中。

    - `GetXXX(key string, def...) XXX, err`

      从传入参数中，读取某个值。如果传入了默认值，那么在读取不到的情况下，返回默认值，否则返回错误。XXX 可以是 golang 所支持的基本类型，或者是 string, File 对象

    - `SaveToFile(fromfile, tofile string) error`

      将上传的文件保存到文件系统中。其中`fromfile`是上传的文件的名字。

    - `SetSession(name interface{}, value interface{}) error`

      往`Session`中设置值。

    - `GetSession(name interface{}) interface{}`

      从`Session`中读取值。

    - `DelSession(name interface{}) error`

      从`Session`中删除某项。

    - `SessionRegenerateID() error`

      重新生成一个`SessionId`。

    - `DestroySession() error`

      销毁`Session`

    - `IsAjax() bool`

      是否是 Ajax 请求

    - `GetSecureCookie(Secret, key string) (string, bool)`

      从`Cookie`中读取数据。`bool`返回值，表达是否取到了数据。

    - SetSecureCookie(Secret, name, value string, others ...interface{})

      设置`Cookie`。

    - `XSRFToken() string`

      创建一个`CSRF` token.

    - `CheckXSRFCookie() bool`

      检测是否有`CSRF` token

  - 我们可以通过方法重写来实现我们自己的逻辑

##### 19.3.3.5 获取请求参数

- 在 Beego 框架中，可以通过 `ctx.Input` 对象来获取请求参数。`ctx` 是 `beego.Controller` 类型的对象，它包含了当前请求的上下文信息，可以用于获取请求参数、请求头等信息
  - `ctx.Input` 对象一些常用的方法来获取请求参数:
    - **`ctx.Input.Query(key string)`：** 获取 URL 查询参数（例如 `?key1=value1&key2=value2` 中的参数）
    - **`ctx.Input.Param(key string)`：** 获取 URL 路径参数（例如 `/user/:id` 中的参数）
    - **`ctx.Input.RequestBody`：** 获取请求体的原始数据（例如 POST 请求的 JSON 数据）
    - **`ctx.Input.Header(key string)`：** 获取请求头参数
    - **`ctx.Input.Cookie(key string)`：** 获取请求中的 Cookie 值
- 还可以使用 `ctx.GetString`、`ctx.GetStrings`、`ctx.GetInt`、`ctx.GetBool` 和 `ctx.GetFloat` 等方法直接从请求中获取特定类型的参数。这些方法会自动解析请求中的参数，并将其转换为对应的类型
  - **`ctx.Getxxx`**常用的方法来获取请求参数
    - **`ctx.GetString(key string) string`：** 获取指定键的字符串类型参数值
    - **`ctx.GetStrings(key string) []string`：** 获取指定键的字符串数组类型参数值
    - **`ctx.GetInt(key string) (int64, error)`：** 获取指定键的整数类型参数值
    - **`ctx.GetBool(key string) (bool, error)`：** 获取指定键的布尔类型参数值
    - **`ctx.GetFloat(key string) (float64, error)`：** 获取指定键的浮点数类型参数值

> 如果请求的参数没有某个值,可以使用默认值 getxxx(key, "默认值")

###### 19.3.3.5.1 获取Query请求中的参数

- 使用**`ctx.Input.Query(key string)`：** 获取 URL 查询参数（例如 `?key1=value1&key2=value2` 中的参数）
- 使用getxxx方法获取

```go
func (u *UserController) Login() {
	user := u.Ctx.Input.Query("user")
	age, _ := u.GetInt("age")

	str := fmt.Sprintf("%v用户登录成功, 年龄为: %v\n", user, age)
	u.Ctx.WriteString(str)
}
```

![image-20240407230513241](https://cloud.006288.xyz/PicGo//image-20240407230513241.png)

###### 19.3.3.5.2 获取动态路由参数

- 使用**`ctx.Input.Param(key string)`：** 获取 URL 路径参数（例如 `/user/:id` 中的参数）

```go
func (u *UserController) Login() {
	user := u.Ctx.Input.Param(":id")

	str := fmt.Sprintf("%v用户登录成功\n", user)
	u.Ctx.WriteString(str)
}


// 路由
beego.Router("/user/:id", &controllers.UserController{}, "post:Login")
```

![image-20240407230917079](https://cloud.006288.xyz/PicGo//image-20240407230917079.png)

###### 19.3.3.5.3 获取form表单中的参数

- 使用getxxx方式获取
- 使用**ctx.Request.PostForm**: 这个方法返回一个包含所有表单数据的map。你可以通过map的键来访问对应的值
- 使用**ctx.Request.FormValue(key string)**: 这个方法会从请求的表单数据中获取指定键的值。如果键不存在，会返回空字符串
- **ctx.Request.Form**: 与 `PostForm` 方法类似，返回一个包含所有表单数据的map。但是，如果请求是GET请求，该方法也会包含URL中的查询参数

```go
func (u *UserController) Login() {
	user := u.GetString("user", "admin")
	age := u.Ctx.Request.FormValue("age")
	all := u.Ctx.Request.PostForm
	
	//all := u.Ctx.Request.Form

	str := fmt.Sprintf("%v用户登录成功,年龄是: %v, 这次请求的参数: %v\n", user, age, all)
	u.Ctx.WriteString(str)
}
```

![image-20240407232719873](https://cloud.006288.xyz/PicGo//image-20240407232719873.png)

###### 19.3.3.5.4 获取raw中的参数

- 使用**`ctx.Input.RequestBody`：** 获取请求体的原始数据（例如 POST 请求的 JSON 数据）
- 一般在接口开发时，有时会将JSON请求参数保存在HTTP请求的请求体中。这时就不能使用绑定结构体方式获取JSON数据，需要直接读取请求体的内容，然后格式化数据。处理JSON参数的步骤如下：
  - 在app.conf配置文件中添加一行：**CopyRequestBody=true**。
  - 通过c.Ctx.Input.RequestBody语句获取HTTP请求中请求体的内容。
  - 通过json.Unmarshal()函数反序列化JSON字符串，将JSON参数绑定到结构体变量

```go
// 配置参数
CopyRequestBody=true

// 控制器
type User struct {
	Name string `json:"name" form:"name"`
	Age  int    `json:"age" form:"age"`
}

func (u *UserController) Login() {
	userinfo := User{}
	if err := json.Unmarshal(u.Ctx.Input.RequestBody, &userinfo); err != nil {
		return
	}

	str := fmt.Sprintf("用户信息如下:%v\n", userinfo)
	u.Ctx.WriteString(str)
}
```

![image-20240407235406722](https://cloud.006288.xyz/PicGo//image-20240407235406722.png)

###### 19.3.3.5. 5 模型绑定

- 大多数时候，我们还需要把输入转换为结构体，Beego 提供了一系列的方法来完成输入到结构体的绑定。

- 这部分方法是直接定义在 `Context` 结构体上的，所以用户可以直接操作 `Context` 实例。为了简化操作，我们在`Controller`上也定义了类似的方法

- `Bind`这一大类有多个方法：

  - `Bind(obj interface{}) error`: 默认是依据输入的 `Content-Type`字段，来判断该如何反序列化；
  - `BindYAML(obj interface{}) error`: 处理`YAML`输入
  - `BindForm(obj interface{}) error`: 处理表单输入
  - `BindJSON(obj interface{}) error`: 处理`JSON`输入
  - `BindProtobuf(obj proto.Message) error`: 处理`proto`输入
  - `BindXML(obj interface{}) error`: 处理`XML`输入

- 在使用特定格式的输入的时候，别忘记设置标签（`Tag`），例如我们例子里面的`json:"age"`，不同格式的输入，其标签是不是一样的。
  
- 需要注意的是，虽然我们提供了一个根据`Content-Type`来判断如何绑定的，但是我们更加推荐用户使用指定格式的绑定方法。

  > - 一个接口，应该只接收特定某种格式的输入，例如只接收 JSON，而不应该可以处理多种输入

- 在早期，Beego 还有一个类似于`BindForm`的方法：`ParseForm(obj interface{}) error`，这两个方法效果是一致的

```go
// 在app.conf配置文件中添加一行：CopyRequestBody=true

func (u *UserController) Login() {
	userinfo := User{}
	if err := u.BindJSON(&userinfo); err != nil {
		u.Ctx.WriteString("绑定失败")
		return
	}

	str := fmt.Sprintf("绑定成功,用户信息如下:%v\n", userinfo)
	u.Ctx.WriteString(str)
}
```

![image-20240408003624074](https://cloud.006288.xyz/PicGo//image-20240408003624074.png)

###### 19.3.3.5.6 文件上传

- 在 beego 中你可以很容易的处理文件上传，就是别忘记在你的 form 表单中增加这个属性 `enctype="multipart/form-data"`，否则你的浏览器不会传输你的上传文件。
- 文件上传之后一般是放在系统的内存里面，如果文件的 size 大于设置的缓存内存大小，那么就放在临时文件中，默认的缓存内存是 64M，你可以通过如下来调整这个缓存内存大小:

```go
beego.BConfig.MaxMemory = 1<<22
// 或者在配置文件中通过如下设置：
maxmemory = 1<<22
```

- 与此同时，beego 提供了另外一个参数，`MaxUploadSize`来限制最大上传文件大小——如果你一次长传多个文件，那么它限制的就是这些所有文件合并在一起的大小。

  - 默认情况下，`MaxMemory`应该设置得比`MaxUploadSize`小，这种情况下两个参数合并在一起的效果则是：
    - 如果文件大小小于`MaxMemory`，则直接在内存中处理；
    - 如果文件大小介于`MaxMemory`和`MaxUploadSize`之间，那么比`MaxMemory`大的部分将会放在临时目录；
    - 文件大小超出`MaxUploadSize`，直接拒绝请求，返回响应码 413

  - Beego 提供了两个很方便的方法来处理文件上传：

    - GetFile(key string) (multipart.File, *multipart.FileHeader, error)

      该方法主要用于用户读取表单中的文件名 `the_file`，然后返回相应的信息，用户根据这些变量来处理文件上传：过滤、保存文件等。`GetFile` 方法返回三个值：一个 `multipart.File` 接口，代表上传的文件，以及一个 `*multipart.FileHeader` 结构体，包含了文件的元数据，如文件名、大小等信息, 最后一个是错误

    - SaveToFile(fromfile, tofile string) error

      该方法是在 GetFile 的基础上实现了快速保存的功能
      fromfile 是提交时候的 html 表单中的 name

    > 此处和gin框架差不多可以使用它自带的保存方式,也可以使用os.create和io.copy方法自己实现

- 示例

```go
func (c *UserController) UPload() {
	f, h, _ := c.GetFile("file")
	f.Close()

	c.SaveToFile("file", "./static/img/"+h.Filename)  // 文件目录一定要存在,没有需要提前创建

}
```

![image-20240408001402377](https://cloud.006288.xyz/PicGo//image-20240408001402377.png)

- 上传多个文件

```go
func (c *UserController) UPload() {
	forms, _ := c.GetFiles("file")
	for _, file := range forms {
		c.SaveToFile("file", "./static/img/"+file.Filename)
	}
}
```

![image-20240408002006670](https://cloud.006288.xyz/PicGo//image-20240408002006670.png)

###### 19.3.3.5.7 文件下载

- 在Beego框架中，你可以使用 `c.Ctx.Output.Download` 方法来实现文件下载。这个方法用于发送文件给客户端，将文件内容作为响应主体，并设置相应的Content-Disposition头，让浏览器自动下载文件
- `Download`方法的第一个参数，是文件路径，也就是要下载的文件；第二个参数是不定参数，代表的是用户保存到本地时候的文件名

```go
func (u *UserController) DownloadFile() {
	u.Ctx.Output.Download("./static/img/sahnghai.png", "shanghai.jpg")
}
```

![image-20240408002903298](https://cloud.006288.xyz/PicGo//image-20240408002903298.png)

##### 19.3.3.6 响应请求

- 在处理完用户的请求后，通常会返回HTML代码，然后浏览器就可以显示HTML内容。除返回HTML外，在API接口开发中，还可以返回JSON、XML、JSONP格式的数据。
- 如果使用Beego开发API,则需要在app.conf中设置AutoRender=false,以禁止自动渲染模板，否则Beego每次处理请求都会尝试渲染模板，如果模板不存在则会报错

###### 19.3.3.6.1 直接输出文本

- 使用 `c.Ctx.WriteString` 方法或 `c.Ctx.Output.Body` 方法直接输出文本或HTML内容到响应主体。

```go
c.Ctx.WriteString("Hello, beego!")

u.Ctx.Output.Body([]byte("hello beego"))
```

###### 19.3.3.6.2 返回JSON数据

- 使用 `c.Data["json"]` 或 `c.Data["jsonp"]` 设置JSON数据，然后调用 `c.ServeJSON` 方法将其返回给客户端

```go
// JSON结构体
type UserJson struct {
	//忽略掉Id字段
	Id int `json:"-"`
	//JSON字段名为name
	Name  string `json:"name"`
	Phone string `json:"phone"`
}

func (this *UserController) Get() {
	//返回JSON数据
	user := models.UserJson{1, "tom", "123456"}
	//讲需要返回的数据赋值给json字段
	this.Data["json"] = &user
	//将数据序列化成json字符串，然后返回给客户端
	this.ServeJSON()
}
```

> 其他数据xml等用法也基本相似,对应替换即可

###### 19.3.3.6.3 渲染模板

- Beego 的模板处理引擎采用的是 Go 内置的 `html/template` 包进行处理，而且 Beego 的模板处理逻辑是采用了缓存编译方式，也就是所有的模板会在 Beego 应用启动的时候全部编译然后缓存在 map 里面
- Beego 中默认的模板目录是 `views`，用户可以把模板文件放到该目录下，Beego 会自动在该目录下的所有模板文件进行解析并缓存，开发模式下每次都会重新解析，不做缓存。当然，用户也可以通过如下的方式改变模板的目录（只能指定一个目录为模板目录)

```go
beego.ViewsPath = "myviewpath"
```

- 用户无需手动的调用渲染输出模板，Beego 会自动的在调用完相应的 `method` 方法之后调用 `Render` 函数，当然如果您的应用是不需要模板输出的，那么可以在配置文件或者在 `main.go` 中设置关闭自动渲染

```go
beego.AutoRender = false
或在配置文件中设置
autorender = false
```

- beego模板基本语法和go语言模板一摸一样,这里不在展开

- 案例

```go
func (this *UserController) Get() {
	//渲染视图
	user := models.UserForm{1, "tom", "123456"}
	this.Data["user"] = user
	//设置要渲染的模板路径，即views目录下面的相对路径
	//如果不设置TplName，则beego默认按照 "<控制器名字>/<方法名>.tpl"  格式去查找模板文件
	this.TplName = "user/index.html"
	//如果关闭了自动渲染，则需要手动调用渲染函数。默认开启自动渲染
	this.Render()
}


// 模板
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1>用户个人信心：</h1>
    <p>
        用户名：{{.user.Name}}<br/>
        注册时间：{{.user.Phone}}
    </p>
</body>
</html>

```

###### 19.3.3.6.4 重定向

- 在Beego框架中，你可以使用 `c.Redirect` 方法进行重定向。这个方法接受两个参数：要重定向的目标URL和HTTP状态码（可选，默认为302）

```go
func (c *LoginController) Post() {
    // 处理用户登录逻辑
    // ...

    // 登录成功后重定向到首页
    c.Redirect("/", 302)
}
```

> 你也可以使用其他的HTTP状态码来执行不同类型的重定向。常见的HTTP状态码有：
>
> - 301 Moved Permanently：永久重定向，表示请求的资源已经被移动到新的URL上。
> - 302 Found：临时重定向，表示请求的资源暂时被移动到新的URL上。
> - 303 See Other：表示请求的资源存在另一个URL上，客户端应该使用GET方法去获取资源。
> - 307 Temporary Redirect：临时重定向，与302类似，但是要求客户端保持请求方法不变进行重定向。
> - 308 Permanent Redirect：永久重定向，与301类似，但要求客户端保持请求方法不变进行重定向

##### 19.3.3.7 中间件(过滤器)使用

- 在Beego框架中，过滤器是一种机制，允许您在HTTP请求到达Controller之前或响应返回给客户端之前拦截并处理请求和响应。通过使用过滤器，您可以实现一些通用的操作，例如身份验证、日志记录、请求参数校验、响应结果处理等

- 过滤器函数如下所示：

  ```
  web.InsertFilter(pattern string, pos int, filter FilterFunc, opts ...FilterOpt)
  ```

  - InsertFilter 函数的三个必填参数，一个可选参数

    - **pattern 路由规则**，可以根据一定的规则进行路由，如果你全匹配可以用 `*`

    - **position 执行 Filter 的地方**，五个固定参数如下，分别表示不同的执行过程
      - BeforeStatic 静态地址之前
        - BeforeRouter 寻找路由之前
          - BeforeExec 找到路由之后，开始执行相应的 Controller 之前
          - AfterExec 执行完 Controller 逻辑之后执行的过滤器
          - FinishRouter 执行完逻辑之后执行的过滤器

    - **filter filter 函数** type FilterFunc func(*context.Context)

    - **opts**
      1. web.WithReturnOnOutput: 设置 returnOnOutput 的值(默认 true), 如果在进行到此过滤之前已经有输出，是否不再继续执行此过滤器,默认设置为如果前面已有输出(参数为true)，则不再执行此过滤器
      2. web.WithResetParams: 是否重置 filters 的参数，默认是 false，因为在 filters 的 pattern 和本身的路由的 pattern 冲突的时候，可以把 filters 的参数重置，这样可以保证在后续的逻辑中获取到正确的参数，例如设置了 `/api/*` 的 filter，同时又设置了 `/api/docs/*` 的 router，那么在访问 `/api/docs/swagger/abc.js` 的时候，在执行 filters 的时候设置 `:splat` 参数为 `docs/swagger/abc.js`，但是如果不清楚 filter 的这个路由参数，就会在执行路由逻辑的时候保持 `docs/swagger/abc.js`，如果设置了 true，就会重置 `:splat` 参数.
      3. web.WithCaseSensitive: 是否大小写敏感

```go
// 过滤器
func CheckAge(c *context.Context) {
	age, err := strconv.Atoi(c.Request.FormValue("age"))
	if err != nil {
		c.WriteString("参数有误,请重新输入")
		c.Output.SetStatus(400)
		return
	}
	if age < 18 {
		c.WriteString("未成年禁止登录")
		return
	}
}

// 注册过滤器
beego.InsertFilter("/user", beego.BeforeRouter, CheckAge)

// 路由注册
beego.Router("/user", &controllers.UserController{}, "post:Login")
```

![image-20240408224308381](https://cloud.006288.xyz/PicGo//image-20240408224308381.png)

##### 19.3.3.8 beego处理session

- beego 内置了 session 模块，目前 session 模块支持的后端引擎包括 memory、cookie、file、mysql、redis、couchbase、memcache、postgres，用户也可以根据相应的 interface 实现自己的引擎。

- **关于 Session 模块使用中的一些参数设置**

> 可以使用beego.BConfig.WebConfig.Session.xxxx修改,也可以写在配置文件中


```go
// beego.BConfig.WebConfig.Session.SessionOn
设置是否开启 Session，默认是 false，配置文件对应的参数名：sessionon。
  
// beego.BConfig.WebConfig.Session.SessionProvider
设置 Session 的引擎，默认是 memory，目前支持还有 file、mysql、redis 等，配置文件对应的参数名：sessionprovider。
  
// beego.BConfig.WebConfig.Session.SessionName
设置 cookies 的名字，Session 默认是保存在用户的浏览器 cookies 里面的，默认名是 beegosessionID，配置文件对应的参数名是：sessionname。
  
// beego.BConfig.WebConfig.Session.SessionGCMaxLifetime
设置 Session 过期的时间，默认值是 3600 秒，配置文件对应的参数：sessiongcmaxlifetime。
  
// beego.BConfig.WebConfig.Session.SessionProviderConfig
设置对应 file、mysql、redis 引擎的保存路径或者链接地址，默认值是空，配置文件对应的参数：sessionproviderconfig。
  
// beego.BConfig.WebConfig.Session.SessionHashFunc
默认值为 sha1，采用 sha1 加密算法生产 sessionid
  
// beego.BConfig.WebConfig.Session.SessionCookieLifeTime
设置 cookie 的过期时间，cookie 是用来存储保存在客户端的数据
```

- **session 有几个方便的方法：**

  - SetSession(name string, value interface{})
  - GetSession(name string) interface{}
  - DelSession(name string)
  - SessionRegenerateID()
  - DestroySession()

  > session 操作主要有设置 session、获取 session、删除 session

- 当然你可以通过下面的方式自己控制这些逻辑：

  ```
  sess:=this.StartSession()
  defer sess.SessionRelease()
  ```

  - sess 对象具有如下方法：

    - sess.Set()

    - sess.Get()

    - sess.Delete()

    - sess.SessionID()

    - sess.Flush()
  - 但是我还是建议大家采用 SetSession、GetSession、DelSession 三个方法来操作，避免自己在操作的过程中资源没释放的问题

  - **特别注意点**
    - 因为 session 内部采用了 gob 来注册存储的对象，例如 struct，所以如果你采用了非 memory 的引擎，请自己在 main.go 的 init 里面注册需要保存的这些结构体，不然会引起应用重启之后出现无法解析的错误

  > 从 beego1.1.3 版本开始移除了第三方依赖库,也就是如果你想使用 mysql、redis、couchbase、memcache、postgres 这些引擎,那么你首先需要安装

```go
func (c *MainController) Get() {
	// 设置模板参数
	c.Data["Website"] = "beego.vip"
	c.Data["Email"] = "astaxie@gmail.com"
	//读取session数据
	v := c.GetSession("count")
	if v == nil {
		//写入session数据
		c.SetSession("count", int(1))
		c.Data["num"] = 0
	} else {
		c.SetSession("count", v.(int) + 1)
		c.Data["num"] = v.(int)
	}
	// 需要渲染的模板，Beego会渲染这个模板然后返回结果
	c.TplName = "index.tpl"
}
```

> 其他存储引擎这里不再展开

##### 19.3.3.9 错误处理

- 如何中止此次请求并抛出异常，beego 可以在控制器中这样操作：
  - 这样 `this.Abort("401")` 之后的代码不会再执行，而且会显示给用户默认页面

```go
func (this *MainController) Get() {
	this.Abort("401")
	v := this.GetSession("asta")
	if v == nil {
		this.SetSession("asta", int(1))
		this.Data["Email"] = 0
	} else {
		this.SetSession("asta", v.(int)+1)
		this.Data["Email"] = v.(int)
	}
	this.TplName = "index.tpl"
}
```

- web 框架默认支持 401、403、404、500、503 这几种错误的处理。用户可以自定义相应的错误处理，例如下面重新定义 404 页面：

  ```go
  func page_not_found(rw http.ResponseWriter, r *http.Request){
  	t,_:= template.New("404.html").ParseFiles(web.BConfig.WebConfig.ViewsPath+"/404.html")
  	data :=make(map[string]interface{})
  	data["content"] = "page not found"
  	t.Execute(rw, data)
  }
  
  func main() {
  	web.ErrorHandler("404",page_not_found)
  	web.Router("/", &controllers.MainController{})
  	web.Run()
  }
  ```

  - 我们可以通过自定义错误页面 `404.html` 来处理 404 错误。

  - beego 更加人性化的还有一个设计就是支持用户自定义字符串错误类型处理函数，例如下面的代码，用户注册了一个数据库出错的处理页面：

  ```go
  func dbError(rw http.ResponseWriter, r *http.Request){
  	t,_:= template.New("dberror.html").ParseFiles(web.BConfig.WebConfig.ViewsPath+"/dberror.html")
  	data :=make(map[string]interface{})
  	data["content"] = "database is now down"
  	t.Execute(rw, data)
  }
  
  func main() {
  	web.ErrorHandler("dbError",dbError)
  	web.Router("/", &controllers.MainController{})
  	web.Run()
  }
  ```

  - 一旦在入口注册该错误处理代码，那么你可以在任何你的逻辑中遇到数据库错误调用 `this.Abort("dbError")` 来进行异常页面处理

- **Controller 定义 Error**

  - 从 1.4.3 版本开始，支持 Controller 方式定义 Error 错误处理函数，这样就可以充分利用系统自带的模板处理，以及 context 等方法

  ```go
  package controllers
  
  import (
  	"github.com/beego/beego/v2/server/web"
  )
  
  type ErrorController struct {
  	web.Controller
  }
  
  func (c *ErrorController) Error404() {
  	c.Data["content"] = "page not found"
  	c.TplName = "404.tpl"
  }
  
  func (c *ErrorController) Error501() {
  	c.Data["content"] = "server error"
  	c.TplName = "501.tpl"
  }
  
  
  func (c *ErrorController) ErrorDb() {
  	c.Data["content"] = "database is now down"
  	c.TplName = "dberror.tpl"
  }
  ```

  - 通过上面的例子我们可以看到，所有的函数都是有一定规律的，都是 `Error` 开头，后面的名字就是我们调用 `Abort` 的名字，例如 `Error404` 函数其实调用对应的就是 `Abort("404")`

  - 我们就只要在 `web.Run` 之前采用 `web.ErrorController` 注册这个错误处理函数就可以了

  ```go
  package main
  
  import (
  	_ "btest/routers"
  	"btest/controllers"
  
  	"github.com/beego/beego/v2/server/web"
  )
  
  func main() {
  	web.ErrorController(&controllers.ErrorController{})
  	web.Run()
  }
  ```

> beego框架我们并没有详细讲解,它的Models, ORM模型并没有展开详解,它在操作数据库时用的较多,需要的可以[参考文档学习](https://git-books.github.io/books/beego/?p=mvc/model/overview.md)

### 19.4 grpc框架

- gRPC是rpc框架中的一种，是一个高性能，开源和通用的RPC框架，基于Protobuf序列化协议开发，且支持众多开发语言。
- 面向服务端和协议端，基于http/2设计，带来诸如双向流，流控，头部压缩，单TCP连接上的多路复用请求等特性。这些特性使得其在移动设备上表现的更好，更省电和节省空间。
- 在gPRC里客户端可以向调用本地对象一样直接调用另一台不同机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。
- 与许多RPC系统类似，gRPC也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口。并运行一个gRPC服务器来处理客户端调用。在客户端拥有一个存根能够向服务端一样的方法

![image-20240414210409973](https://cloud.006288.xyz/PicGo//image-20240414210409973.png)

#### 19.4.1 安装grpc

- **安装protoc编译器**

  - 下载 protoc 编译器：[protobuf](https://github.com/protocolbuffers/protobuf/releases)，选择合适的平台，解压后将可执行文件加入环境变量，此编译器用来编译服务定义文件 .proto 生成指定语言的目标代码，这些代码用来实现 gRPC 服务以及客户端 stub

  ![image-20240414211843040](https://cloud.006288.xyz/PicGo//image-20240414211843040.png)

  - 配置环境变量

  ![image-20240414212428626](https://cloud.006288.xyz/PicGo//image-20240414212428626.png)

  - 验证是否安装成功

  ![image-20240414212516308](https://cloud.006288.xyz/PicGo//image-20240414212516308.png)



- **安装protoc-gen-go插件**

  - 这个插件用于将Protobuf文件编译一键生成 `_pb.go` 文件，对应内容为`通信请求/响应参数`的对象模型。它会将Protobuf文件中的消息类型、服务定义等转换为相应的Go语言结构体、方法等。生成的Go代码可以用于序列化和反序列化Protobuf消息，以及与其他语言的服务进行通信
  - 安装

  ```go
  go install google.golang.org/protobuf/cmd/protoc-gen-go@laste
  ```

  - `go install` 指令默认会将插件安装到 `$GOPATH/bin` 目录下. 需要确保 `$GOPATH/bin` 路径有被添加到环境路径 `$PATH` 当中.
  - 安装完成后，可以通过查看插件版本指令，校验安装是否成功

![image-20240414215258541](https://cloud.006288.xyz/PicGo//image-20240414215258541.png)

- **安装protoc-gen-go-grpc插件**

  - 这个插件是构建在`protoc-gen-go`之上的，它用于生成 `_grpc.pb.go`，对应内容为`通信服务框架`代码。它除了生成与`protoc-gen-go`相同的代码外，还生成了用于gRPC服务的客户端和服务器代码，包括接口定义、服务端实现、客户端Stub等
  - 安装

  ```go
  go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
  ```

  - 安装完成后，可以通过查看插件版本指令，校验安装是否成功

  ![image-20240414215335552](https://cloud.006288.xyz/PicGo//image-20240414215335552.png)

  

- **下载grpc库**

```go
go get -u google.golang.org/grpc
```

#### 19.4.2 编写proto文件

- proto 文件是 Google Protocol Buffers 的定义文件，用于描述数据结构和服务接口。它使用简单的语法来定义消息类型、字段、服务以及 RPC 方法，是定义通信协议的一种格式

- **Proto 文件的主要用途包括：**

  - **数据序列化和反序列化**：通过定义消息类型和字段，Proto 文件可以用于生成代码，实现数据的序列化和反序列化。这样，您可以将结构化数据转换为二进制格式进行传输，并在不同系统或语言之间进行通信。
  - **跨语言通信**：Proto 文件可以通过编译生成多种编程语言的代码，包括但不限于 C++, Java, Python, Go 等。这样，您可以在不同的语言中使用相同的数据结构和通信接口，实现跨语言的通信。
  - **定义服务接口**：Proto 文件可以定义服务及其 RPC 方法，描述了客户端和服务器之间的通信接口。这样，您可以基于这些定义生成客户端和服务器的代码，并实现远程过程调用（RPC）。

  总之，Proto 文件是定义通信协议的一种格式，通过它可以描述数据结构和服务接口，实现数据序列化、跨语言通信以及远程过程调用等功能

##### 19.4.2.1 proto文件基本语法

- [官方参考文档](https://protobuf.dev/reference/go/go-generated/)

- **文件规范**

  - 创建.proto文件时，文件命名应该使用全小写字母命名，多个字母之间用 **_** 连接。例如：`lower_snake_case.proto`
  - 书写.proto文件代码时，应使用2个空格的缩进
  - `;`：语句结束符

- **注释**

  - 使用 `//` 或者 `/**/` 进行注释

- **指定proto3语法**

  - 使用`syntax`关键字 在文件首行中指定该proto文件所采用的语法
  - ProtocolBuffers 语言版本3，简称 proto3，是 .proto 文件最新的语法版本。相较于proto2，语法更加简化，使用更加简单

  ```protobuf
  syntax = "proto3";
  ```

- **package申明符**

  - `package` 是一个可选的声明，用于指定生成的代码所属的包名
  - 在生成代码时，生成的 Go 文件将包含这个声明，并且其中的类型和方法将被放置在指定的包中

  ```protobuf
  package = grpcDemo
  ```

- **生成的代码包路径**

  - `option go_package` 是用于指定生成 Go 语言代码时的包路径（Package Path）的选项
  - 使用 Protocol Buffers 编译器（protoc）生成 Go 语言代码时，编译器将根据 .proto 文件的目录结构来确定生成的 Go 语言代码的包路径。但是，有时候您可能希望将生成的代码放置在与 .proto 文件所在的目录不同的地方，或者希望指定生成的 Go 语言代码的包名称。这时，您就可以使用 `option go_package` 来指定生成的 Go 语言代码的包路径

  ```go
  option go_package = "存放路径";"别名";
  ```

- **定义消息类型（Message Types）**

  - 消息（message）就是要定义的结构化对象，我们可以给这个结构化对象中定义其对应的消息字段

  > 可以理解为go语言的结构体

  - 消息字段的格式定义为：类型 字段名 = 唯一编号
    - 字段名称命名规范：全小写字母，多个字母之间用 **_** 连接。
    - 字段类型分为：标量数据类型和特殊类型（包括枚举、其他消息类型等）。
    - 字段唯一编号：用来标识字段，一旦开始使用就不能够再改变

   ```protobuf
   message UserRequest {
     string name = 1;    // 这个数字是字段唯一编号：用来标识字段，一旦开始使用就不能够再改变
     int64 age = 2;
     string addr = 3;
   
     // 切片
     repeated string subject = 4;
   
     // 字典
     map <string, float> score = 5;  // 字典的key,只能是int或者string
   
     // 枚举
     enum prize {
       stage1 = 0;
       stage2 = 1;
       stage3 = 2;
     }
   
     // 保留关键字
     reserved "phone";
   }
   ```

> - 不同语言数据类型proto[映射关系参考](https://protobuf.dev/programming-guides/proto3/#scalar)
> - 保留关键字: 当我们想要保留某个关键字不被使用,可以使用reserved关键字标识,如果有人使用这个关键字编译器就会报错

> - 唯一编号用于唯一的标识每一个字段，在解析和序列化的时候可以准确快速的定位到每个字段的位置和大小
> - 编号的范围为1 ~ 536,870,911(2^29-1)，其中19000~19999不可用。因为Protobuf协议的实现过程中对预留了这些编号范围为1 ~ 15的字段编号需要一个字节进行编码，16~2047内的数字需要两个字节进行编码。
> - 编码后的字节不仅只包含了编号，还包含了字段类型。所以1~15要用来标记出现非常频繁的字段，要为将来有可能添加的、频繁出现的字段预留一些出来

- **定义服务（Services）**
  - 关键字 `service` 用于定义服务，后面跟着服务的名称 `ServiceName`，花括号 `{}` 内部定义服务的 RPC 方法。
    - `rpc` 关键字表示定义一个 RPC 方法。
    - 方法的名称 `MethodName`，是该 RPC 方法的标识符。
    - 括号 `()` 内包含了方法的请求类型 `RequestType`，即客户端发送给服务器的消息类型。
    - `returns` 关键字后跟着返回类型 `ResponseType`，表示服务器响应给客户端的消息类型

```protobuf
service MyService {
  rpc MyMethod(MyRequest) returns (MyResponse)
}
```

- gRPC允许四种定义服务的方法
  - **一元 RPC**：
    - 一元 RPC 是最常见的一种 RPC 方法。在一元 RPC 中，客户端发送单个请求并等待单个响应。这种方法类似于传统的函数调用，客户端发送请求后会阻塞等待响应。
  - **服务器流式 RPC**：
    - 服务器流式 RPC 允许客户端发送单个请求，然后服务器返回一个流，用于生成多个响应。客户端可以从该流中读取服务器发送的响应。
  - **客户端流式 RPC**：
    - 客户端流式 RPC 允许客户端通过流式方式发送多个请求给服务器，并等待单个响应。服务器接收来自客户端的请求流，然后发送单个响应。
  - **双向流式 RPC**：
    - 双向流式 RPC 允许客户端和服务器之间建立一个双向的流，双方可以独立地向对方发送一系列消息。客户端和服务器可以同时读取和写入流中的消息

```protobuf
service Calculator {
  // 一元 RPC
  rpc UnaryOperation(UnaryRequest) returns (UnaryResponse) {};  // 传统及时响应

  // 服务器流式 RPC
  rpc ServerStreamingOperation(ServerStreamingRequest) returns (stream ServerStreamingResponse) {}; // 出参为流

  // 客户端流式 RPC
  rpc ClientStreamingOperation(stream ClientStreamingRequest) returns (ClientStreamingResponse)  {}; // 入参为流

  // 双向流式 RPC
  rpc BidirectionalStreamingOperation(stream BidirectionalStreamingRequest) returns (stream BidirectionalStreamingResponse) {}; // 出入都为流
}
```

- protoc常见命令
  - `--proto_path=PATH`：指定搜索 Proto 文件的路径。可以指定多个路径，用逗号分隔。
  - `--go_out=PATH`：生成 Go 语言代码，并指定输出路径。
  - `--go-grpc_out=PATH`：生成支持 gRPC 的 Go 语言代码，并指定输出路径。
  - `--grpc_out=PATH`：生成 gRPC 的代码，并指定输出路径。
  - `--plugin=PLUGIN_PATH`：指定使用的插件，例如 `--plugin=protoc-gen-go=/path/to/protoc-gen-go`

##### 19.4.2.2 编译proto文件

```protobuf
syntax = "proto3";

package GrpcDemo;

option go_package = "../grpcServer";

message UserRequest {
  string name = 1;
  int64 age = 2;
  string addr = 3;
}

message UserResponse {
  string userinfo = 1;
}

service GrpcService {
  // 一元rpc
  rpc Getinfo(UserRequest) returns (UserResponse) {};
  // 服务端流式rpc
  rpc Getinfo2(UserRequest) returns (stream UserResponse) {};
  // 客户端流式rpc
  rpc Getinfo3(stream UserRequest) returns (UserResponse) {};
  // 双向流式rpc
  rpc Getinfo4(stream UserRequest) returns (stream UserResponse) {};
}
```

- 编译proto文件

```go
protoc --go_out=../grpcServer --go-grpc_out=../grpcServer demo.proto
```

#### 19.4.3 服务端代码

```go
package main

import (
	"context"
	"fmt"
	"google.golang.org/grpc"
	"grpcStuday/grpcServer"
	"io"
	"log"
	"net"
	"sync"
	"time"
)

type GrpcServer struct {
	grpcServer.UnimplementedGrpcServiceServer
}

func (GrpcServer) Getinfo(ctx context.Context, req *grpcServer.UserRequest) (*grpcServer.UserResponse, error) {
	name := req.GetName()
	fmt.Println("收到客户端请求信息: ", req)
	return &grpcServer.UserResponse{Userinfo: "收到了" + name + "的请求"}, nil
}

func (GrpcServer) Getinfo2(req *grpcServer.UserRequest, srv grpcServer.GrpcService_Getinfo2Server) error {
	name := req.GetName()
	fmt.Println("收到客户端请求信息: ", req)
	for i := 0; i < 10; i++ {
		time.Sleep(time.Second * 1)
		if err := srv.Send(&grpcServer.UserResponse{Userinfo: "收到了" + name + "的请求"}); err != nil {
			log.Println("响应失败")
		}
	}
	return nil
}
func (GrpcServer) Getinfo3(srv grpcServer.GrpcService_Getinfo3Server) error {
	for {
		req, err := srv.Recv()
		if err != nil {
			if err == io.EOF {
				log.Println("客户端传输完毕")
				return srv.SendAndClose(&grpcServer.UserResponse{Userinfo: "收到你发送的信息流了"})
			} else {
				log.Println("接收客户端请求出错了", err)
				return err
			}
		}
		fmt.Println("收到客户端请求: ", req)
	}

}
func (GrpcServer) Getinfo4(srv grpcServer.GrpcService_Getinfo4Server) error {
	messageChan := make(chan string)

	wg := sync.WaitGroup{}
	wg.Add(2)

	go func() {
		defer wg.Done()
		for {
			req, err := srv.Recv()
			if err != nil {
				if err == io.EOF {
					close(messageChan)
					break
				}
				log.Println(err)
				break
			}
			fmt.Println("收到客户端请求信息: ", req)
			messageChan <- req.Name
		}
	}()

	go func() {
		defer wg.Done()
		for message := range messageChan {
			srv.Send(&grpcServer.UserResponse{Userinfo: "收到" + message + "的请求信息"})
		}
	}()

	wg.Wait()
	return nil
}

func main() {
	// 创建监听
	listen, err := net.Listen("tcp", ":9999")
	if err != nil {
		log.Println("监听失败", err)
		return
	}
	// 创建grpc服务
	gsrv := grpc.NewServer()
	// 注册服务
	grpcServer.RegisterGrpcServiceServer(gsrv, GrpcServer{})
	// 启动服务
	gsrv.Serve(listen)
}
```

#### 19.4.4 客户端代码

```go
package main

import (
	"context"
	"fmt"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"grpcStuday/grpcServer"
	"io"
	"log"
	"sync"
	"time"
)

func getinfo_client(client grpcServer.GrpcServiceClient) {
	res, err := client.Getinfo(context.Background(), &grpcServer.UserRequest{Name: "kuebi", Age: 24, Addr: "shanghai"})
	if err != nil {
		log.Println("远程调用失败: ", err)
		return
	}
	fmt.Println("收到服务端响应的信息: ", res)
}

func getinfo2_client(client grpcServer.GrpcServiceClient) {
	srv, err := client.Getinfo2(context.Background(), &grpcServer.UserRequest{Name: "kuebi", Age: 24, Addr: "shanghai"})
	if err != nil {
		log.Println("远程调用失败", err)
		return
	}

	for {
		res, err := srv.Recv()
		if err != nil {
			if err == io.EOF {
				fmt.Println("服务端响应完毕")
				return
			}
		}
		fmt.Println("收到服务端响应信息: ", res)
	}
}

func getinfo3_client(client grpcServer.GrpcServiceClient) {
	srv, err := client.Getinfo3(context.Background())
	if err != nil {
		log.Println("远程调用失败", err)
		return
	}

	for i := 0; i < 10; i++ {
		time.Sleep(time.Second * 1)
		if err := srv.Send(&grpcServer.UserRequest{Name: "kuebi", Age: 24, Addr: "shanghai"}); err != nil {
			log.Println("客户端请求发送失败", err)
		}
	}
	res, err := srv.CloseAndRecv()
	if err != nil {
		log.Println("服务端信息出错", err)
		return
	}
	fmt.Println("收到服务端响应信息: ", res)
}

func getinfo4_client(client grpcServer.GrpcServiceClient) {
	srv, err := client.Getinfo4(context.Background())
	if err != nil {
		log.Println("远程调用失败", err)
		return
	}

	wg := sync.WaitGroup{}
	wg.Add(2)

	go func() {
		defer wg.Done()
		defer srv.CloseSend()
		for i := 0; i < 10; i++ {
			time.Sleep(time.Second * 1)
			if err := srv.Send(&grpcServer.UserRequest{Name: "kuebi", Age: 24, Addr: "shanghai"}); err != nil {
				log.Println("客户端请求发送失败", err)
				return
			}
		}
	}()

	go func() {
		defer wg.Done()
		defer srv.CloseSend() // 在接收到io.EOF错误后关闭流
		for {
			res, err := srv.Recv()
			if err != nil {
				if err == io.EOF {
					log.Println("服务端信息响应完毕", err)
					return
				}
				log.Println("服务端信息响应失败", err)
				return
			}
			fmt.Println("收到服务端响应的信息: ", res)
		}
	}()

	wg.Wait()
}

func main() {
	l, err := grpc.Dial("localhost:9999", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Println("连接失败", err)
		return
	}
	defer l.Close()
	client := grpcServer.NewGrpcServiceClient(l)

	// 一元rpc
	fmt.Println("########################### 一元rpc ##########################")
	getinfo_client(client)

	// 服务端流式rpc
	fmt.Println("########################### 服务端流式rpc ##########################")
	getinfo2_client(client)

	// 客户端流式rpc
	fmt.Println("########################### 客户端流式rpc ##########################")
	getinfo3_client(client)

	// 双向流式rpc
	fmt.Println("########################### 双向流式rpc ##########################")
	getinfo4_client(client)
}
```

#### 19.4.5 grpc超时设置

- gRPC默认的请求的超时时间是很长的，当你没有设置请求超时时间时，所有在运行的请求都占用大量资源且可能运行很长的时间，导致服务资源损耗过高，使得后来的请求响应过慢，甚至会引起整个进程崩溃。
- 综上，一个合理的超时时间是非常必要的。在一些要求更高的服务中，我们还需要针对DNS解析、连接建立，读、写等设置更精细的超时时间。除了设置静态的超时时间，根据当前系统状态、服务链路等设置自适应的动态超时时间也是服务治理中一个常见的方案

##### 19.4.5.1 客户端的超时

> - context.WithDeadline：会返回最终上下文截止时间。第一个形参为父上下文，第二个形参为调整的截止时间。若父级时间早于子级时间，则以父级时间为准，否则以子级时间为最终截止时间
> - context.WithTimeout：很常见的另外一个方法，是便捷操作。实际上是对于 WithDeadline 的封装
>
> 
>
> - `ctx.Err()` 用于检查 `context.Context` 中的错误，主要用于判断上下文是否已经超时或取消。它返回的是一个普通的错误值，通常情况下，当调用超时时，返回的是 `context.DeadlineExceeded` 错误。`ctx.Err()` 并不直接将错误转换为 gRPC 的状态码，而是提供了一个基础的错误判断机制
> - `status.FromError()` 用于将错误转换为 gRPC 的状态码，主要用于统一错误处理逻辑和向客户端返回标准的 gRPC 错误。它接收一个错误值作为参数，并返回相应的 gRPC 状态码和错误消息, 如果传入的错误不是 gRPC 错误，则返回的状态码为 `codes.Unknown`

- **客户端连接超时**
  - grpc默认会异步创建连接，如果连接没有创建成功会在下面的RPC调用中报错, 并不会阻塞在Dial或DialContext这里
  - 如果我们想控制连接创建时的超时时间该怎么做呢？
    - 异步转成同步：首先我们需要使用`grpc.WithBlock()`这个选项让连接的创建变为阻塞式的
    - 超时时间：使用`grpc.DialContext()`以及Go中`context.Context`来控制超时时间

```go
	// 设置连接超时时间
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)
	defer cancel()

	l, err := grpc.DialContext(ctx, "localhost:8888", grpc.WithBlock(), grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		if ctx.Err() == context.DeadlineExceeded {
			log.Println("连接超时", err)
			return
		}
		log.Println("连接失败", err)
		return
	}
	defer l.Close()
	client := grpcServer.NewGrpcServiceClient(l)
```

- **客户端请求超时**

  - 和上面连接超时的配置类似。无论是`普通RPC`还是`流式RPC`，服务调用的第一个参数均是`context.Context`,  所以可以使用`context.Context`来控制服务调用的超时时间

  ```go
  // 设置超时时间
  ctx, cancel := context.WithTimeout(context.Background(), time.Second*1)
  defer cancel()
  
  func getinfo_client(client grpcServer.GrpcServiceClient, ctx context.Context) {
  	res, err := client.Getinfo(ctx, &grpcServer.UserRequest{Name: "kuebi", Age: 24, Addr: "shanghai"})
  	if err != nil {
  		// 方便快捷直接使用ctx.Err判断
  		//if ctx.Err() == context.DeadlineExceeded {
  		//	log.Println("远程调用超时", err)
  		//	return
  		//}
  
  		// 使用status判断
  		st, ok := status.FromError(err)
  		if ok && st.Code() == codes.DeadlineExceeded {
  			log.Println("远程调用超时", err)
  			return
  		}
  
  		log.Println("远程调用失败: ", err)
  		return
  	}
  	fmt.Println("收到服务端响应的信息: ", res)
  }
  ```

##### 19.4.5.2 服务端的超时

- **服务端连接超时控制**

  - 服务端也可以控制连接创建的超时时间，如果在设定的时间内没有建立的连接，服务端就会主动断连，避免浪费服务端的端口、内存等资源
  - 具体来说，当客户端尝试连接到 gRPC 服务器时，服务器会等待一个最大时间，超过这个时间客户端仍未成功建立连接，则服务器将不再等待，而是关闭连接并返回错误给客户端。这样可以避免服务器无限期地等待连接请求，从而有效地控制连接超时

  - 以下是在 gRPC 服务端设置连接超时的一般步骤：
    - **在 gRPC 服务器配置中设置连接超时**：您可以在创建 gRPC 服务器时通过设置 `grpc.ServerOption` 来配置连接超时。一种常见的选项是 `grpc.ConnectionTimeout`，它定义了客户端连接的最大等待时间
    - **处理连接超时错误**：一旦设置了连接超时，您需要相应地处理连接超时错误。这通常包括在处理连接请求之前检查超时，并在超时时返回适当的错误响应

```go
// 创建 gRPC 服务器，并设置连接超时为5秒
    s := grpc.NewServer(
        grpc.ConnectionTimeout(5 * time.Second), // 设置连接超时为5秒
    )
```

- **服务端处理超时时间控制**
  - 服务实现函数的第一个参数也是`context.Context`，所以我们可以在一些耗时操作前对`context.Context`进行判断：如果已经超时了，就没必要继续往下执行了。此时客户端也会收到上文提到过的超时`error`

```go
func (GrpcServer) Getinfo4(ctx context.Context, req *grpcServer.UserRequest) (*grpcServer.UserResponse, error) {
    // 设置处理超时为10秒
    ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()

    // 检查超时
    select {
    case <-ctx.Done():
        // 已经超时，返回超时错误给客户端
        return nil, status.Errorf(codes.DeadlineExceeded, "处理超时")
    default:
        // 没有超时，继续处理逻辑
    }

    // 实际处理逻辑
}
```

- 服务端检测客户端
  - 由于 Client 已经设置了截止时间。Server 势必要去检测它, 否则如果 Client 已经结束掉了，Server 还傻傻的在那执行，这对资源是一种极大的浪费,  因此在这里需要用 `ctx.Err()==context.Canceled` 进行判断

```go
// 服务端
func (GrpcServer) Getinfo(ctx context.Context, req *grpcServer.UserRequest) (*grpcServer.UserResponse, error) {
	for i := 0; i < 5; i++ {
		select {
		case <-ctx.Done():
			log.Println("客户端取消请求,程序终止")
			return nil, ctx.Err()
		default:
			time.Sleep(1 * time.Second)
		}
	}
	return &grpcServer.UserResponse{Userinfo: "收到信息"}, nil
}



// 客户端
func getinfo_client(client grpcServer.GrpcServiceClient, ctx context.Context) {
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()

	res, err := client.Getinfo(ctx, &grpcServer.UserRequest{Name: "kuebi", Age: 24, Addr: "shanghai"})
	if err != nil {
		if status.Code(err) == codes.Canceled {
			log.Println("远程调用取消:", err)
			return
		}
		if ctx.Err() == context.DeadlineExceeded {
			log.Println("远程调用超时", err)
			return
		}
		log.Println("远程调用失败: ", err)
		return
	}
	fmt.Println("收到服务端响应的信息: ", res)
}
```

#### 19.4.6 grpc安全传输

-  gRPC 底层是基于 HTTP/2 协议的，HTTP 本身不带任何加密传输功能，基于 SSL 的 HTTPS 协议才是加密传输。gRPC 使用了 HTTP/2 协议但是并未使用 HTTPS，即少了加密传输的部分,数据都是明文传输的,在生产环境是绝对不允许这样的,这样数据很容易被篡改, 我们可以通过抓包来验证数据是否是明文传输

![image-20240421114401011](https://cloud.006288.xyz/PicGo//image-20240421114401011.png)

- 对于加密传输 gRPC 将它抽出来作为一个组件，可以由用户自由选择。gRPC 内默认提供了两种内置的认证方式：
  1. 基于 CA 证书的 SSL/TLS 认证方式；
  2. 基于 Token 的认证方式。

- 同时也提供了可扩展的用户自定义认证方式

##### 19.4.6.1 基于 CA 证书的 SSL/TLS 认证方式

- **生成CA证书**

  - 创建一个秘钥，这个便是CA证书的根本，之后所有的东西都来自这个秘钥

  ```shell
  # 通过rsa算法生成2048位长度的秘钥
  openssl genrsa -out ca.key 2048
  ```

  - 使用 CSR 创建一个自签名的根证书（CA证书）

  ```shell
  # 证书包含了机构信息，在输入下面的指令之后会有一系列的信息输入，
  # 这些信息便是机构信息，公司名称地址什么的
  # 这里还有一个过期信息，CA证书也会过期，openssl默认是一个月，这里设置为10年
  # 证书通常使用 ".crt" 或 ".cer" 扩展名
  openssl req -x509 -new -nodes -key ca.key -sha256 -days 36500 -out ca.crt
  ```

  > 如果存在csr使用下面命令签发:
  >
  > openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
  >
  > - `-req`：表示处理证书签署请求。
  > - `-in ca.csr`：指定输入的 CSR 文件。
  > - `-signkey ca.key`：指定用于签署 CSR 的私钥文件。
  > - `-out ca.crt`：指定输出的证书文件名。
  >
  > 这个命令是用于使用已有的 CSR 来签署证书。通常，CSR 是由私钥生成的，然后发送到 CA 进行签署。这个过程可以分为两步：首先生成 CSR，然后使用 CSR 生成 CA 证书

  ![image-20240421121121386](https://cloud.006288.xyz/PicGo//image-20240421121121386.png)

  - 生成证书签署请求文件ca.csr (非必须)

  ```go
  openssl req -new -key ca.key -out ca.csr
  ```

- 生成服务端证书

  > 在得到CA证书之后，需要通过 `openssl`工具对证书进行转换得到公钥（ `.crt文件`）和密钥（ `.key文件`），无论CA证书是怎么来的到这里之后就没有任何区别了，服务器证书的制作流程相较CA证书要复杂一点点

  - 生成证书私钥

  ```shell
  # 通过RSA算法生成长度2048位的秘钥
  openssl genpkey -algorithm RSA -out server.key
  ```

  - 通过私钥生成证书请求文件csr

  ```shell
  openssl req -new -nodes -key server.key -out server.csr -days 3650 -subj "/C=cn/OU=shanghai/O=pudongxinqu/CN=*kubei.com" -config ./openssl.cfg -extensions v3_req
  
  # 这里用到了openssl的配置文件,我们需要将openssl的配置文件cfg拷贝一份到项目目录,然后修改它:
  # 找到[ CA_default ]中的copy_extensions = copy,将注释删除
  # 找到[ req ]中req_extensions = v3_req, 将注释删除
  # 找到[ v3_req ],添加subjectAltName = @alt_names
  # 添加新的标签[ alt_names ]和标签字段
  DNS.1 = *.kubei.com
  ```

  - 生成SAN证书pem

  ```shell
  openssl x509 -req -days 365 -in server.csr -out server.pem -CA ca.crt -CAkey ca.key -CAcreateserial -extfile ./openssl.cfg -extensions v3_req
  ```

![image-20240421134120595](https://cloud.006288.xyz/PicGo//image-20240421134120595.png)

- grpc服务端TLS配置
  - 加载证书和私钥,构造TLS凭证
  - 配置监听器

```go
func main() {
	// 构造TLS凭证
	credns, err := credentials.NewServerTLSFromFile("E:\\GoCode\\grpcStuday\\key\\server.pem", "E:\\GoCode\\grpcStuday\\key\\server.key")
	if err != nil {
		log.Fatalf("failed to load server certificates: %v", err)
	}
	
	// 创建监听
	listen, err := net.Listen("tcp", ":9999")
	if err != nil {
		log.Println("监听失败", err)
		return
	}
	// 创建grpc服务
	gsrv := grpc.NewServer(
		// 配置监听器
		grpc.Creds(credns),
		
		// 设置连接超时时间
		grpc.ConnectionTimeout(time.Second * 5),
	)

	// 注册服务
	grpcServer.RegisterGrpcServiceServer(gsrv, GrpcServer{})
	// 启动服务
	gsrv.Serve(listen)
}
```

- grpc客户端TLS配置
  - 1）`NewClientTLSFromFile` 指定使用**CA 根证书**来校验服务端的证书有效性。
    - 注意：第二个参数域名就是服务端证书时的 CN 参数
  - 2）建立连接时 指定建立安全连接`WithTransportCredentials`

```go
func main() {
    // 构造TLS凭证
	credens, err := credentials.NewClientTLSFromFile("E:\\GoCode\\grpcStuday\\key\\server.pem", "*.kubei.com")
	if err != nil {
		log.Fatalf("failed to load client certificates: %v", err)
	}

	// 设置连接超时时间
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*10)
	defer cancel()

	// 建立连接
	l, err := grpc.DialContext(ctx, "localhost:9999", grpc.WithBlock(), grpc.WithTransportCredentials(credens))
	if err != nil {
		if ctx.Err() == context.DeadlineExceeded {
			log.Println("连接超时", err)
			return
		}
		log.Println("连接失败", err)
		return
	}
	defer l.Close()
	client := grpcServer.NewGrpcServiceClient(l)

	// 一元rpc
	//fmt.Println("########################### 一元rpc ##########################")
	getinfo_client(client, ctx)
}
```

- 测试

![image-20240421140353692](https://cloud.006288.xyz/PicGo//image-20240421140353692.png)

##### 19.4.6.2 基于 Token 的认证方式

- 在前面的章节，我们通过 TLS 证书的方式对通信数据进行了加密。另外，我们还可以给 RPC 方法添加自定义的验证方法，使得数据更加安全。这篇文章我们就以 Token 认证为例，介绍 gRPC 如何添加自定义验证方法

- **自定义认证**

  - gRPC 官方默认提供了用于自定义认证的接口，作用是将所需的安全认证信息添加到 RPC 方法的上下中

  ```go
  type PerRPCCredentials interface {
   GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
   RequireTransportSecurity() bool
  }
  
  // GetRequestMetadata() 获取当前请求认证所需的元数据；
  // RequireTransportSecurity() 是否需要基于 TLS 认证进行安全传输
  ```

- 服务端配置

```go
func (GrpcServer) Getinfo(ctx context.Context, req *grpcServer.UserRequest) (*grpcServer.UserResponse, error) {
	// 从上文中获取元数据
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, status.Errorf(codes.Unauthenticated, "获取token失败")
	}

	var (
		appid     string
		appsecret string
	)

	if value, ok := md["app_id"]; ok {
		appid = value[0]
	}

	if value, ok := md["app_secret"]; ok {
		appsecret = value[0]
	}

	// 验证token
	if appid != "kubei" || appsecret != "zxcvbnmQAZ123" {
		return nil, status.Errorf(codes.Unauthenticated, "tokent验证失败")
	}

	for i := 0; i < 5; i++ {
		select {
		case <-ctx.Done():
			log.Println("客户端取消请求,程序终止")
			return nil, ctx.Err()
		default:
			time.Sleep(1 * time.Second)
		}
	}
	return &grpcServer.UserResponse{Userinfo: "收到信息"}, nil
}

func main() {
	// 创建监听
	listen, err := net.Listen("tcp", ":9999")
	if err != nil {
		log.Println("监听失败", err)
		return
	}
	// 创建grpc服务
	gsrv := grpc.NewServer(
		// 设置连接超时时间
		grpc.ConnectionTimeout(time.Second*5),
	)

	// 注册服务
	grpcServer.RegisterGrpcServiceServer(gsrv, GrpcServer{})
	// 启动服务
	gsrv.Serve(listen)
}
```

- 客户端配置

```go
type MyToken struct {
	AppID     string
	AppSecret string
}

type PerRPCCredentials interface {
	GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
	RequireTransportSecurity() bool
}

// 实现PerRPCCredentials接口
func (t *MyToken) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{"app_id": t.AppID, "app_secret": t.AppSecret}, nil
}

// 实现PerRPCCredentials接口
func (t *MyToken) RequireTransportSecurity() bool {
	return false
}



func main() {
	//credens, err := credentials.NewClientTLSFromFile("E:\\GoCode\\grpcStuday\\key\\server.pem", "*.kubei.net")
	//if err != nil {
	//	log.Fatalf("failed to load client certificates: %v", err)
	//}

	// 实例化mytoken
	mytoken := MyToken{AppID: "kubei", AppSecret: "zxcvbnmQAZ123"}

	opts := []grpc.DialOption{
		grpc.WithPerRPCCredentials(&mytoken),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	}

	// 建立连接
	l, err := grpc.DialContext(context.Background(), "localhost:9999", opts...)
	if err != nil {
		log.Println("连接失败", err)
		return
	}
	defer l.Close()
	client := grpcServer.NewGrpcServiceClient(l)

	// 一元rpc
	//fmt.Println("########################### 一元rpc ##########################")
	getinfo_client(client)
}
```

- 测试

![image-20240421144431048](https://cloud.006288.xyz/PicGo//image-20240421144431048.png)

#### 19.4.7 grpc拦截器

- 实际业务中有很多rpc方法,我们不能每个方法中都去添加一段token验证,这样代码冗余太高,我们可以将token验证单独拆分出去,做成一个公共方法,每次请求进来都会先进行token验证,通过后才调用函数执行, 这样的行为就叫拦截器
- 在 gRPC 中，拦截器（Interceptors）是一种强大的机制，可以用于在 gRPC 调用的生命周期中进行拦截和处理。拦截器可以用于实现各种功能，例如身份验证、日志记录、性能监控等

- 拦截器类型
  1. UnaryServerInterceptor 服务端拦截，在服务端接收请求的时候进行拦截。
  2. UnaryClientInterceptor 这是一个客户端上的拦截器，在客户端真正发起调用之前，进行拦截。
  3. StreamClientInterceptor 在流式客户端调用时，通过拦截 clientstream 的创建，返回一个自定义的 clientstream, 可以做一些额外的操作。
  4. StreamServerInterceptor 在服务端接收到流式请求的时候进行拦截

##### 19.4.7.1 服务端拦截器

- 服务端的拦截器从请求开始按顺序执行拦截器，在执行完对应RPC的逻辑之后，再按反向的顺序执行拦截器中对响应的处理逻辑

![image-20240421214135082](https://cloud.006288.xyz/PicGo//image-20240421214135082.png)

- **一元拦截器**

  - 服务器端一元拦截器会拦截 gRPC 服务器所处理的所有一元 RPC ，如果想在服务器端拦截 gRPC 服务的一元 RPC，需要为 gRPC 服务器端实现一元拦截器。
  - 首先要实现 UnaryServerInterceptor 类型的函数，并在创建 gRPC 服务器端时将函数注册进来，该函数是用于服务器端一元拦截器的类型，它具有以下签名：

  ```go
  func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)
  
  // ctx context.Context：单个请求的上下文
  // req interface{}：RPC服务的请求结构体
  // info *UnaryServerInfo：RPC的服务信息
  // handler UnaryHandler：它包装了服务实现，通过调用它我们可以完成RPC并获取到响应
  ```

  - 它本质是一个方法，拦截器的应用是在服务端启动的时候要注册上去，从 `grpc.NewServer(opts...)` 这里开始，这里需要一个 ServerOption 对象：

  ```go
  //注册拦截器 创建gRPC服务器
  s := grpc.NewServer(grpc.UnaryInterceptor("拦截器"))  
  ```

  - 服务器端一元拦截器的实现通常可以分为以下的前置处理、调用 RPC 方法以及后置处理三个阶段：

    - 前置处理阶段。在前置处理阶段，在调用预期的 RPC 远程方法之前执行，用户可以通过检查传入的参数来获取关于当前 RPC 的信息，比如 RPC 上下文、RPC 请求和服务器端信息，甚至可以在预处理阶段修改 RPC ；

    - 调用阶段。在这个阶段中，需要调用 gRPC UnaryHandler 来触发 RPC 方法，在调用 RPC 之后，就进入后置处理阶段。这意味着，RPC 响应要流经后置处理阶段；

    - 后置阶段。在这个阶段中，可以按需处理返回的响应和错误。当后置处理阶段完成之后，需要以拦截器函数返回参数的形式将消息和错误返回。如果不需要后置处理器，那么可以直接返回 handler 调用（handler(ctx, req)) 

  ```go
  // 编写拦截器
  
  func check_token(ctx context.Context) (bool, error) {
  	// 从上文中获取元数据
  	md, ok := metadata.FromIncomingContext(ctx)
  	if !ok {
  		return false, status.Errorf(codes.Unauthenticated, "获取token失败")
  	}
  
  	var (
  		appid     string
  		appsecret string
  	)
  
  	if value, ok := md["app_id"]; ok {
  		appid = value[0]
  	}
  
  	if value, ok := md["app_secret"]; ok {
  		appsecret = value[0]
  	}
  
  	// 验证token
  	if appid != "kubei" || appsecret != "zxcvbnmQAZ123" {
  		return false, status.Errorf(codes.Unauthenticated, "tokent验证失败")
  	}
  	return true, nil
  }
  
  func orderUnaryServerInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
  	// 在处理请求之前执行的代码
  	log.Println("Received request for method:", info.FullMethod) // 打印请求方法
  	ok, err := check_token(ctx)
  	if !ok {
  		return nil, err
  	}
  
  	// 调用下一个拦截器或处理器
  	resp, err := handler(ctx, req)
  
  	// 在处理请求之后执行的代码
  	log.Println("Finished processing request for method:", info.FullMethod)
  
  	return resp, nil
  
  }
  
  // 注册拦截器
  func main() {
  	// 创建监听
  	listen, err := net.Listen("tcp", ":9999")
  	if err != nil {
  		log.Println("监听失败", err)
  		return
  	}
  	// 创建grpc服务
  	gsrv := grpc.NewServer(
          // 注册拦截器
  		grpc.UnaryInterceptor(orderUnaryServerInterceptor),
  	)
  
  	// 注册服务
  	grpcServer.RegisterGrpcServiceServer(gsrv, GrpcServer{})
  	// 启动服务
  	gsrv.Serve(listen)
  }
  ```

  

- **流式拦截器**

  - 服务器端流拦截器会拦截 gRPC 服务器所处理的所有流 RPC ，如果想在服务器端拦截 gRPC 服务的流式 RPC，需要为 gRPC 服务器端实现流拦截器。首先要实现 StreamServerInterceptor 类型的函数，并在创建 gRPC 服务器端时将函数注册进来，该函数是用于服务器端一元拦截器的类型，它具有以下签名：

  ```go
  func(srv interface{}, ss ServerStream, info *StreamServerInfo, handler StreamHandler) error
  
  // srv interface{}：服务实现
  // ss ServerStream：服务端视角的流。怎么理解呢？无论是哪一种流式RPC对于服务端来说发送（SendMsg）就代表着响应数据，接收（RecvMsg）就代表着请求数据，不同的流式RPC的区别就在于是多次发送数据（服务器端流式 RPC）还是多次接收数据（客户端流式 RPC）或者两者均有（双向流式 RPC）。因此仅使用这一个抽象就代表了所有的流式RPC场景
  // info *StreamServerInfo：RPC的服务信息
  // handler StreamHandler：它包装了服务实现，通过调用它我们可以完成RPC
  ```

  - 若要为服务端安装流拦截器，请使用 StreamInterceptor 中的 ServerOption 来配置 NewServer 。
  - 流拦截器分为以下的前置处理阶段和流操作拦截阶段：
    - 前置处理阶段。与一元拦截器类似，在前置处理阶段，可以在流 RPC 进入服务实现之前对其进行拦截。
    - 流操作拦截阶段。在前置处理阶段之后，则可以调用 StreamHandler 来完成远程方法的 RPC 执行，而且通过已实现 grpc.ServerStream 接口的包装器流接口，可以拦截流 RPC 的消息。在通过 handler(srv, newWrappedStream(ss)) 方法调用 grpc.StreamHandler 时，可以将这个包装器结构传递进来。grpc.ServerStream 的包装器可以拦截 gRPC 服务发送或接收到的数据，它实现了 SendMsg 函数和 RecvMsg 函数，这两个函数分别会在服务发送和接收 RPC 流消息的时候被调用

  ```go
  // 编写流式拦截器
  func StreamingInterceptor(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
  	// 在处理流式调用之前执行的代码
  	log.Println("Received stream request for method:", info.FullMethod)
  	// 从上下文中获取请求数据
  	ctx := ss.Context()
  	ok, err := check_token(ctx)
  	if !ok {
  		return err
  	}
  
  	// 调用下一个拦截器或处理器
  	err = handler(srv, ss)
  
  	// 在处理流式调用之后执行的代码
  	log.Println("Finished processing stream request for method:", info.FullMethod)
  
  	return err
  
  }
  
  
  
  func main() {
  	// 创建监听
  	listen, err := net.Listen("tcp", ":9999")
  	if err != nil {
  		log.Println("监听失败", err)
  		return
  	}
  	// 创建grpc服务
  	gsrv := grpc.NewServer(
  		grpc.UnaryInterceptor(orderUnaryServerInterceptor),
  		// 注册流式拦截器
  		grpc.StreamInterceptor(StreamingInterceptor),
  	)
  
  	// 注册服务
  	grpcServer.RegisterGrpcServiceServer(gsrv, GrpcServer{})
  	// 启动服务
  	gsrv.Serve(listen)
  }
  ```

##### 19.4.7.2 客户端拦截器

- 客户端拦截器和服务端拦截器类似，从请求开始按顺序执行拦截器，在获取到服务端响应之后，再按反向的顺序执行拦截器中对响应的处理逻辑

![image-20240421223850264](https://cloud.006288.xyz/PicGo//image-20240421223850264.png)

- **一元拦截器**

  - 一元拦截器是在客户端发起一元调用之前和之后执行的代码块。它可以用于实现一系列功能，比如认证、日志记录、错误处理等。一元拦截器通过实现`grpc.UnaryClientInterceptor`接口来定义, 签名如下

  ```go
  func(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, invoker UnaryInvoker, opts ...CallOption) error
  
  // ctx: 上下文，包含了请求的相关信息。
  // method: 调用的方法名。
  // req: 请求消息。
  // reply: 响应消息。
  // cc: 客户端连接。
  // invoker: 用于调用下一个拦截器或RPC函数的函数。
  // opts: 调用选项
  ```

  - 与前面介绍的服务器端一元拦截器一样，客户端一元拦截器也有以下的处理阶段：

    - 前置阶段。在前置处理阶段，可以在调用远程方法之前拦截 RPC，还可以通过检查传入的参数来访问关于当前 RPC 的信息（如 RPC 的上下文、方法字符串、要发送的请求以及 CallOption 配置），甚至可以在原始的 RPC 发送至服务器端应用程序之前，对其进行修改。随后，借助 UnaryInvoker 参数，可以调用实际的一元 RPC ；

    - 后置阶段。在后置处理阶段，可以访问 RPC 的响应结果或错误结果

  - 若要在 ClientConn 上安装一元拦截器，需使用 DialOptionWithUnaryInterceptor 的 DialOption 配置 Dial

  ```go
  // 编写拦截器
  
  // 客户端一元拦截器
  func UnaryClientInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
  	// 在发起请求之前执行的代码
  	log.Println("Sending request for method:", method)
  	log.Println("Request:", req)
  
  	// 记录请求时间
  	start := time.Now()
  
  	// 调用下一个拦截器或处理器
  	err := invoker(ctx, method, req, reply, cc, opts...)
  
  	// 在请求完成之后执行的代码
  	log.Println("Received response for method:", method)
  	log.Println("Response:", reply)
  	log.Println("Request completed in:", time.Since(start))
  
  	return err
  }
  
  
  // 注册拦截器
  func main() {
  	//credens, err := credentials.NewClientTLSFromFile("E:\\GoCode\\grpcStuday\\key\\server.pem", "*.kubei.net")
  	//if err != nil {
  	//	log.Fatalf("failed to load client certificates: %v", err)
  	//}
  
  	// 实例化mytoken
  	mytoken := MyToken{AppID: "kubei", AppSecret: "zxcvbnmQAZ123"}
  
  	opts := []grpc.DialOption{
  		grpc.WithPerRPCCredentials(&mytoken),
  		grpc.WithTransportCredentials(insecure.NewCredentials()),
  		// 注册拦截器
  		grpc.WithUnaryInterceptor(UnaryClientInterceptor),
  	}
  
  	// 建立连接
  	l, err := grpc.DialContext(context.Background(), "localhost:9999", opts...)
  	if err != nil {
  		log.Println("连接失败", err)
  		return
  	}
  	defer l.Close()
  	client := grpcServer.NewGrpcServiceClient(l)
  
  	// 一元rpc
  	fmt.Println("########################### 一元rpc ##########################")
  	getinfo_client(client)
  }
  ```

- **流式拦截器**

  - 流式拦截器是在客户端发起流式调用之前和之后执行的代码块。它可以用于实现一系列功能，比如认证、日志记录、错误处理等。流式拦截器通过实现`grpc.StreamClientInterceptor`接口来定义, 其签名如下:

  ```go
  func(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, streamer Streamer, opts ...CallOption) (ClientStream, error)
  
  // ctx: 上下文，包含了请求的相关信息。
  // desc: 流式调用描述符。
  // cc: 客户端连接。
  // method: 调用的方法名。
  // streamer: 用于调用下一个拦截器或RPC函数的函数。
  // opts: 调用选项
  ```

  - 客户端流拦截器实现包括以下的前置处理和流操作拦截阶段：

    - 前置处理阶段。类似于上面的一元拦截器；

    - 流操作拦截阶段。流拦截器并没有事后进行 RPC 方法调用和后处理，而是拦截了用户在流上的操作。首先，拦截器调用传入的 streamer 以获取 ClientStream ，然后包装 ClientStream 并用拦截逻辑重载其方法，最后拦截器将包装好的 ClientStream 返回给用户进行操作

  ```go
  // 客户端流式拦截器
  func StreamClientInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) {
  	// 在发起流式调用之前记录日志
  	log.Printf("Starting stream for method: %s", method)
  
  	// 调用下一个拦截器或处理器
  	stream, err := streamer(ctx, desc, cc, method, opts...)
  
  	// 在流式调用完成之后记录日志
  	log.Printf("Finished stream for method: %s", method)
  
  	return stream, err
  }
  
  // 注册拦截器
  func main() {
  	// 实例化mytoken
  	mytoken := MyToken{AppID: "kubei", AppSecret: "zxcvbnmQAZ123"}
  
  	opts := []grpc.DialOption{
  		grpc.WithPerRPCCredentials(&mytoken),
  		grpc.WithTransportCredentials(insecure.NewCredentials()),
  		// 注册流式拦截器
  		grpc.WithStreamInterceptor(StreamClientInterceptor),
  	}
  
  	// 建立连接
  	l, err := grpc.DialContext(context.Background(), "localhost:9999", opts...)
  	if err != nil {
  		log.Println("连接失败", err)
  		return
  	}
  	defer l.Close()
  	client := grpcServer.NewGrpcServiceClient(l)
  
  	//	// 双向流式rpc
  	fmt.Println("########################### 双向流式rpc ##########################")
  	getinfo4_client(client)
  }
  
  ```

#### 19.4.8 grpc网关

- 前面我们已经对grpc已经有一个基本认识了,但是现在有一个问题是我们无法使用http直接访问, 同时也不能让每个客户端都执行porto文件生成grpc框架文件,因此我们需要让我们的服务端grpc服务能够提供RESTful 风格的访问方式, 那就引入了grpc网关----[gRPC-Gateway](https://github.com/grpc-ecosystem/grpc-gateway)
- gRPC-Gateway是protobuf编译器 `protoc` 的插件。它读取protobuf文件中`service` 定义的内容，并生成反向代理服务器( reverse-proxy server) ，该服务器可以将`RESTful API`转换为 `gRPC`，于是我们就可以像普通的HTTP1.x服务器一样使用JSON请求gRPC服务

- 在下图中以 gRPC 方式和 RESTful 方式调用 gRPC 服务，有一个 ProductInfo 服务契约，使用该契约构建了名为 ProductInfo 服务的 gRPC 服务

![image-20240422003429695](https://cloud.006288.xyz/PicGo//image-20240422003429695.png)

- 在之前的 gRPC 应用程序中，会构建一个 gRPC 客户端来与该 gRPC 服务进行交互，但在这里没有构建 gRPC 客户端，而是构建了一个反向代理服务。该服务为 gRPC 服务中的每个远程方法暴露了 RESTful API 并且接收了来自 REST 客户端的 HTTP 请求，之后，它会将请求翻译成 gRPC 消息，并调用后端服务的远程方法，来自后端服务器的响应消息会再次转换成 HTTP 响应，并发送给客户端

##### 19.4.8.1 gRPC-Gateway基本使用

- **安装gRPC-Gateway**
  - 使用 gRPC-Gateway 工具需要安装 protoc 的插件`gen-grpc-gateway`来生成对应的 grpc-gateway 代码

```go
go install github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway@latest
```

- 下载依赖包

  - 再项目工程创建`http.proto`和`annotations.proto`文件
  - 将github上[annotations.proto](https://github.com/googleapis/googleapis/blob/master/google/api/annotations.proto)文件复制到`annotations.proto`文件中
  - 将github上[http.proto](https://github.com/googleapis/googleapis/blob/master/google/api/http.proto)文件复制到`http.proto`文件中

![image-20240422232040935](https://cloud.006288.xyz/PicGo//image-20240422232040935.png)

- **生成gRPC-Gateway反向代理服务器**

  > 也可以使用[buf](https://grpc-ecosystem.github.io/grpc-gateway/docs/tutorials/adding_annotations/#generating-the-grpc-gateway-stubs)工具生成,它执行的效果和上文中protoc命令一样

  - 目前有三种方式可以反向代理服务器
    - 不做任何修改直接生成，`protoc-gen-grpc-gateway`会按照默认规则映射Method和参数等HTTP配置
    - 给protobuf添加annotations，可以自定义Method和Path等HTTP配置   **(本章节重点)**
    - 使用外部配置，比较适用于不能修改源protobuf的情况下

```protobuf
// 给protobuf添加annotations

syntax = "proto3";

package GrpcDemo;

option go_package = "../grpcServer";

// 导入依赖包
import "google/api/annotations.proto";


message UserRequest {
  string name = 1;
  int64 age = 2;
  string addr = 3;
}

message UserResponse {
  string userinfo = 1;
}

service GrpcService {
  // 一元rpc
  rpc Getinfo(UserRequest) returns (UserResponse) {
  	// 添加请求方法和路由
      option(google.api.http) = {
        get: "/api/v1/getInfo"
      };
  };
}
```

- 编译proto文件

```go
protoc --go_out=. --go_opt paths=source_relative --go-grpc_out=. --go-grpc_opt paths=source_relative --grpc-gateway_out=. --grpc-gateway_opt paths=source_relative demo.proto
```

- 编译后会生成三个文件

![image-20240422233141810](https://cloud.006288.xyz/PicGo//image-20240422233141810.png)

- **server端的实现**

```go
package main

import (
	"context"
	"fmt"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"grpcStuday/grpcServer"
	"net"
	"net/http"
	"sync"
)

const (
	grpcPort = ":8009"
	gwPort   = ":8010"
)

type GrpcServer struct {
	grpcServer.UnimplementedGrpcServiceServer
}

func (GrpcServer) Getinfo(ctx context.Context, req *grpcServer.UserRequest) (*grpcServer.UserResponse, error) {
	fmt.Println("收到客户都端请求")
	return &grpcServer.UserResponse{Userinfo: "收到信息"}, nil
}


// 对内访问
func startGRPCServer(wg *sync.WaitGroup) {
	defer wg.Done()

	lis, err := net.Listen("tcp", grpcPort)
	if err != nil {
		panic(err)
	}

	s := grpc.NewServer()

	grpcServer.RegisterGrpcServiceServer(s, &GrpcServer{})
	if err := s.Serve(lis); err != nil {
		panic(err)
	}
}

// 对外访问
func startGatewayServer(wg *sync.WaitGroup) {
	defer wg.Done()

	conn, err := grpc.DialContext(
		context.Background(),
		"localhost"+grpcPort,
		grpc.WithBlock(),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	gwmux := runtime.NewServeMux()
	err = grpcServer.RegisterGrpcServiceHandler(context.Background(), gwmux, conn)
	if err != nil {
		panic(err)
	}

	http.ListenAndServe(gwPort, gwmux)
}

func main() {
	wg := sync.WaitGroup{}

	wg.Add(2)
	go startGRPCServer(&wg)
	go startGatewayServer(&wg)
	wg.Wait()
}
```

![image-20240423002429724](https://cloud.006288.xyz/PicGo//image-20240423002429724.png)

##### 19.4.8.2 gRPC-Gateway参数获取

- 获取body参数
  - body参数会将所有body请求参数绑定到请求结构体上

```protobuf
message Mybody {
  string name = 1;
}

message UserRequest {
  string name = 1;
  int64 age = 2;
  Mybody Mybody = 3;
}

message UserResponse {
  string message = 1;
  string name = 2;
  Mybody Mybody = 3;
}



service GrpcService {
  // 一元rpc
  rpc Getinfo(UserRequest) returns (UserResponse) {
      option(google.api.http) = {
        post: "/v1/getInfo"
        body: "*"                // 解析所有请求参数
//        body: "name"           // 只解析指定字段
//        body: "Mybody"         // 只解析Mybody字段

      };
  };
}
```

```go
// 服务端修改

func (GrpcServer) Getinfo(ctx context.Context, req *grpcServer.UserRequest) (*grpcServer.UserResponse, error) {
	fmt.Println("收到客户都端请求")
	reqname := req.GetName()
	return &grpcServer.UserResponse{Message: "收到来自" + reqname + "的信息", Name: req.Name, Mybody: req.Mybody}, nil
}
```



![image-20240423010420518](https://cloud.006288.xyz/PicGo//image-20240423010420518.png)

> get方法不能写body字段, 获取参数从query获取

- 获取query参数
  - 只要没有再body中和url中申明的参数,默认从query获取

```go
service GrpcService {
  // 一元rpc
  rpc Getinfo(UserRequest) returns (UserResponse) {
      option(google.api.http) = {
        get: "/v1/getInfo"
      };
  };
}
```

![image-20240423004415724](https://cloud.006288.xyz/PicGo//image-20240423004415724.png)

![image-20240423011001227](https://cloud.006288.xyz/PicGo//image-20240423011001227.png)

- 获取动态路由参数(获取url参数)

```protobuf
service GrpcService {
  // 一元rpc
  rpc Getinfo(UserRequest) returns (UserResponse) {
      option(google.api.http) = {
        get: "/v1/getInfo/{name}/{age}/{Mybody.name}"
      };
  };
}
```

![image-20240423011151632](https://cloud.006288.xyz/PicGo//image-20240423011151632.png)

```protobuf
// 固定某个值
service GrpcService {
  // 一元rpc
  rpc Getinfo(UserRequest) returns (UserResponse) {
      option(google.api.http) = {
        get: "/v1/getInfo/{name=kubei}/{age}/{Mybody.name}"
      };
  };
}
```

![image-20240423011542531](https://cloud.006288.xyz/PicGo//image-20240423011542531.png)

- 请求方法
  - grpc支持许多http请求方法,我们可以查看[官方示例](https://github.com/googleapis/googleapis/blob/master/google/api/http.proto)

#### 19.4.9 错误处理

- 我们都知道当发起http请求的时候，服务端会返回一些http状态码，不管是成功还是失败。客户端可以根据服务端返回的状态码，判断服务器出现了哪些错误

- 同样的，当我们调用 gRPC 调用时，客户端会收到带有成功状态的响应或带有相应错误状态的错误。 客户端应用程序需要以能够处理所有潜在错误和错误条件的方式编写。 服务器应用程序要求您处理错误并生成具有相应状态代码的适当错误。

- 发生错误时，gRPC 会返回其错误状态代码之一以及可选的错误消息，该消息提供错误条件的更多详细信息。 状态对象由一个整数代码和一个字符串消息组成，这些消息对于不同语言的所有 gRPC 实现都是通用的

- gRPC 使用一组定义明确的 gRPC 特定状态代码。 这包括如下状态代码：[grpc状态码](https://github.com/grpc/grpc/blob/master/doc/statuscodes.md#status-codes-and-their-use-in-grpc)

  | Code                | Number | Description                                                  |
  | ------------------- | ------ | ------------------------------------------------------------ |
  | OK                  | 0      | 请求成功，成功状态                                           |
  | CANCELLED           | 1      | 操作已被（被调用）取消                                       |
  | UNKNOWN             | 2      | 未知错误，如果从另一个地址空间接收到的状态值属于在该地址空间中未知的错误空间，则可以返回此错误的示例，没有返回足够的错误信息的 API 引发的错误也可能会转换为此错误 |
  | INVALID_ARGUMENT    | 3      | 表示客户端指定的参数无效（注：这与 FailedPrecondition 不同），它表示无论系统状态如何都有问题的参数（如格式错误的文件名） |
  | DEADLINE_EXCEEDED   | 4      | 表示操作在完成之前已过期，超过截止时间，对于改变系统状态的操作，即使操作成功完成，也可能会返回此错误（如来自服务器的成功响应可能已延迟足够长的时间以使截止日期到期） |
  | NOT_FOUND           | 5      | 表示未找到某些请求的实体（如文件或目录）                     |
  | ALREADY_EXISTS      | 6      | 创建实体的尝试失败，因为实体已经存在                         |
  | PERMISSION_DENIED   | 7      | 表示调用者没有权限执行指定的操作， 它不能用于拒绝由耗尽某些资源引起的（使用 ResourceExhausted ）， 如果无法识别调用者，也不能使用它（使用 Unauthenticated ） |
  | RESOURCE_EXHAUSTED  | 8      | 表示某些资源已耗尽，可能是每个用户的配额，或者整个文件系统空间不足 |
  | FAILED_PRECONDITION | 9      | 指示操作被拒绝，因为系统未处于操作执行所需的状态（如要删除的目录可能是非空的，rmdir 操作应用于非目录等） |
  | ABORTED             | 10     | 表示操作被中止，通常是由于并发问题，如排序器检查失败、事务中止等 |
  | OUT_OF_RANGE        | 11     | 表示尝试超出有效范围的操作                                   |
  | UNIMPLEMENTED       | 12     | 表示此服务中未实施或不支持/启用操作                          |
  | INTERNAL            | 13     | 意味着底层系统预期的一些不变量已被破坏，若看到这个错误，则说明问题很严重 |
  | UNAVAILABLE         | 14     | 表示服务当前不可用，这很可能是暂时的情况，可以通过回退重试来纠正（请注意：重试非幂等操作并不总是安全的） |
  | DATA_LOSS           | 15     | 表示不可恢复的数据丢失或损坏                                 |
  | UNAUTHENTICATED     | 16     | 表示请求没有用于操作的有效身份验证凭据                       |

- `gRPC` 提供了`google.golang.org/grpc/status`来表示错误，这个结构包含了 `code` 和 `message` 两个字段
  - `code`是类似于`http status code`的一系列错误类型的枚举，所有语言 sdk 都会内置这个枚举列表
  - `message`就是服务端需要告知客户端的一些错误详情信息
- 无论是`server`和`client`返回的都是`error`，如果我们返回`Status`那肯定是不行的, 但 `Status` 提供了和`Error`互转的方法

![image-20240425221958406](https://cloud.006288.xyz/PicGo//image-20240425221958406.png)

- 在服务端当遇到错误时，gRPC 服务的方法函数应该创建一个 status.Status ，通常调用 status.New() 函数并传入适当的 status.Code 和错误描述来生成一个 status.Status ，调用 status.Err() 方法便能将一个 status.Status 转为 error 类型或者调用 status.Error() 方法直接生成 error

  > 在某些情况下，可能需要为服务器端的特定错误添加详细信息 ，status.WithDetails() 方法可以添加任意多个 proto.Message ，可以使用 google.golang.org/genproto/googleapis/rpc/errdetails 包中的定义或自定义的错误详情
  >

- 到客户端首先利用`status.FromError(err)`把`error`转回`Status`,后调用 status.Details() 方法来读取这些详细信息

- 示例

  - proto文件

  ```protobuf
  syntax = "proto3"; // 版本声明，使用 Protocol Buffers v3 版本
  
  option go_package = "../proto";  // 指定生成的 Go 代码在项目中的导入路径
  
  package pb; // 包名
  
  
  // 定义服务
  service Greeter {
      	// SayHello 方法
      	rpc SayHello (HelloRequest) returns (HelloResponse) {}
  }
  
  // 请求消息
  message HelloRequest {
      string name = 1;
  }
  
  // 响应消息
  message HelloResponse {
      string reply = 1;
  }
  ```

  - server端

  ```go
  package main
  
  import (
          "context"
          "fmt"
          pb "server/proto"
          "net"
          "sync"
          "google.golang.org/genproto/googleapis/rpc/errdetails"
          "google.golang.org/grpc"
          "google.golang.org/grpc/codes"
          "google.golang.org/grpc/status"
  )
  
  // grpc server
  
  type server struct {
          pb.UnimplementedGreeterServer
          mu    sync.Mutex     // count 的并发锁
          count map[string]int // 记录每个 name 的请求次数
  }
  
  // SayHello 是需要实现的方法对外提供的服务
  func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloResponse, error) {
          s.mu.Lock()
          defer s.mu.Unlock()
          s.count[in.Name]++ // 记录用户的请求次数
          // 超过 1 次就返回错误
          if s.count[in.Name] > 1 {
                  st := status.New(codes.ResourceExhausted, "Request limit exceeded.")
                  ds, err := st.WithDetails(
                          &errdetails.QuotaFailure{
                                  Violations: []*errdetails.QuotaFailure_Violation{{
                                          Subject:     fmt.Sprintf("name:%s", in.Name),
                                          Description: "限制每个 name 只能调用一次!",
                                  }},
                          },
                  )
                  if err != nil {
                          return nil, st.Err()
                  }
                  return nil, ds.Err()
          }
          // 正常返回响应
          reply := "hello " + in.GetName()
          return &pb.HelloResponse{Reply: reply}, nil
  }
  
  func main() {
          // 启动服务
          l, err := net.Listen("tcp", ":8972")
          if err != nil {
                  fmt.Printf("failed to listen, err:%v\n", err)
                  return
          }
          s := grpc.NewServer() // 创建 gRPC 服务
          // 注册服务，注意初始化 count
          pb.RegisterGreeterServer(s, &server{count: make(map[string]int)})
          // 启动服务
          err = s.Serve(l)
          if err != nil {
                  fmt.Printf("failed to serve,err:%v\n", err)
                  return
          }
  }
  ```

  - client端

  ```go
  package main
  
  import (
          "context"
          "flag"
          "fmt"
          "google.golang.org/grpc/status"
          pb "client/proto"
          "log"
          "time"
          "google.golang.org/genproto/googleapis/rpc/errdetails"
          "google.golang.org/grpc"
          "google.golang.org/grpc/credentials/insecure"
  )
  
  // gRPC 客户端
  // 调用 server 端的 SayHello() 方法
  
  var name = flag.String("name", "cqupthao", "通过 -name 告诉 server 你是谁")
  
  func main() {
          flag.Parse() // 解析命令行参数
  
          // 连接 server
          conn, err := grpc.Dial("127.0.0.1:8972", grpc.WithTransportCredentials(insecure.NewCredentials()))
                  if err != nil {
                          log.Fatalf("grpc.Dial failed,err:%v", err)
                          return
                  }
                  defer conn.Close()
                  // 创建客户端
                  c := pb.NewGreeterClient(conn) // 使用生成的 Go 代码
                  // 调用 RPC 方法
                  ctx, cancel := context.WithTimeout(context.Background(), time.Second)
                  defer cancel()
                  resp, err := c.SayHello(ctx, &pb.HelloRequest{Name: *name})
                  if err != nil {
                          s := status.Convert(err)        // 将 err 转为 status
                          for _, d := range s.Details() { // 获取 details
                                  switch info := d.(type) {
                                          case *errdetails.QuotaFailure:
                                                  fmt.Printf("Quota failure: %s\n", info)
                                          default:
                                                  fmt.Printf("Unexpected type: %s\n", info)
                                  }
                          }
                  fmt.Printf("c.SayHello failed, err:%v\n", err)
                  return
          }
          // 获取到 RPC 响应
          log.Printf("resp:%v\n", resp.GetReply())
  }
  ```
